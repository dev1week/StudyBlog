<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Hanju]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>Hanju</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 26 Nov 2024 02:03:59 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 26 Nov 2024 02:03:46 GMT</pubDate><copyright><![CDATA[1week]]></copyright><ttl>60</ttl><dc:creator>1week</dc:creator><item><title><![CDATA[ALB - Application Load Balancer]]></title><description><![CDATA[ 
 <br><br>
7계층에서 동작하는 로드밸런서 입니다. 트래픽을 균형있게 나누어줍니다.
<br><br>
트래픽을 여러 대상에 자동으로 분산시켜 안정적인 운용을 할 수 있습니다.
<br>
<br>EC2뿐만 아니라 컨테이너(ECS), 서버리스(Lambda) 등으로 다양한 서비스와 연계하여 부하를 분배할 수 있습니다.<br>

<br>서로 다른 EC2에 대한 하나의 엔드포인트를 제공합니다.<br>

<br>부하 분산 대상에 대한 헬스 체크, 고정 세션, ssl Offload, 다운서버 제외 기능을 제공합니다.<br>

<br><br><img src="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FuEVaLGfjsShiUrHBYllh%252Fimage.png%3Falt%3Dmedia%26token%3Df5a11a54-fadd-49e5-ad48-5973920829bc&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=af6f198d520aed36cd5bd6b758108b905fd27ff37c455b31fa04467eb73f43e1" referrerpolicy="no-referrer"><br><a rel="noopener nofollow" class="external-link" href="https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/application/introduction.html" target="_blank">https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/application/introduction.html</a><br>
<br>
위 사진과 같이 Load Balancer, Listener, Target Group으로 나누어져 있습니다.

<br>
기본적으로 VPC에 탑재되며 사용자 요청을 받고, 이를 VPC 내의 리소스에 적절히 부하분산합니다.

<br>
외부의 요청을 받아들이는 리스너, 요청을 분산 전달할 수 있는 리소스의 집합인 대상그룹으로 구성됩니다.

<br>
ELB는 다수의 리스너와 대상 그룹을 거느릴 수 있습니다.

<br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/alb-application-load-balancer/undefined" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/alb-application-load-balancer/undefined" target="_blank">PAGE구성요소</a><br><br>
<br>
앱의 트래픽을 여러 가용영역으로 분산합니다.

<br>
리스너를 이용해 RL, 호스트, 헤더, 메소드를 기반으로 규칙을 구성하여 요청을 처리할 수 있습니다.

<br>
트래픽 부하에 따라 자동으로 스케일 업, 다운을 수행할 수 있습니다.

<br>
하나 이상 타겟 그룹에 라우팅할 수 있으며 각 그룹별 가중치 설정이 가능합니다.

<br>
SSL Offloading을 지원합니다.

<br>
디폴트 알고리즘은 라운드 로빈이며, 최소 미해결 요청 라우팅 알고리즘을 지원합니다.

<br>
교차 영역 로드 밸런싱을 통해 AZ의 모든 타겟 그룹에 트래픽을 분산합니다.

<br><a data-href="고가용성 및 스케일링" href="고가용성 및 스케일링" class="internal-link" target="_self" rel="noopener nofollow">고가용성 및 스케일링</a>]]></description><link>0.-aws/1.-고가용성-및-스케일링/alb/alb.html</link><guid isPermaLink="false">0. AWS/1. 고가용성 및 스케일링/ALB/ALB.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 07:09:51 GMT</pubDate><enclosure url="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FuEVaLGfjsShiUrHBYllh%252Fimage.png%3Falt%3Dmedia%26token%3Df5a11a54-fadd-49e5-ad48-5973920829bc&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=af6f198d520aed36cd5bd6b758108b905fd27ff37c455b31fa04467eb73f43e1" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FuEVaLGfjsShiUrHBYllh%252Fimage.png%3Falt%3Dmedia%26token%3Df5a11a54-fadd-49e5-ad48-5973920829bc&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=af6f198d520aed36cd5bd6b758108b905fd27ff37c455b31fa04467eb73f43e1&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[고가용성]]></title><description><![CDATA[<a class="tag" href="?query=tag:AWS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWS</a> 
 <br><br><br>
고가용성은 시스템이 예상치 못한 장애나 문제에도 계속해서 가용하고 작동하는 능력을 가리킵니다. 이는 시스템의 가용성을 유지하기 위해 여러 가용 영역에 걸쳐 리소스를 분산하는 등의 방법을 포함할 수 있습니다.
<br><br><br>
스케일링은 시스템이 사용자 또는 트래픽 증가에 유연하게 대응할 수 있는 능력을 의미합니다. 이는 자동으로 리소스를 확장하거나 축소하여 수요에 맞게 조정하는 것을 포함할 수 있습니다.
<br><br><br>
<br>Elastic Load Balancing (ELB):

<br>고가용성: ELB는 여러 가용 영역에 걸쳐 로드 밸런싱을 수행하여 장애 발생 시에도 트래픽을 안정적으로 분산합니다.
<br>스케일링: ELB는 Auto Scaling 그룹과 통합하여 자동으로 인스턴스를 확장하거나 축소하여 트래픽에 대응합니다.


<br>Amazon EC2 Auto Scaling:

<br>고가용성: Auto Scaling은 여러 가용 영역에 인스턴스를 배포하여 고가용성을 제공하며, 인스턴스 장애 시 자동으로 대체 인스턴스를 시작합니다.
<br>스케일링: Auto Scaling은 정의된 조건에 따라 자동으로 인스턴스를 확장하거나 축소하여 트래픽에 대응합니다.


<br>Amazon RDS Multi-AZ (Multi-Availability Zone) Deployment:

<br>고가용성: RDS Multi-AZ는 프라이머리 데이터베이스와 스탠바이 데이터베이스를 여러 가용 영역에 걸쳐 설정하여 장애 발생 시 자동으로 스위치하여 가용성을 제공합니다.
<br>스케일링: RDS는 수동 또는 자동 스케일링을 통해 데이터베이스 인스턴스의 크기를 조정할 수 있습니다.


<br><a data-href="ALB" href="0.-aws/1.-고가용성-및-스케일링/alb/alb.html" class="internal-link" target="_self" rel="noopener nofollow">ALB</a><br><a href=".?query=tag:AWS" class="tag" target="_blank" rel="noopener nofollow">#AWS</a>]]></description><link>0.-aws/1.-고가용성-및-스케일링/1.-고가용성-및-스케일링.html</link><guid isPermaLink="false">0. AWS/1. 고가용성 및 스케일링/1. 고가용성 및 스케일링.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 10:42:07 GMT</pubDate></item><item><title><![CDATA[0 CloudFormation]]></title><description><![CDATA[ 
 <br>1.Cloud Formation이란?<br>
AWS 리소스 생성 및 배포 자동화 템플릿 서비스입니다.
<br>
<br>AWS 리소스를 모델링하고 설정합니다.

<br>리소스 관리 시간을 줄일 수 있습니다.


<br>AWS 리소스를 설명하는 템플릿(=코드)를 생성하면 리소스의 프로비저닝과 구성을 담당합니다.
<br><br><br><img src="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FSGEXGnQfYFl1GV94AXeZ%252Fimage.png%3Falt%3Dmedia%26token%3Dbc8a4eca-5c7a-4f79-bdfa-432e12b2e396&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=c1ce24f89c350ac9d93c8516d900243166fce2b0bc7954435800b0b33facf49a" referrerpolicy="no-referrer"><br>
<br>Cloud Front에서 실행하는 호출은 모두 템플릿으로 선언됩니다.
<br>해당 템플릿을 local이나 S3에 저장합니다.
<br>Cloudformation에서 템플릿을 활용해 AWS 리소스를 생성하고 스택을 생성합니다.
<br><br><br><br>
리소스 모음을 단일 단위(스택)으로 쉽게 관리할 수 있습니다.
<br><br>
각 개별 서비스를 사용하여 프로비저닝해야하고 서비스간 연동을 진행해야합니다. 모든 작업을 마치고 애플리케이션을 제대로 실행하려면 복잡하고 많은 시간이 소요됩니다.
<br><br>
모든 리소스와 속성을 설명하는 템플릿을 사용합니다. 템플릿을 사용하여 Cloudfront에서 스택을 생성할 경우 필요한 서비스를 자동으로 프로비저닝합니다. 스택의 삭제, 관리가 용이합니다.
<br><br>
가용성을 확대해야하는 경우 여러 리전에서 애플리케이션을 복제할 수 있습니다.
<br><br>
복제시, 애플리케이션에 필요한 모든 AWS 서비스를 숙지, 각 리전에서 해당 서비스를 다시 구성해야합니다.
<br><br>
템플릿을 재사용하여 리소스를 일관되고 반복적으로 생산할 수 있습니다. 또한 여러 리전에서 동일한 리소스를 반복적으로 프로비저닝할 수 있습니다.
<br><br><br>
애플리케이션을 업데이트하고 문제가 발생할 경우 원래 설정으로 롤백해야합니다.<br>
변경된 리소스를 기억하고 원래 설정을 알고 다시 수동으로 복구해야합니다.
<br><br>
템플릿에서 차이점을 추적하여 인프라 변경사항을 추적할 수 있습니다. 형상관리시스템(git)을 활용하여 변경 내용, 변경 시간, 변경한 사람을 정확히 알 수 있습니다. 이전 버전으로 되돌려야할 경우 이전 버전의 템플릿을 사용하면 됩니다.
<br><br><br>
<br>
리소스에 대한 이해가 낮으면 사용하기가 어렵습니다.

<br>
배포에 필요한 모든 옵션을 직접 활용하기에는 설정이 많습니다.<br>


<br>
json, yaml 문법에서 각 참조 방식이 난해합니다.

<br>java같은 곳에서는 ctrl 키를 눌러 해당 함수의 구현체로 바로 이동이 가능합니다.
<br>반면에 json은 데이터를 표현하는 포멧이기 때문에 참조값 추적이 난해합니다.


<br>]]></description><link>0.-aws/1.-iac/cloudformation/0-cloudformation.html</link><guid isPermaLink="false">0. AWS/1. IaC/CloudFormation/0 CloudFormation.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 10:42:28 GMT</pubDate><enclosure url="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FSGEXGnQfYFl1GV94AXeZ%252Fimage.png%3Falt%3Dmedia%26token%3Dbc8a4eca-5c7a-4f79-bdfa-432e12b2e396&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=c1ce24f89c350ac9d93c8516d900243166fce2b0bc7954435800b0b33facf49a" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FSGEXGnQfYFl1GV94AXeZ%252Fimage.png%3Falt%3Dmedia%26token%3Dbc8a4eca-5c7a-4f79-bdfa-432e12b2e396&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=c1ce24f89c350ac9d93c8516d900243166fce2b0bc7954435800b0b33facf49a&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[스택]]></title><description><![CDATA[ 
 <br><br>
CloudFormation에서는 스택이라는 하나의 단위로 리소스들을 관리합니다.
<br><br>
<br>스택이라는 하나의 단위로 리소스를 관리합니다.<br>

<br>스택의 모든 리소스는 스택의 CloudFormation 템플릿으로 정의합니다.<br>

<br>스택에서 실행 중인 리소스를 변경해야하는 경우 스택을 업데이트합니다.<br>

<br><br>
스택의 설정을 변경하거나 리소스를 변경하는 경우 스택 업데이트를 이용해서 간편하게 변경할 수 있습니다.
<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-1" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-1" target="_blank"></a><br>2-1. 원리<br>
<br>변경사항(새 입력 파라미터 값 또는 업데이트된 템플릿)을 작성합니다.
<br>CloudFormation에서는 제출한 변경사항과 스택의 현재 상태를 비교하여 변경된 리소스만 업데이트합니다.
<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-2" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-2" target="_blank"></a><br>2-2. 업데이트 방법<br>
직접 업데이트와 변경 세트 생성 및 실행 총 두 가지 방법을 제공합니다.
<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#a" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#a" target="_blank"></a><br>a. 스택을 직접 업데이트<br>
<br>변경사항을 제출합니다.<br>

<br>AWS CloudFormation에서 즉시 해당사항을 배포합니다.<br>

<br>업데이트를 빠르게 배포할 때 사용합니다.<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#b" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#b" target="_blank"></a><br>b. 변경 세트 사용<br>
<br>AWS CloudFormation에서 스택에 대해 변경사항을 미리 확인합니다.
<br>변경사항을 적용할지 결정합니다.
<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-3" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-3" target="_blank"></a><br>2-3 스택 리소스의 업데이트 동작<br>
업데이트한 리소스의 경우 AWS CloudFormation에서는 다음 동작 중 하나를 사용합니다.
<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#a-1" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#a-1" target="_blank"></a><br>a.업데이트(무중단)<br>
해당 리소스의 작동을 중단하지 않고, 리소스의 물리적 ID를 변경하지 않는 상태에서 리소스를 업데이트합니다.
<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#b-1" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#b-1" target="_blank"></a><br>b.업데이트(중단)<br>
리소스를 업데이트하지만, 다소 중단이 발생합니다.
<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#c" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#c" target="_blank"></a><br>c.대체<br>
업데이트 도중 리소스를 다시 생성하며, 물리적 ID도 생성합니다.
<br>일반적인 방법은 아래와 같습니다.<br>
<br>리소스를 먼저 생성합니다.
<br>대체 리소스를 가리키도록 종속 리소스의 참조를 변경합니다
<br>이전 리소스를 삭제합니다.
<br>AWS 리소스 유형에 따라 업데이트하는 속성이 달라집니다. 각 속성에 대한 업데이트 동작은 <a data-tooltip-position="top" aria-label="https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html" rel="noopener nofollow" class="external-link" href="https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html" target="_blank">AWS 리소스 유형 참조</a>에 설명되어 있습니다.<br><br><a data-tooltip-position="top" aria-label="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-3.-aws" rel="noopener nofollow" class="external-link" href="https://hanju.gitbook.io/studynote/aws/iac/cloud-formation/undefined-1#id-2-3.-aws" target="_blank"></a><br>2-3. AWS 리소스를 대체해야하는 경우 설정하기<br>
RDS의 Port를 업데이트하는 경우 CloudFormation에서는 업데이트된 포트 설정을 사용하여 새 DB 인스턴스를 생성하고 대체하여 무중단 배포를 구성할 수 있습니다. 방법은 아래와 같습니다.
<br>
<br>현재 DB의 스냅샷을 생성합니다.
<br>DB 인스턴스를 바꾸는 동안 해당 DB를 사용하는 앱에서 중단을 처리할 방법을 준비합니다.
<br>앱에서 업데이트된 포트 설정과 기타 고려사항이 적용되었는지 확인합니다.
<br>DB 스냅샷을 사용하여 새 DB 인스턴스에서 정보를 복원합니다.
]]></description><link>0.-aws/1.-iac/cloudformation/스택.html</link><guid isPermaLink="false">0. AWS/1. IaC/CloudFormation/스택.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 06:53:02 GMT</pubDate></item><item><title><![CDATA[템플릿이란?]]></title><description><![CDATA[ 
 <br><br><br>
AWS 리소스 구축을 위한 청사진입니다.
<br>
<br>.json, .yaml, .template, .txt 등을 사용합니다.
<br><br><br>
ami-0ff8a91507f77f867 AMI ID, t2.micro 인스턴스 유형, testkey 키 페어 이름 및 Amazon EBS 볼륨을 사용하여 인스턴스를 프로비저닝하는 예시입니다.
<br><br>{
    "AWSTemplateFormatVersion": "2010-09-09",
    "Description": "A sample template",
    "Resources": {
        "MyEC2Instance": {
            "Type": "AWS::EC2::Instance",
            "Properties": {
                "ImageId": "ami-0ff8a91507f77f867",
                "InstanceType": "t2.micro",
                "KeyName": "testkey",
                "BlockDeviceMappings": [
                    {
                        "DeviceName": "/dev/sdm",
                        "Ebs": {
                            "VolumeType": "io1",
                            "Iops": 200,
                            "DeleteOnTermination": false,
                            "VolumeSize": 20
                        }
                    }
                ]
            }
        }
    }
}
<br><br>AWSTemplateFormatVersion: 2010-09-09
Description: A sample template
Resources:
  MyEC2Instance:
    Type: 'AWS::EC2::Instance'
    Properties:
      ImageId: ami-0ff8a91507f77f867
      InstanceType: t2.micro
      KeyName: testkey
      BlockDeviceMappings:
        - DeviceName: /dev/sdm
          Ebs:
            VolumeType: io1
            Iops: 200
            DeleteOnTermination: false
            VolumeSize: 20
<br><br><br>
템플릿에는 여러 주요 섹션이 포함되어 있습니다.
<br>
<br>Resources 섹션만 필수 섹션입니다.<br>

<br><br>
기본적으로는 임의 순서대로 지정이 가능하지만, 이전 섹션을 참고할 수 있습니다. 때문의 다음 순서를 사용하는 것이 좋습니다.
<br><br><br><br><br>
AWSTemplateFormatVersion 섹션은 템플릿의 기능을 식별합니다. 최신 템플릿 포맷 버전은 2010-09-09이며 현재 유일한 유효 값입니다.
<br>
<br>값을 지정하지 않을 경우 최신 버전이라고 가정합니다.<br>

<br>리터럴 문자이어야합니다.<br>

<br>파라미터나 함수를 사용해 포맷 버전을 지정할 수 있습니다.<br>

<br><br>"AWSTemplateFormatVersion" : "2010-09-09"
<br><br>AWSTemplateFormatVersion: "2010-09-09"
<br><br>
템플릿의 Description 섹션(선택 사항)에 템플릿에 대한 설명을 지정합니다.
<br>
<br>0~1023 바이트 길이의 리터럴 문자열이어야 합니다.
<br>파라미터나 함수를 사용할 수 없습니다.
<br>업데이트 중 수정이 불가능합니다.
<br><br>"Description" : "Here are some details about the template."
<br><br>Description: &gt;
  Here are some
  details about
  the template.
]]></description><link>0.-aws/1.-iac/cloudformation/템플릿.html</link><guid isPermaLink="false">0. AWS/1. IaC/CloudFormation/템플릿.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 07:01:53 GMT</pubDate></item><item><title><![CDATA[<font color="#8064a2">IaC Overview</font>]]></title><description><![CDATA[<a class="tag" href="?query=tag:AWS" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AWS</a> 
 <br><br><br>IaC는 "Infrastructure as Code"의 약자로, 인프라스트럭처를 코드로 정의하고 관리하는 방식을 가리킵니다. 이는 개발자나 시스템 관리자가 코드를 사용하여 인프라 리소스를 프로비저닝하고 구성하는 것을 의미합니다.<br><br><br>
<br>
일관성: 코드로 정의된 인프라는 반복 가능하며, 인프라 구성이 일관되고 예측 가능하게 됩니다.

<br>
자동화: 코드를 통해 인프라를 프로비저닝하고 구성함으로써, 반복적이고 수동적인 작업을 자동화할 수 있습니다.

<br>
버전 관리: 코드로 정의된 인프라는 버전 관리 시스템을 통해 관리될 수 있으며, 변경 이력을 추적하고 롤백할 수 있습니다.

<br>
안정성: IaC를 사용하면 실수를 줄이고, 변경 사항에 대한 테스트 및 검증을 수행할 수 있으므로 시스템의 안정성이 향상됩니다.

<br>
유연성: 코드로 정의된 인프라는 변경에 대응하기 쉽습니다. 새로운 요구 사항이나 확장성이 필요한 경우 코드를 수정하여 인프라를 업데이트할 수 있습니다.

<br><br><br>주요한 IaC 도구로는 AWS CloudFormation, Terraform, Ansible, Chef, Puppet 등이 있습니다. 이러한 도구들을 사용하여 개발자와 운영팀은 코드를 통해 인프라를 효율적으로 관리하고 운영할 수 있습니다.<br><a href=".?query=tag:AWS" class="tag" target="_blank" rel="noopener nofollow">#AWS</a><br><a data-href="0 CloudFormation" href="0.-aws/1.-iac/cloudformation/0-cloudformation.html" class="internal-link" target="_self" rel="noopener nofollow">0 CloudFormation</a>]]></description><link>0.-aws/1.-iac/1.-iac.html</link><guid isPermaLink="false">0. AWS/1. IaC/1. IaC.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 14:40:31 GMT</pubDate></item><item><title><![CDATA[AWS]]></title><description><![CDATA[<a class="tag" href="?query=tag:Root" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Root</a> 
 <br><br>AWS는 "Amazon Web Services"의 약자로, 아마존이 제공하는 클라우드 컴퓨팅 플랫폼 및 서비스를 가리킵니다. AWS는 인프라스트럭처(서버, 스토리지, 네트워킹 등)부터 데이터베이스, 인공지능, 머신 러닝, 개발 도구, 보안, 분석, 그리고 IoT와 같은 다양한 기술 스택을 제공합니다. 이를 통해 기업이나 개발자들은 필요한 인프라를 프로비저닝하고 애플리케이션을 배포하며, 스케일링하고 관리하는 등의 작업을 AWS의 클라우드 플랫폼을 통해 수행할 수 있습니다. <br><br>
<br>확장성 및 유연성: AWS는 필요에 따라 리소스를 확장하거나 축소할 수 있는 유연한 인프라를 제공합니다. 개발자는 애플리케이션의 수요가 변할 때 쉽게 대응할 수 있습니다.
<br>다양한 서비스: AWS는 다양한 서비스를 제공하여 개발자가 필요로 하는 모든 것을 하나의 플랫폼에서 제공합니다. 데이터베이스, 스토리지, 컴퓨팅, 인공지능, 머신 러닝, 보안, IoT 등의 다양한 서비스를 활용할 수 있습니다.
<br>비용 효율성: AWS는 사용한 만큼 비용을 지불하는 Pay-As-You-Go 모델을 채택하고 있어, 개발자는 실제로 사용한 리소스에 대해서만 비용을 지불하게 됩니다. 또한 예약 인스턴스 및 스팟 인스턴스와 같은 할인 모델도 제공하여 비용을 절감할 수 있습니다.
<br>보안: AWS는 업계 표준을 준수하며, 다양한 보안 도구 및 서비스를 제공하여 개발자가 애플리케이션을 안전하게 운영할 수 있도록 지원합니다. 이는 데이터 보안, 네트워크 보안, 액세스 제어 및 모니터링 등을 포함합니다.
<br>글로벌 인프라: AWS는 전 세계에 걸쳐 다양한 리전과 가용 영역을 제공하여 개발자가 애플리케이션을 전 세계적으로 배포하고 사용자에게 접근할 수 있도록 합니다.
<br>자동화 및 관리: AWS는 다양한 자동화 도구와 관리 서비스를 제공하여 개발자가 애플리케이션을 효율적으로 관리하고 유지보수할 수 있도록 지원합니다. 예를 들어, AWS Elastic Beanstalk, AWS Lambda, AWS CloudFormation 등의 서비스를 통해 개발 및 배포 과정을 자동화할 수 있습니다.
<br><a data-href="1. 고가용성 및 스케일링" href="0.-aws/1.-고가용성-및-스케일링/1.-고가용성-및-스케일링.html" class="internal-link" target="_self" rel="noopener nofollow">1. 고가용성 및 스케일링</a><br>
<a data-href="1. IaC" href="0.-aws/1.-iac/1.-iac.html" class="internal-link" target="_self" rel="noopener nofollow">1. IaC</a><br><a href=".?query=tag:Root" class="tag" target="_blank" rel="noopener nofollow">#Root</a>]]></description><link>0.-aws/0.-aws.html</link><guid isPermaLink="false">0. AWS/0. AWS.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 14:40:47 GMT</pubDate></item><item><title><![CDATA[구조 패턴]]></title><description><![CDATA[ 
 <br><br>
클래스와 객체를 효율적으로 구성하여 더 큰 구조를 형성하고, 서로 간의 관계를 단순화하고 유연하게 만드는 디자인 패턴의 한 유형입니다.
<br><br>
<br><a data-href="데코레이터" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/데코레이터.html" class="internal-link" target="_self" rel="noopener nofollow">데코레이터</a>: 객체에 동적으로 새로운 행동이나 상태를 추가할 수 있게 해주는 패턴.
<br><a data-href="복합체" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/복합체.html" class="internal-link" target="_self" rel="noopener nofollow">복합체</a>(Composite): 객체들을 트리 구조로 구성하여 부분-전체 계층을 구현하고, 개별 객체와 복합 객체를 동일하게 다루는 패턴.
<br><a data-href="브리지" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/브리지.html" class="internal-link" target="_self" rel="noopener nofollow">브리지</a>(Bridge): 추상적인 부분과 구체적인 구현 부분을 분리하여 독립적으로 변형할 수 있게 해주는 패턴.
<br><a data-href="어댑터" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/어댑터.html" class="internal-link" target="_self" rel="noopener nofollow">어댑터</a> (Adapter): 기존 인터페이스를 다른 인터페이스로 변환하여 호환되지 않는 인터페이스들 간의 협력을 가능하게 해주는 패턴.
<br><a data-href="파사드" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/파사드.html" class="internal-link" target="_self" rel="noopener nofollow">파사드</a> (Facade): 서브시스템에 대한 간단한 인터페이스를 제공하여 복잡한 서브시스템을 쉽게 사용할 수 있게 해주는 패턴.
<br><a data-href="프록시" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/프록시.html" class="internal-link" target="_self" rel="noopener nofollow">프록시</a> (Proxy): 다른 객체에 대한 접근을 제어하기 위해 대리자나 자리 채움 객체를 제공하는 패턴.
<br><a data-href="플라이웨이트" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/플라이웨이트.html" class="internal-link" target="_self" rel="noopener nofollow">플라이웨이트</a> (Flyweight): 다수의 작은 객체들을 효율적으로 지원하기 위해 공유를 통해 메모리를 절약하는 패턴.
<br> : ]]></description><link>0.-clean-code/1.-design-pattern/2.-구조-패턴/2.-구조-패턴.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 구조 패턴/2. 구조 패턴.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 12:00:12 GMT</pubDate></item><item><title><![CDATA[데코레이터]]></title><description><![CDATA[ 
 ]]></description><link>0.-clean-code/1.-design-pattern/2.-구조-패턴/데코레이터.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 구조 패턴/데코레이터.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:05:49 GMT</pubDate></item><item><title><![CDATA[플라이웨이트]]></title><description><![CDATA[ 
 ]]></description><link>0.-clean-code/1.-design-pattern/2.-구조-패턴/플라이웨이트.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 구조 패턴/플라이웨이트.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:06:02 GMT</pubDate></item><item><title><![CDATA[생성 패턴]]></title><description><![CDATA[ 
 <br><br>
객체 생성 메커니즘을 다루는 디자인 패턴의 한 유형입니다.
<br><br>
<br><a data-href="빌더" href="0.-clean-code/1.-design-pattern/2.-생성-패턴/빌더.html" class="internal-link" target="_self" rel="noopener nofollow">빌더</a> (Builder): 객체의 생성 과정을 단계별로 나누고, 다양한 표현을 통해 동일한 생성 절차를 수행할 수 있게 하는 패턴.
<br><a data-href="싱글톤" href="0.-clean-code/1.-design-pattern/2.-생성-패턴/싱글톤.html" class="internal-link" target="_self" rel="noopener nofollow">싱글톤</a> (Singleton): 클래스의 인스턴스를 하나만 생성하여 전역에서 접근할 수 있도록 보장하는 패턴.
<br><a data-href="추상 팩토리" href="0.-clean-code/1.-design-pattern/2.-생성-패턴/추상-팩토리.html" class="internal-link" target="_self" rel="noopener nofollow">추상 팩토리</a> (Abstract Factory): 관련된 객체들을 구체적인 클래스에 의존하지 않고 생성할 수 있게 해주는 인터페이스를 제공하는 패턴.
<br><a data-href="팩토리" href="0.-clean-code/1.-design-pattern/2.-생성-패턴/팩토리.html" class="internal-link" target="_self" rel="noopener nofollow">팩토리</a>(Factory Method): 객체 생성을 서브클래스에서 정의할 수 있도록 하여 객체 생성의 인터페이스를 정의하지만, 실제 객체 생성은 서브클래스에서 처리하는 패턴.
<br><a data-href="프로토타입" href="0.-clean-code/1.-design-pattern/2.-생성-패턴/프로토타입.html" class="internal-link" target="_self" rel="noopener nofollow">프로토타입</a>(Prototype): 새 객체를 생성할 때, 기존 객체를 복사하여 생성하는 패턴.
]]></description><link>0.-clean-code/1.-design-pattern/2.-생성-패턴/2.-생성-패턴.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 생성 패턴/2. 생성 패턴.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:58:52 GMT</pubDate></item><item><title><![CDATA[문제]]></title><description><![CDATA[ 
 <br><br><br>다음과 같은 House  클래스가 있다고 가정해봅시다. <br>
class House{
	private String windows;
	private String doors;
	private String rooms; 

	public House(String windows, String doors, String rooms ){
		this.windows = windows;
		this.doors = doors;
		this.rooms = rooms 
	}

}

<br>요구 사항이 바뀌어 내부에 차고, 수영장, 정원을 나타내야하는 속성이 들어가야하면 어떻게 될까요?<br>
<img src="https://i.imgur.com/CqBwkE3.png" referrerpolicy="no-referrer"><br>아래 코드처럼 변수가 늘어날 때마다, 생성자가 매우 못갱겨집니다. 심지어 사용하지 않는 변수의 경우 객체 생성시, 굳이 임의의 값을 넣어야 합니다. 때문에 버그가 발생할 수 있습니다. <br>
class House{
	private String windows;
	private String doors;
	private String rooms; 
	private String garage;
	private String pool;
	private String garden; 

	public House(String windows, String doors, String rooms,
				String garage, String pool, String garden 
	){
		this.windows = windows;
		this.doors = doors;
		this.rooms = rooms;
		this.garage = garage;
		this.pool = pool;
		this.garden = garden; 
	}

}

<br><br>
자신의 클래스에서 객체 생성 코드를 추출하여 builders라는 별도의 객체로 이동합니다. 
<br>객체 생성을 일련의 단계들로 정리합니다. 객체를 생성하고 싶으면 위 단계를 builder 객체에 실행합니다. 모든 타입에 대해서 빌더를 호출할 필요가 없으므로, 필요한 필드의 빌더만 호출해도 됩니다.<br><br><img src="https://i.imgur.com/FXOveNJ.png" referrerpolicy="no-referrer"><br><br>
빌더 단계들에 대한 일련의 호출을 디렉터라는 별도의 클래스로 추출할 수 있습니다. 
<br>
<br>디렉터 클래스는 실행순서를 정의하고 빌더는 이 단계들에 대한 구현을 제공합니다. 
<br>디렉터 클래스를 만드는 것은 필수사항은 아닙니다. 
<br>디렉터 클래스는 클라이언트 코드에서 제품 생성의 세부 정보를 완전히 숨깁니다. 
<br>클라이언트는 빌더를 디렉터와 연관시키고 디렉터와 생성을 시행한 후 빌더로부터 결과를 얻기만 하면됩니다. 
<br><br>
다음 예제는 자동차 클래스를 생성할 때, 동일한 생성자를 재사용하는 빌더 패턴을 보여줍니다. 
<br><img src="https://i.imgur.com/cXNHGt3.png" referrerpolicy="no-referrer"><br>Car 클래스는 수백가지 방법으로 생성될 수 있는 복잡한 객체입니다. 거대한 생성자를 사용하는 대신, Car Builder 클래스로 추출하여 객체를 생성합니다. Builder 클래스에는 자동차의 다양한 부분을 설정하기 위한 메서드 집합이 존재합니다. <br>클라이언트는 빌더를 직접 호출하거나, 디렉터 클래스로 위임할 수 있습니다.<br><br>
제품 객체들의 다른 부분을 만드는 메서드를 정의합니다. 
<br>interface Builder {
    void reset(); // 초기화 메서드
    void setSeats(int seats); // 좌석 설정 메서드
    void setEngine(Engine engine); // 엔진 설정 메서드
    void setTripComputer(boolean tripComputer); // 트립 컴퓨터 설정 메서드
    void setGPS(boolean gps); // GPS 설정 메서드
}
<br><br>
빌더 인터페이스의 구현체입니다. 각기 다르게 두현된 여러가지 빌더 변형이 있을 수 있습니다. 
<br>class CarBuilder implements Builder {
    private Car car; // 자동차 객체

    public CarBuilder() {
        this.reset(); // 빌더 초기화
    }

    public void reset() {
        this.car = new Car(); // 새로운 자동차 객체 생성
    }

    public void setSeats(int seats) {
        // 차량의 좌석 수를 설정하세요.
    }

    public void setEngine(Engine engine) {
        // 해당 엔진을 설치하세요.
    }

    public void setTripComputer(boolean tripComputer) {
        // 트립 컴퓨터를 설치하세요.
    }

    public void setGPS(boolean gps) {
        // GPS를 설치하세요.
    }

    public Car getProduct() {
        Car product = this.car; // 제품 객체 가져오기
        this.reset(); // 빌더 초기화
        return product; // 제품 객체 반환
    }
}

<br><br>public Car getProduct() {
	Car product = this.car; // 제품 객체 가져오기
	this.reset(); // 빌더 초기화
	return product; // 제품 객체 반환
}
<br>

class CarManualBuilder implements Builder {
    private Manual manual; // 매뉴얼 객체

    public CarManualBuilder() {
        this.reset(); // 빌더 초기화
    }

    public void reset() {
        this.manual = new Manual(); // 새로운 매뉴얼 객체 생성
    }

    public void setSeats(int seats) {
        // 자동차 좌석의 기능들을 문서화하세요.
    }

    public void setEngine(Engine engine) {
        // 엔진 사용 지침을 추가하세요.
    }

    public void setTripComputer(boolean tripComputer) {
        // 트립 컴퓨터 사용 지침을 추가하세요.
    }

    public void setGPS(boolean gps) {
        // GPS 사용 지침을 추가하세요.
    }

    public Manual getProduct() {
        // 매뉴얼을 반환하고 빌더를 초기화하세요.
        return this.manual; // 매뉴얼 객체 반환
    }
}

class Director {
    public void constructSportsCar(Builder builder) {
        builder.reset(); // 빌더 초기화
        builder.setSeats(2); // 좌석 설정
        builder.setEngine(new SportEngine()); // 엔진 설정
        builder.setTripComputer(true); // 트립 컴퓨터 설정
        builder.setGPS(true); // GPS 설정
    }

    // 다른 생성 메서드들...
}

class Application {
    public void makeCar() {
        Director director = new Director(); // 디렉터 객체 생성

        CarBuilder carBuilder = new CarBuilder(); // 자동차 빌더 객체 생성
        director.constructSportsCar(carBuilder); // 스포츠카 생성
        Car car = carBuilder.getProduct(); // 자동차 제품 객체 가져오기

        CarManualBuilder manualBuilder = new CarManualBuilder(); // 매뉴얼 빌더 객체 생성
        director.constructSportsCar(manualBuilder); // 스포츠카 매뉴얼 생성

        Manual manual = manualBuilder.getProduct(); // 매뉴얼 객체 가져오기
    }
}


]]></description><link>0.-clean-code/1.-design-pattern/2.-생성-패턴/빌더.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 생성 패턴/빌더.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 12:59:32 GMT</pubDate><enclosure url="https://i.imgur.com/CqBwkE3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/CqBwkE3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[추상 팩토리]]></title><description><![CDATA[ 
 ]]></description><link>0.-clean-code/1.-design-pattern/2.-생성-패턴/추상-팩토리.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 생성 패턴/추상 팩토리.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 10:59:40 GMT</pubDate></item><item><title><![CDATA[프로토타입]]></title><description><![CDATA[ 
 ]]></description><link>0.-clean-code/1.-design-pattern/2.-생성-패턴/프로토타입.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 생성 패턴/프로토타입.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:00:02 GMT</pubDate></item><item><title><![CDATA[행동패턴]]></title><description><![CDATA[ 
 <br><br>
객체 간의 상호 작용과 알고리즘 분배에 중점을 둔 디자인 패턴의 한 유형입니다.
<br><br>
<br><a data-href="메멘토" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/메멘토.html" class="internal-link" target="_self" rel="noopener nofollow">메멘토</a> (Memento): 객체의 상태를 저장하고 나중에 복원할 수 있도록 하여 객체의 상태 변화를 기록하는 패턴.
<br><a data-href="반복자" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/반복자.html" class="internal-link" target="_self" rel="noopener nofollow">반복자</a> (Iterator): 컬렉션의 요소들을 순차적으로 접근할 수 있게 해주는 패턴.
<br><a data-href="비지터" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/비지터.html" class="internal-link" target="_self" rel="noopener nofollow">비지터</a> (Visitor): 객체 구조를 변경하지 않고도 새로운 기능을 추가할 수 있게 해주는 패턴.
<br><a data-href="상태" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/상태.html" class="internal-link" target="_self" rel="noopener nofollow">상태</a> (State): 객체의 상태에 따라 행동을 변경할 수 있게 해주는 패턴.
<br><a data-href="옵서버" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/옵서버.html" class="internal-link" target="_self" rel="noopener nofollow">옵서버</a> (Observer): 한 객체의 상태 변화에 따라 다른 객체들에게 통지하고 자동으로 갱신할 수 있게 해주는 패턴.
<br><a data-href="전략" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/전략.html" class="internal-link" target="_self" rel="noopener nofollow">전략</a> (Strategy): 동일한 문제를 해결하는 여러 알고리즘을 캡슐화하여 상호 교환 가능하게 해주는 패턴.
<br><a data-href="중재자" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/중재자.html" class="internal-link" target="_self" rel="noopener nofollow">중재자</a> (Mediator): 객체들이 직접 통신하지 않고 중재자를 통해 통신하여 객체 간의 상호작용을 캡슐화하는 패턴.
<br><a data-href="책임연쇄" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/책임연쇄.html" class="internal-link" target="_self" rel="noopener nofollow">책임연쇄</a> (Chain of Responsibility): 요청을 처리할 수 있는 기회가 여러 객체에게 주어져, 요청이 처리될 때까지 객체들을 순차적으로 전달하는 패턴.
<br><a data-href="커맨드" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/커맨드.html" class="internal-link" target="_self" rel="noopener nofollow">커맨드</a> (Command): 요청을 객체의 형태로 캡슐화하여 요청에 필요한 모든 정보를 저장하고 실행할 수 있게 해주는 패턴.
<br><a data-href="템플릿 메서드" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/템플릿-메서드.html" class="internal-link" target="_self" rel="noopener nofollow">템플릿 메서드</a> (Template Method): 상위 클래스에서 기본적인 알고리즘 구조를 정의하고, 하위 클래스에서 구체적인 처리를 구현하는 패턴.
]]></description><link>0.-clean-code/1.-design-pattern/2.-행동-패턴/2.-행동-패턴.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 행동 패턴/2. 행동 패턴.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:59:36 GMT</pubDate></item><item><title><![CDATA[전략 패턴]]></title><description><![CDATA[ 
 <br><br>
실행 중 구현체를 선택하여 객체 동작을 실시간으로 바뀔 수 있게 하는 디자인 패턴입니다.<br>
어떤 일을 수행하는 구현 방법이 여러가지이고 변형이 빈번하게 일어날 경우 사용합니다. 
<br><br>
일종의 알고리즘 또는 특정 목표를 수행하기 위한 행동(기능, 동작)입니다. 
<br><br><br><br>
사용자가 주소를 입력하면 목적지로 가는 가장 빠른 경로를 볼 수 있는 기능을 개발하는 상황을 가정합니다.
<br><br><img src="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FZsJtrYr36aKCYEXONiXO%252Fimage.png%3Falt%3Dmedia%26token%3Deb50e7c1-93da-4bb7-863d-748e6b5a4033&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=60871c2d8748bdbb35aaedd1e3853b540f77a44d76444b0b2d82f9aae1c24ede" referrerpolicy="no-referrer"><br>도로 경로, 도보 경로, 대중 교통 사용 시, 자전거를 사용하는 경로 등 새 경로 알고리즘을 추가할 때마다 유지보수하기 매우 어려워집니다.<br>
<br>간단한 버그를 수정하거나, 알고리즘 중 하나를 변경하면 전체 클래스에 영향을 미쳐 이미 작동하는 코드에서 오류가 발생하기 시작했습니다.
<br>하나의 클래스에서 관리하기 때문에 병합 충돌 위험이 커집니다.
<br><br>
특정 작업을 다양한 방식으로 수행하는 클래스를 선택한 후 모든 알고리즘을 전략이라는 별도의 클래스로 추출합니다.
<br><br><img src="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FqWlZFI6eAuRd6hDIphuO%252Fimage.png%3Falt%3Dmedia%26token%3D565210e7-0507-4080-bd1a-753f7313fa93&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=844a77abcd924df980a66cfd47e6750ad6a8f6e85f168e328eb0acbdcd0ace0d" referrerpolicy="no-referrer"><br><br><img src="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FCjmWDSJiLTk38nvuH2B9%252Fimage.png%3Falt%3Dmedia%26token%3D023a02d9-f3a7-4235-9a5c-d446ca2e3bea&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=f55316f57277bf4d1791c6e57f5a5ffd5b735d0e870f543821f4f47452c801eb" referrerpolicy="no-referrer"><br><br>
<br>알고리즘, 행위, 동작을 구현한 객체 
<br><br>
<br>모든 전략 구현체에 대한 공용 인터페이스 
<br><br>
<br>
알고리즘을 실행해야할 때마다 알고리즘과 연결된 전략 객체 메서드를 호출합니다. 

<br>
전략을 선택하기 위한 필드를 가지고 있습니다.

<br><br>
<br>
원하는 전략을 컨텍스트에 전달합니다.

<br>
일반 인터페이스(Strategy)를 통해 모든 전략을 실행할 수 있습니다.

<br>
선택된 전략 내에 캡슐화된 알고리즘을 작동시킬 단일 메서드만 노출합니다.<br>
-&gt; 콘텍스트가 구상 전략들에 의존하지 않게 되므로, 콘텍스트 또는 다른 전략들의 코드를 변경하지 않고도 새 알고리즘들을 추가하거나, 기존 알고리즘을 수정할 수 있습니다.

<br><br><img src="https://i.imgur.com/syP7MBy.png" referrerpolicy="no-referrer"><br><br><br>
전략 인터페이스는 공통 작업을 선언합니다.
<br>interface Strategy {
    int execute(int a, int b);
}
<br>
<br>컨텍스트는 이 인터페이스를 사용하여 구상 전략에 의해 구현된 알고리즘을 호출합니다.
<br><br>
전략 인터페이스의 구현체입니다.
<br>
class ConcreteStrategyAdd implements Strategy {
    public int execute(int a, int b) {
        return a + b;
    }
}

class ConcreteStrategySubtract implements Strategy {
    public int execute(int a, int b) {
        return a - b;
    }
}

class ConcreteStrategyMultiply implements Strategy {
    public int execute(int a, int b) {
        return a * b;
    }
}

<br><br>
전략 인터페이스를 사용하여 구현된 알고리즘을 호출합니다.
<br>class ExampleApplication {
    public static void main(String[] args) {
        Context context = new Context();

        // 숫자 입력을 위한 예제, 실제로는 Scanner 등을 사용하여 입력을 받을 수 있음
        int firstNumber = 10; // 예시 입력 값
        int secondNumber = 5; // 예시 입력 값
        String action = "addition"; // 예시 입력 값 (실제로는 사용자 입력 받아야 함)

        if (action.equals("addition")) {
            context.setStrategy(new ConcreteStrategyAdd());
        } else if (action.equals("subtraction")) {
            context.setStrategy(new ConcreteStrategySubtract());
        } else if (action.equals("multiplication")) {
            context.setStrategy(new ConcreteStrategyMultiply());
        }

        int result = context.executeStrategy(firstNumber, secondNumber);

        // 결과 출력
        System.out.println("Result: " + result);
    }
}

<br><br>
<br>
자주 변경되는 알고리즘을 식별합니다.

<br>
모든 알고리즘에 공통인 전략 인터페이스를 선언합니다.

<br>
모든 알고리즘을 각기 다른 클래스로 추출합니다. (전략 인터페이스를 구현합니다.)

<br>
컨텍스트 클래스에서 전략에 대한 참조를 저장하기 위한 필드를 추가합니다.

<br>해당 필드의 값을 대체하기 위한 세터를 제공합니다.
<br>컨텍스트는 전략 인터페이스를 통해서만 전략 객체와 통신해야합니다.
<br>컨텍스트는 인터페이스를 정의할 수 있으며, 이 인터페이스는 전략이 컨텍스트의 데이터에 접근할 수 있도록 합니다.
<br>컨텍스트의 클라이언트들은 컨텍스트를 적절한 전략과 연관시켜야합니다.


<br><br>
<br>객체 내에서 한 알고리즘의 다양한 변형들을 사용하고 싶을 때 사용합니다.
<br>런타임 중에서 알고리즘 전환이 필요한 경우 사용합니다.<br>
: 특정 하위 행동들을 다양한 방식으로 수행할 수 있는 다른 하위 객체들과 연관시켜 객체의 행동들을 런타임에 간접적으로 변경할 수 있습니다.<br>

<br>구현 방식만 차이가 있는 비슷한 클래스들이 많은 경우 사용합니다.<br>
: 전략 패턴은 다양한 행동들을 별도의 클래스 계층 구조로 추출하고 원래 클래스들을 하나로 결합합니다.<br>

<br>비즈니스 로직 내에서 중요하지 않은 알고리즘의 구현 세부사항들로부터 고립합니다.<br>
: 전략 패턴으로 코드, 데이터, 알고리즘의 의존관계를 고립시킬 수 있습니다.<br>

<br>매우 큰 조건문이 있을 경우 사용하기 좋습니다.<br>
: 알고리즘을 같은 인터페이스를 구현하는 별도의 클래스로 추출하여 조건문을 제거할 수 있습니다.
<br><br><br>
<br>런타임 시점에 알고리즘을 선택할 수 있습니다.<br>

<br>알고리즘을 사용하는 코드는 알고리즘 구현체를 몰라도 됩니다.<br>

<br>상속을 합성으로 대체할 수 있습니다.<br>

<br>개방 폐쇄 원칙 컨텍스트를 변경하지 않고 새로운 전략을 도입할 수 있습니다.
<br><br>
<br>알고리즘이 몇 개 밖에 되지 않고 거의 변하지 않는다면, 패턴과 함께 사용되는 새로운 클래스들과 인터페이스로 굳이 복잡하게 만들 필요는 없습니다.<br>

<br>익명함수가 존재합니다.<br>
: 클래스와 인터페이스를 추가할 필요 없이, 전략 객체와 동일한 이점을 누릴 수 있습니다.
<br><br><br><br>
class TakeWeapon {
    public static final int SWORD = 0;
    public static final int SHIELD = 1;
    public static final int CROSSBOW = 2;

    private int state;

    void setWeapon(int state) {
        this.state = state;
    }

    void attack() {
        if (state == SWORD) {
            System.out.println("칼을 휘두르다");
        } else if (state == SHIELD) {
            System.out.println("방패로 밀친다");
        } else if (state == CROSSBOW) {
            System.out.println("석궁을 발사하다");
        }
    }
}

<br>class User {
    public static void main(String[] args) {
        // 플레이어 손에 무기 착용 전략을 설정
        TakeWeapon hand = new TakeWeapon();

        // 플레이어가 검을 들도록 전략 설정
        hand.setWeapon(TakeWeapon.SWORD);
        hand.attack(); // "칼을 휘두르다"

        // 플레이어가 방패를 들도록 전략 설정
        hand.setWeapon(TakeWeapon.SHIELD);
        hand.attack(); // "방패로 밀친다"
    }
}
<br> state 매개 변수에 따라서 간접적으로 attack() 함수의 동작을 제어합니다. 상수를 메서드에 넘겨 조건문으로 일일히 필터링하여 적절한 전략을 실행하는 예제입니다. 하지만, 상수의 가짓수가 늘어날 수록 if else 지옥에 빠지게 될 가능성이 매우 높은 코드입니다. <br><br>
위 코드를 리팩토링 하는 가장 좋은 해결법은 변경하고자 하는 행위를 직접 넘겨주는 것입니다. 
<br><img src="https://i.imgur.com/Pi90tG2.png" referrerpolicy="no-referrer"><br>
<br>여러 무기를 전략 구현체로 정의합니다. 
<br>Weapon이라는 공통 전략 인터페이스를 선언합니다. 
<br>인터페이스를 컨텍스트 클래스에 합성시킵니다. 
<br>컨텍스트를 통해 전략 인터페이스 객체의 상태를 바로바로 변경할 수 있게 합니다. 
<br><br>
도끼나 창을 추가하는 상황이 발생했을 때, 기존 코드의 수정 없이 빠르게 기능을 확장해줄 수 있습니다. 
<br>
<br>전략 클래스를 추가합니다. 
<br>구현합니다. 
<br><br>
쇼핑카트에 담긴 아이템을 LUNA 또는 KAKAO 카드라는 두 개의 전략을 사용해 결제를 진행하는 예제입니다. 
<br>
<br>
전략 인터페이스를 필드로 합성하지 않고 pay()메서드의 매개 변수로 합성한다는 차이가 있으므로 잘확인해봅시다.

<br>
메서드의 입력값으로 객체를 할당하는 예제입니다. 

<br>각 전략에 따라 초기화하는 생성자 매개변수가 달라질 수 있기 때문입니다. 
<br>현재 예제에서는 LUNA 카드는 메일과 비밀번호를, KAKAO 카드는 다른 여러가지 정보가 필요한 상황을 가정하여 구현하였으니, 이 부분을 포인트로 읽어야합니다. 


<br><br><img src="https://i.imgur.com/Ah2llGq.png" referrerpolicy="no-referrer"><br><br>interface PaymentStrategy {
    void pay(int amount);
}
<br><br>
각 카드사마다 결제에 필요한 정보다 다릅니다! 
<br>class KAKAOCardStrategy implements PaymentStrategy {
    private String name;
    private String cardNumber;
    private String cvv;
    private String dateOfExpiry;

    public KAKAOCardStrategy(String nm, String ccNum, String cvv, String expiryDate) {
        this.name = nm;
        this.cardNumber = ccNum;
        this.cvv = cvv;
        this.dateOfExpiry = expiryDate;
    }

    @Override
    public void pay(int amount) {
        System.out.println(amount + "원 paid using KAKAOCard.");
    }
}

class LUNACardStrategy implements PaymentStrategy {
    private String emailId;
    private String password;

    public LUNACardStrategy(String email, String pwd) {
        this.emailId = email;
        this.password = pwd;
    }

    @Override
    public void pay(int amount) {
        System.out.println(amount + "원 paid using LUNACard.");
    }
}

<br><br>
전략을 매개변수로 받아, 실행합니다. 
<br>
class ShoppingCart {
    List&lt;Item&gt; items;
    public ShoppingCart() {
        this.items = new ArrayList&lt;Item&gt;();
    }
    public void addItem(Item item) {
        this.items.add(item);
    }
	
    // 전략을 매개변수로 받아서 바로바로 전략을 실행
    public void pay(PaymentStrategy paymentMethod) {
        int amount = 0;
        for (Item item : items) {
            amount += item.price;
        }
        paymentMethod.pay(amount);
    }
}


<br><br>
class Item {
    public String name;
    public int price;

    public Item(String name, int cost) {
        this.name = name;
        this.price = cost;
    }
}

// 클라이언트 - 전략 제공/설정
class User {
    public static void main(String[] args) {
        // 쇼핑카트 전략 컨텍스트 등록
        ShoppingCart cart = new ShoppingCart();

        // 쇼핑 물품
        Item A = new Item("맥북 프로", 10000);
        Item B = new Item("플레이스테이션", 30000);
        cart.addItem(A);
        cart.addItem(B);

        // LUNACard로 결제 전략 실행
        cart.pay(new LUNACardStrategy("kundol@example.com", "pukubababo")); 

        // KAKAOBank로 결제 전략 실행
        cart.pay(new KAKAOCardStrategy("Ju hongchul", "123456789", "123", "12/01")); 
    }
}

<br><br><br>
다른 객체에 작업을 위임하는 합성을 기반으로 합니다. 
<br><br>
둘 다 객체를 매개변수화합니다. 
<br><br><br>
템플릿은 상속이 기반이고, 전략 패턴은 합성이 기반입니다. 
<br><br>
<br>자식 클래스에서 알고리즘의 일부분을 확장해 변경할 수 있습니다. 
<br>클래스 수준에서 작동하므로 정적입니다. 
<br><br>
<br>객체 행동의 일부분을 다양한 전략을 제공하여 변경할 수 있습니다. 
<br>객체 수준에서 작동하므로 런타임시 변경됩니다. (동적입니다.)
<br><br>
상태는 전략의 확장입니다. 
<br>
<br>두 패턴 모두 합성을 기반으로 합니다. 
<br>]]></description><link>0.-clean-code/1.-design-pattern/2.-행동-패턴/전략.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 행동 패턴/전략.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 13:29:41 GMT</pubDate><enclosure url="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FZsJtrYr36aKCYEXONiXO%252Fimage.png%3Falt%3Dmedia%26token%3Deb50e7c1-93da-4bb7-863d-748e6b5a4033&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=60871c2d8748bdbb35aaedd1e3853b540f77a44d76444b0b2d82f9aae1c24ede" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FZsJtrYr36aKCYEXONiXO%252Fimage.png%3Falt%3Dmedia%26token%3Deb50e7c1-93da-4bb7-863d-748e6b5a4033&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=60871c2d8748bdbb35aaedd1e3853b540f77a44d76444b0b2d82f9aae1c24ede&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[템플릿 메서드]]></title><description><![CDATA[ 
 ]]></description><link>0.-clean-code/1.-design-pattern/2.-행동-패턴/템플릿-메서드.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/2. 행동 패턴/템플릿 메서드.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:04:14 GMT</pubDate></item><item><title><![CDATA[Design Pattern Overview]]></title><description><![CDATA[<a class="tag" href="?query=tag:Root" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Root</a> 
 <br><br><a href=".?query=tag:Root" class="tag" target="_blank" rel="noopener nofollow">#Root</a> <br><a data-href="2. 구조 패턴" href="0.-clean-code/1.-design-pattern/2.-구조-패턴/2.-구조-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">2. 구조 패턴</a><br>
<a data-href="2. 행동 패턴" href="0.-clean-code/1.-design-pattern/2.-행동-패턴/2.-행동-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">2. 행동 패턴</a><br>
<a data-href="2. 생성 패턴" href="0.-clean-code/1.-design-pattern/2.-생성-패턴/2.-생성-패턴.html" class="internal-link" target="_self" rel="noopener nofollow">2. 생성 패턴</a>]]></description><link>0.-clean-code/1.-design-pattern/1.-design-pattern.html</link><guid isPermaLink="false">0. Clean Code/1. Design Pattern/1. Design Pattern.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:01:13 GMT</pubDate></item><item><title><![CDATA[Clean Code Overview]]></title><description><![CDATA[ 
 <br>]]></description><link>0.-clean-code/0.-clean-code.html</link><guid isPermaLink="false">0. Clean Code/0. Clean Code.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:00:50 GMT</pubDate></item><item><title><![CDATA[상속하지 말고 합성하라]]></title><description><![CDATA[ 
 <br><br>
내가 자바를 만들면서 가장 후회하는 일은 상속을 만든 것이다 - 제임스 고슬링 (Java 창시자)
<br>
상속을 위한 설계와 문서를 갖출 것이 아니라면 상속은 금지하는 것이 좋다. - 조슈야 블로크 (이펙티브자바)
<br><br>
상속과 합성은 객체 지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법입니다. 
<br><br><br>
클래스 상속을 통해 자식 클래스는 부모 클래스의 자원을 물려받게 되며, 부모 클래스와 다른 부분만 추가하거나 오버라이딩함으로써 기존 코드를 확장합니다. 
<br><img src="https://i.imgur.com/lEJHf8l.png" referrerpolicy="no-referrer"><br>
class Mobile {
	// ...
}

class Apple extends Mobile {
	// ...
}

<br><br>
<br>명확한 is-a 관계에 놓여 있는 경우 
<br>상위 클래스가 확장할 목적으로 설계되어있고 문서화도 잘되어 있는 경우 
<br><br>
고객을 백화점 매출 기여도에 따라 등급을 나누어 관리하는 예제입니다. 
<br>
<br>Customer라는 최상위 클래스를 정의합니다. 
<br>Customer를 상속받아 VIPCustomer, GoldCustomer 등의 자식 클래스로 구현합니다. 
<br>Cooper 등급을 새로 추가한다 할때 상위 클래스를 상속만 하면 됩니다. 
<br>
class Customer{
	private String name;

}

class VIPCusomer extends Customer{

}

//긴 시간이 지나고 요구사항이 변경될 경우 

class CooperCustomer extends Customer{


}

<br><br>
현업에서는 가능하면 extends 사용을 지양하는 편이며, 상속을 해야할 때는 정말 개념적으로 연관 관계가 있을 때만 합니다. 
<br><br>결합도란?<br>
결합도는 하나의 모듈이 다른 모듈의 코드를 얼마나 많이 참조하고 있는지 의존정도를 나타낸다. 객체 지향 프로그래밍에서는 결합도는 낮을수록 응집도는 높을수록 좋습니다. 즉 우리는 추상화에 의존함으로써, 다른 객체에 대한 결합도는 최소화 하고 응집도를 최대화하여 변경 가능성을 최소화해야합니다. <br>상속을 하면 결합도가 높아진다.<br>
상속을 하게 되면 부모와 자식 관계가 컴파일 시점에 관계가 결정되어 결합도가 높아집니다. 실행 시점에서 객체의 종류를 변경하는 것이 불가능하기 때문에 유기적인 다형성 및 객체 지향적으로 코드를 작성할 수 없습니다. <br>
// 자동차의 엔진 클래스
class Engine {
    void ignite() {
        System.out.println("엔진이 시동됩니다.");
    }
}

// 자동차의 엔진을 상속받는 하위 클래스
class ElectricEngine extends Engine {
    // 전기 엔진은 시동할 때 특별한 처리를 해야 할 수도 있다고 가정
    @Override
    void ignite() {
        System.out.println("전기 엔진이 시동됩니다.");
        // 전기 엔진의 특별한 기능을 수행하는 코드
    }
}

// 자동차 클래스의 사용 예시
public class Main {
    public static void main(String[] args) {
        // 자동차의 엔진을 사용하는 경우
        Engine engine = new Engine();
        engine.ignite(); // 엔진이 시동됩니다.

        // 전기 자동차를 사용하는 경우
        ElectricEngine electricEngine = new ElectricEngine();
        electricEngine.ignite(); // 전기 엔진이 시동됩니다.
    }
}


<br>위 코드에서 Engine의 ignite메서드의 시그니처를 변경할 경우 상속 받은 모든 자식클래스를 싹다 뜯어고쳐야합니다. <br><br>
class Animal{
	void fly(){
	}
}

class Eagle extends Animal{
	@Override 
	public void fly(){
		//정상 구현 가능 
	}
}

class Tiger extends Animal{
	@Override 
	public void fly(){
		//제대로 구현 못하고 빈 껍데기로 남겨 놓아야한다. 
	}


}


<br> 부모 클래스에 메서드가 추가될 때 해당 메서드가 모든 자식 클래스에게 적합하지 않을 수도 있습니다. 예시로, Animal 클래스에 fly() 라는 메서드를 추가했을 때, Tiger 클래스는 fly() 메서드가 필요없습니다. 구현하고 빈칸으로 놔두거나 클래스를 분리하여 해결할 수 있지만 모두 좋은 방법은 아닙니다.<br><br>
상위 클래스에 결함이 있을 때 상속하면 자식에게 그대로 넘어옵니다. 자식 클래스를 아무리 잘 구현해도 부모 클래스에서 결함이 있기 때문에 문제가 전이되어버립니다. 
<br><br>
부모와 자식 사이 개념적 결합으로 인해, 부모를 변경할 때 자식도 함께 변경해야할 수도 있습니다. 
<br>아래와 같은 코드에서 Food 클래스에 <br>
class Food {
    final int price;
    
    Food(int price) {
        this.price = price;
    }
}

class Bread extends Food {
    public Bread(int price) {
        super(price);
    }
}

public class Main {
    public static void main(String[] args) {
        Food bread = new Bread(1000);
    }
}
<br>count 필드를 하나 추가해버리면 자식 클래스는 물론 클라이언트까지 싹다 뜯어 고쳐야합니다.<br>
class Food {
    final int price;
    final int count; // 코드 추가
    
    Food(int price, int count) { 
        this.price = price;
        this.count = count; // 코드 추가
    }
}

class Bread extends Food {
    public Bread(int price, int count) {
        super(price, count); // 코드 수정
    }
}

public class Main {
    public static void main(String[] args) {
        Food bread = new Bread(1000, 5); // 코드 수정
    }
}

<br><br>
자식이 부모의 메서드를 오버라이딩할 때 부모의 호출 방법에 영향을 받을 수 있습니다.
<br>부모의 public 메서드는 외부에서 사용하도록 노출되어있습니다. 상속을 할 경우, 자식에서도 부모의 public 메서드를 이용할 때 의도치 않은 동작을 수행할 수 있습니다. <br><br>
HashSet을 상속하고 부모의 메소드를 오버라이딩한 예제입니다. 
<br>
class CustomSet&lt;E&gt; extends HashSet&lt;E&gt; {
    private int addCount = 0; // 자료형에 몇번 추가되었는지 세는 카운트 변수

    @Override
    public boolean add(E e) {
        // 만일 add되면 카운트를 증가 시키고, 부모 클래스 HashSet의 add() 메소드를 실행한다.
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        // 만일 리스트 자체로 들어와 통쨰로 add 한다면, 컬렉션의 사이즈를 구해 카운트에 더하고, 부모 클래스 HashSet의 addAll() 메소드를 실행한다.
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

public class Main {
    public static void main(String[] args) {
        CustomSet&lt;String&gt; mySet = new CustomSet&lt;&gt;();

        mySet.addAll(Arrays.asList("가", "나", "다", "라", "마"));
        mySet.add("바");

        System.out.println(mySet.getAddCount()); // ! 6이 나와야 정상이지만 11이 나오게 된다.
    }
}

<br>원소가 6개 추가되니 결과는 6이 나와야하지만, 11이 나오게된다. 이유는 부모의 addAll() 메서드를 오버라이딩한 채로 super를 이용해서 호출했기 때문이다. HashSet(부모)의 addAll() 메서드 구현체를 살펴보자<br>public boolean addAll(Collection&lt;? extends E&gt; c){

	boolean modified = false; 
	for(E e: c){
		if(add(e))
			modified = true; 
	}
	return modified 
}

<br>HashSet(부모)의 내부로직을 살펴보면, 들어온 리스트를 순회하면서 하나씩 넣어주고 있다. <br>
    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

<br>하지만 자식에서는 일단 컬렉션 사이즈만큼 더해버리고, 부모에서 addAll을 돌면서 또 <br><br>
// 기본 자동차 클래스
class Car {
    // 기본 구현
}

// 스포츠카 클래스
class SportsCar extends Car {
    // 스포츠카에 대한 추가 구현
}

// 세단 클래스
class Sedan extends Car {
    // 세단에 대한 추가 구현
}

// SUV 클래스
class SUV extends Car {
    // SUV에 대한 추가 구현
}

// 전기 자동차 클래스
class ElectricCar extends Car {
    // 전기 자동차에 대한 추가 구현
}

// 하이브리드 자동차 클래스
class HybridCar extends Car {
    // 하이브리드 자동차에 대한 추가 구현
}

// 트럭 클래스
class Truck extends Car {
    // 트럭에 대한 추가 구현
}

// 더 많은 자동차 클래스들...


<br><br><br>
기존 클래스를 상속이 아닌 필드로 클래스의 인스턴스를 참조하게 만드는 설계입니다. 
<br><br>서로 관련 없는 이질적인 관계에서 한 클래스가 다른 클래스의 기능을 사용해서 구현해야한다면 합성의 방식을 사용합니다. 가령 학생과 그 학생이 수강하는 과목이나, 자동차와 엔진 종류 관계를 생각하면 편합니다. 두 관계 모두 연관이 아주 없지는 않지만 상속 관계로 맺기에는 애매합니다.<br>
class Car {
    Engine engine; // 필드로 Engine 클래스 변수를 갖는다(has)

    Car(Engine engine) {
        this.engine = engine; // 생성자 초기화 할때 클래스 필드의 값을 정하게 됨
    }

    void drive() {
        System.out.printf("%s엔진으로 드라이브~\n", engine.EngineType);
    }

    void breaks() {
        System.out.printf("%s엔진으로 브레이크~\n", engine.EngineType);
    }
}

class Engine {
    String EngineType; // 디젤, 가솔린, 전기

    Engine(String type) {
        EngineType = type;
    }
}

<br>public class Main {
    public static void main(String[] args) {
        Car digelCar = new Car(new Engine("디젤"));
        digelCar.drive(); 

        Car electroCar = new Car(new Engine("전기"));
        electroCar.drive(); 
    }
}
<br><br>
위 코드를 보면 Car 클래스가 Engine 클래스의 기능이 필요하다고 해서 무조건 상속하는 것이 아닌, 따로 내부 파라미터로 지정하여 객체 자체를 가져다 씁니다. 이와 같은 원리를 포워딩이라고합니다. 
]]></description><link>0.-clean-code/상속하지-말고-합성하라.html</link><guid isPermaLink="false">0. Clean Code/상속하지 말고 합성하라.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 17:33:30 GMT</pubDate><enclosure url="https://i.imgur.com/lEJHf8l.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/lEJHf8l.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[0. Network]]></title><description><![CDATA[ 
 <br><a data-href="1. L3- 네트워크 계층" href="0.-network/1.-l3-네트워크-계층.html" class="internal-link" target="_self" rel="noopener nofollow">1. L3- 네트워크 계층</a><br>
<a data-href="2. L4- 네트워크 계층" href="0.-network/2.-l4-네트워크-계층.html" class="internal-link" target="_self" rel="noopener nofollow">2. L4- 네트워크 계층</a>]]></description><link>0.-network/0.-network.html</link><guid isPermaLink="false">0. Network/0. Network.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 10:48:14 GMT</pubDate></item><item><title><![CDATA[<font color="#8064a2">개요 </font>]]></title><description><![CDATA[<a class="tag" href="?query=tag:Network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Network</a> 
 <br><br><br>데이터 링크 계층에는 송수신지를 특정할 수 있는 MAC 주소가 있습니다.<br>
<br>
첫째, 물리 계층과 데이터 링크 계층만으로는 다른 네트워크까지의 도달 경로를 파악하기 어렵습니다.

<br>LAN A에 속한 호스트와 LAN B에 속한 호스트가 통신하기 위해, 패킷은 다양한 경로로 이동합니다.
<br>패킷이 이동할 최적의 경로를 정하는 것을 라우팅이라합니다.


<br>
MAC 주소만으로는 모든 네트워크에 속한 호스트의 위치를 특정하기 어렵습니다.

<br>
호스트가 네트워크에 속한 다른 호스트의 MAC 주소를 전부 알기가 어렵습니다.<br>
→ MAC 주소만으로는 이 세상에 있는 모든 호스트를 특정할 수 없습니다.

<br>
택배의 수신인 역할을 MAC주소라면, 수신지는 IP 주소입니다.    

<br>MAC과 IP주소를 함께 사용하고 IP 주소를 우선적으로 사용합니다.<br>





<br><br><br>네트워크 계층(Network Layer)은 OSI 모델(Open Systems Interconnection model)의 세 번째 계층입니다. 네트워크 계층의 주요 역할과 기능은 다음과 같습니다<br>
<br>
라우팅(Routing): 네트워크 계층은 데이터 패킷을 출발지에서 목적지까지 전달하는 경로를 결정합니다. 이를 위해 다양한 라우팅 알고리즘과 프로토콜을 사용합니다.

<br>
논리적 주소 지정(Logical Addressing): 네트워크 계층은 각 장치에 논리적인 주소(IP 주소)를 부여하여 서로 다른 네트워크 간의 통신을 가능하게 합니다. IP 주소는 인터넷 프로토콜(IPv4, IPv6)을 통해 할당됩니다.

<br>
패킷 포워딩(Packet Forwarding): 네트워크 계층은 패킷을 올바른 목적지로 전달하기 위해 다음 홉(Next Hop)을 결정하고 패킷을 전달합니다.

<br>
혼잡 제어(Congestion Control): 네트워크의 과부하를 방지하고 효율적인 데이터 전송을 위해 혼잡 제어 메커니즘을 사용합니다.

<br>
프레임 분할과 재조합(Fragmentation and Reassembly): 데이터가 전송되는 동안 네트워크의 최대 전송 단위(MTU)를 초과할 경우, 네트워크 계층은 큰 데이터를 작은 패킷으로 분할하고, 수신 측에서 이를 다시 조합합니다.

<br>네트워크 계층에서 사용되는 대표적인 프로토콜로는 IP(Internet Protocol)가 있으며, 이 외에도ICMP(Internet Control Message Protocol), ARP(Address Resolution Protocol) 등이 있습니다.<br>
네트워크 계층은 네트워크의 안정성과 효율성을 유지하기 위해 중요한 역할을 합니다.<br><a href=".?query=tag:Network" class="tag" target="_blank" rel="noopener nofollow">#Network</a>]]></description><link>0.-network/1.-l3-네트워크-계층.html</link><guid isPermaLink="false">0. Network/1. L3- 네트워크 계층.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 07:05:27 GMT</pubDate></item><item><title><![CDATA[<font color="#8064a2">IP의 한계</font>]]></title><description><![CDATA[<a class="tag" href="?query=tag:Network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Network</a> 
 <br><br><br>
<br>신뢰할 수 없는 통신입니다.
<br>비연결형 통신입니다.
<br><br><br>
<br>신뢰할 수 있는 통신과 연결형 통신을 지원하여 IP의 한계를 극복합니다.
<br>포트번호를 통해 응용 계층의 애플리케이션 프로세스를 식별합니다.
<br><img src="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FfOpZbLGxPgdgH5MKH7OR%252Fimage.png%3Falt%3Dmedia%26token%3Db376e6bb-e40f-4734-b7aa-04a5c1c1cbf1&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=cbf7f460d9aa0681c7ed7847ff713c9a87bbab7d52b0d6b39c3e695f360713d7" referrerpolicy="no-referrer"><br><br><a href=".?query=tag:Network" class="tag" target="_blank" rel="noopener nofollow">#Network</a>]]></description><link>0.-network/2.-l4-네트워크-계층.html</link><guid isPermaLink="false">0. Network/2. L4- 네트워크 계층.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 07:05:33 GMT</pubDate><enclosure url="https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FfOpZbLGxPgdgH5MKH7OR%252Fimage.png%3Falt%3Dmedia%26token%3Db376e6bb-e40f-4734-b7aa-04a5c1c1cbf1&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=cbf7f460d9aa0681c7ed7847ff713c9a87bbab7d52b0d6b39c3e695f360713d7" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://hanju.gitbook.io/~gitbook/image?url=https%3A%2F%2F102830355-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252FfNpWAsJfDNQXNBCChExd%252Fuploads%252FfOpZbLGxPgdgH5MKH7OR%252Fimage.png%3Falt%3Dmedia%26token%3Db376e6bb-e40f-4734-b7aa-04a5c1c1cbf1&amp;width=768&amp;dpr=4&amp;quality=100&amp;sign=cbf7f460d9aa0681c7ed7847ff713c9a87bbab7d52b0d6b39c3e695f360713d7&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[API 디자인]]></title><description><![CDATA[ 
 <br>리소스를 중심으로 디자인 됩니다. 리소스는 클라이언트에서 액세스할 수 있는 모든 종류의 개체, 데이터 또는 서비스이빈다. <br>리소스마다 고유하게 식별하는 URI인 식별자가 있습니다. 예를 들어 특정 고객 주문의 URI는 다음과 같습니다. <br>https://adventure-works.com/orders/1
<br><br><br>DB에서의 하나의 레코드, Spring에서의 하나의 객체와 유사한 단일 자원의 개념입니다. 단수를 사용하여 문서 자원을 표시합니다. <br>http://api.example.com/**device-management**/managed-devices/{device-id}  
http://api.example.com/**user-management**/users/{id}  
http://api.example.com/**user-management**/users/admin
<br><br>서버가 관리하는 리소스 디렉터리입니다. 복수형으로 작성합니다. <br>http://api.example.com/device-management/**managed-devices**  
http://api.example.com/user-management/**users**  
http://api.example.com/user-management/**users**/{id}/**accounts**
<br><br>스토어는 클라이언트가 관리 하는 자원 저장소이다. 클라이언트는 API를 이용하여 자원을 넣거나 가져올 수 있고 삭제 할 수 있다. 복수를 사용하여 스토어를 표현한다.<br>http://api.example.com/song-management/users/{id}/**playlists**
<br><br>컨트롤러 자원은 인자와 반환 값, 입력 및 출력이 있는 실행 가능한 함수와 같다. 문서, 컬렉션, 스토어로 해결이 어려운 절차적 실행을 수행하기 위한 모델이다. 특정 자원을 가리키는 것이 아니라 실행 인 만큼 예외적으로 동사를 사용한다.<br>http://api.example.com/cart-management/users/{id}/cart/**checkout**  
http://api.example.com/song-management/users/{id}/playlist/**play**
<br><br>자원을 정렬, 필터링 하거나 제한된 수량을 요청 해야 할 필요가 있다. 이때 신규 API를 생성 하려 하지 말고 쿼리 파라미터를 활용 한다.<br>http://api.example.com/device-management/managed-devices  
http://api.example.com/device-management/managed-devices?**region=USA**  
http://api.example.com/device-management/managed-devices?**region=USA&amp;brand=XYZ**  
http://api.example.com/device-management/managed-devices?**region=USA&amp;brand=XYZ&amp;sort=installation-date**
<br>
<br>Paging : 리턴해야하는 데이터의 양이 많거나 예측하기 어려운경우는 페이징 처리를 하는것이 좋다.
<br>Filtering : 속성의 기대값을 지정하여 리소스를 필터링한다. 하나의 속성에 여러개의 기대값으로 필터링하는것이 가능하며 한번에 여러개의 속성으로 필터링 하는것도 가능하다.
<br>Sorting : 리소스를 정렬한다. sort 파라미터는 정렬을 수행할 속성의 이름을 포함해야 한다.
<br>Searching : 검색 파라미터는 Filter와 유사하게 전달되지만 정확한 값이 아니여도 되며 대략적으로 일치하기만 하면 된다.
<br><br>http://api.example.com/devicemanagement/manageddevices/ http://api.example.com/device-management/managed-devices
<br>REST API에서는 일관된 소문자를 권장합니다. 복합어 형태로 이뤄진 경우 -로 가독성을 챙깁니다. 단, 언더바(_)는 사용하지 않습니다. 애플리케이션의 글꼴에 따라 일부 브라우저나 화면에서 정상적으로 표시되지 않을 수 있습니다. <br><br><br><br>https://adventure-works.com/orders // Good

https://adventure-works.com/create-order // Avoid
<br>컬렉션을 참조하는 URI에 대해서는 일관적인 명명 규칙을 적용해야 한다. <br><br>GET : 리소스 접근<br>
POST : 리소스 생성<br>
PUT: 리소스에 대한 전체 속성 업데이트<br>
PATCH: 리소스 일부 속성 업데이트<br>
DELETE: 지정된 URI 리소스 제거 <br><br>
<br>POST 요청은 기존 리소스에 처리할 데이터를 보내는데 사용할 수 있음 
<br><br>POST <br>
<br>새 리소스가 정상 생성된 경우 -&gt; 201 or 200
<br>새 리소스가 정상 생성되었으나 body에 포함할 내용이 없는 경우 -&gt; 204(내용없음)
<br>PUT <br>
<br>
<br><br>
<br>
HTTP 표준:

<br>HTTP/1.1 표준(RFC 7231)은 GET 요청에서 본문을 사용하지 않는 것을 명시적으로 요구하지 않지만, GET 요청은 자원의 상태를 변경하지 않고 자원의 표현을 요청하는 데 사용된다고 명시하고 있습니다.
<br>GET 요청은 주로 URL을 통해 필요한 모든 정보를 전달하는 것으로 간주됩니다. 따라서 쿼리 파라미터를 통해 정보를 전달하는 것이 일반적입니다.


<br>
호환성 문제:

<br>많은 웹 서버, 프록시, 캐시 및 브라우저는 GET 요청의 본문을 무시하거나 제대로 처리하지 않습니다. 이는 GET 요청이 본문을 포함하지 않는다는 가정하에 설계되었기 때문입니다.
<br>만약 GET 요청에 본문이 포함된 경우, 이러한 인프라 컴포넌트는 예기치 않게 동작할 수 있으며, 이는 호환성 문제를 초래할 수 있습니다.


<br>
안정성과 멱등성:

<br>GET 요청은 멱등성(idempotent)을 가지며, 동일한 요청을 여러 번 수행해도 동일한 결과를 반환해야 합니다. 이는 주로 URL을 통해 필요한 모든 정보를 전달함으로써 보장됩니다.
<br>본문을 포함한 GET 요청은 멱등성을 깨뜨릴 수 있으며, 서버 측에서 처리의 일관성을 보장하기 어렵게 만들 수 있습니다.


<br>
캐싱:

<br>GET 요청은 캐싱이 가능하다는 특성이 있습니다. 캐시는 URL을 기준으로 작동하므로, 쿼리 파라미터를 통해 전달된 정보가 캐시 키로 사용될 수 있습니다.
<br>본문을 포함한 GET 요청은 캐시 인프라에서 제대로 처리되지 않으며, 이는 캐싱의 이점을 활용할 수 없게 만듭니다.


<br><br>오랜 시간이 지나더라도 일반적인 개발자 환경을 제공하려면 다음과 같아야합니다.<br>
1: 단순해야합니다.<br>
2: 직관적이어야 합니다.<br>
3: 일관적이어야 합니다.<br>
<br>정확한 미국 영어여야합니다. 
<br>일반적으로 인정되는 줄임말 또는 축약어를 사용할 수 있습니다. (Application Programming Interface - API)
<br>
]]></description><link>0.-network/api-디자인.html</link><guid isPermaLink="false">0. Network/API 디자인.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 13 Jul 2024 08:46:36 GMT</pubDate></item><item><title><![CDATA[Untitled Overview]]></title><description><![CDATA[ 
 <br>]]></description><link>알고리즘과-자료구조/알고리즘/그래프-탐색/2.-그래프-탐색.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/그래프 탐색/2. 그래프 탐색.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:11:36 GMT</pubDate></item><item><title><![CDATA[2. 문자열]]></title><description><![CDATA[ 
 <br><a data-href="KMP" href="알고리즘과-자료구조/알고리즘/문자열/kmp.html" class="internal-link" target="_self" rel="noopener nofollow">KMP</a><br>
<a data-href="Mancher's Algorithm" href="알고리즘과-자료구조/알고리즘/문자열/mancher's-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">Mancher's Algorithm</a><br>
<a data-href="String Hashing" href="알고리즘과-자료구조/알고리즘/문자열/string-hashing.html" class="internal-link" target="_self" rel="noopener nofollow">String Hashing</a><br>
<a data-href="Trie" href="알고리즘과-자료구조/알고리즘/문자열/trie.html" class="internal-link" target="_self" rel="noopener nofollow">Trie</a>]]></description><link>알고리즘과-자료구조/알고리즘/문자열/2.-문자열.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/문자열/2. 문자열.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:32:35 GMT</pubDate></item><item><title><![CDATA[Mancher's Algorithm]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/알고리즘/문자열/mancher&apos;s-algorithm.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/문자열/Mancher&apos;s Algorithm.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:31:09 GMT</pubDate></item><item><title><![CDATA[String Hashing]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/알고리즘/문자열/string-hashing.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/문자열/String Hashing.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:31:57 GMT</pubDate></item><item><title><![CDATA[2. 완전탐색]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/알고리즘/완전탐색/2.-완전탐색.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/완전탐색/2. 완전탐색.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:14:09 GMT</pubDate></item><item><title><![CDATA[2. 이진탐색]]></title><description><![CDATA[ 
 <br><a data-href="이진탐색" href="알고리즘과-자료구조/알고리즘/이진탐색/이진탐색.html" class="internal-link" target="_self" rel="noopener nofollow">이진탐색</a><br>
<a data-href="Parametric Search" href="알고리즘과-자료구조/알고리즘/이진탐색/parametric-search.html" class="internal-link" target="_self" rel="noopener nofollow">Parametric Search</a>]]></description><link>알고리즘과-자료구조/알고리즘/이진탐색/2.-이진탐색.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/이진탐색/2. 이진탐색.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:21:40 GMT</pubDate></item><item><title><![CDATA[Java 코드]]></title><description><![CDATA[ 
 <br><br><br>private int binarySearch(int[] arr, int target){

	//이진 탐색을 이용해 정렬된 배열 arr안에서 target 인덱스 반환 
	//target이 없다면 -1을 반환 

}

<br>
<br>이진 탐색을 이용해 정렬된 배열 arr 안에서 target 인덱스 반환
<br>target이 없다면 -1을 반환
<br><br>arr배열 안에 있는 인덱스를 찾는 과정이므로, arr의 범위인 [0,arr.length)가 탐색 범위입니다. 찾는 범위는 다음과 같이 각각의 변수로 선언합니다. <br>int start = 0;
int end = arr.length; 

<br><br>end-start가 양수일 때까지 탐색을 계속 반복해야 합니다. <br>while(end&gt;start){


}

<br><br>범위의 중간 인덱스와 그 값을 구합니다. <br>
int mid = (start+end)/2;
int value = arr[mid];

<br>찾아낸 중간값으로 target과의 대소 판단 후 범위를 조정합니다. <br>if(value==target){

	return mid;

}else if(value&gt; target){
	//다운 
	//정답은 더 작은 범위에 있다.
	//[start, mid) 
	end = mid;
}else{
	//업
	//정답은 더 큰 범위에 있다. 
	// [mid+1, end)
	start = mid+1; 
}

<br><br>
private static int binarySearch(int[] arr, int target){

	int start = 0;
	int end = arr.length; 

	while(end&gt;start){
		int mid = (start+end)/2;
		int value = arr[mid];
		if(value==mid){
			return mid; 
		}else if(value&gt;target){
			end = mid;
		
		}else{
			start = mid+1; 
		}
	}
}

<br><br><br>정렬기준이 중요한 이유<br>
이진 탐색 문제 대부분은 큰 범위의 정답 후보 중 문제 조건에 맞는 정답을 찾아내는 케이스입니다. 문제에서 요구하는 조건의 검색 결과가 정답 후보의 값에 따라 정렬된 상태인지 확인해야합니다. <br><br>이진 탐색은 정확한 값 뿐만 아니라 정답 조건을 만족하는 값 중 가장 큰 값 혹은 가장 작은 값을 찾는데도 많이 사용됩니다. 파라메트릭 서치를 구현하기 위해서는 다음 2가지를 고려해야합니다.<br>1. 범위 좁히기
2. 범위 표기법 
<br><br>정답 조건을 만족하는 값 중 가장 큰 값을 구하는 경우<br>
중간값을 검사 했을 때 정답을 만족하더라도 더 큰값이 있는지 찾아야합니다. 범위를 큰 쪽으로 좁히되, 검사한 중간 값을 포함해서 좁혀야합니다. <br>정답 조건을 만족하는 값 중 가장 작은 값을 구하는 경우<br>
중간값을 검사했을 때 정답을 만족하더라도 더 작은 값이 있는지 찾아야합니다. 범위를 작은 쪽으로 좁히되, 검사한 중간값을 포함해서 좁혀야합니다. 이 경우 범위에 2개의 값이 남아있을 때 중간값은 start를 선택합니다. start가 정답 조건을 만족한다면 중간값을 포함한 [start, start] 를 선택하게 됩니다.<br>
반대로 start가 정답 조건을 만족하지 않는다면 큰 값이 들어 있는 범위인 [start+1, end]<br>하나의 값만 남았다고 해서 무조건 정답이 아니다.<br>
원소가 하나 남았다면 이 값이 정답을 만족하는지 여부를 한 번 더 검사해야합니다. <br><br><br>자바에서는 배열과 리스트에 적용할 수 있는 두 가지 메서드를 제공합니다. 주의해야할 점은 탐색 대상은 항상 정렬되어 있는 상태이어야합니다. <br><br>앞의 두 메서드는 배열이나 리스트에서 검색하려는 원소가 있다면 해당 원소의 인덱스를 반환합니다. 만약 찾고자 하는 값이 없다면 음수를 반환합니다. <br>원소가 들어갈 위치 찾기<br>
찾고자 하는 값이 없을 경우 음수 값을 반환합니다. 이 값을 양수로 변환하고 1을 빼면 해당 원소가 들어갈 위치가 됩니다. <br><br><br>
import java.util.Arrays;
import java.util.Collections;

public class LDSBinarySearch {
    public static void main(String[] args) {
        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println("Length of LDS: " + lengthOfLDS(nums));
    }

    public static int lengthOfLDS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        // dp 배열 초기화
        Integer[] dp = new Integer[nums.length];
        int length = 0;

        for (int num : nums) {
            // 이분 탐색을 통해 현재 num이 들어갈 위치를 찾음
            int i = Arrays.binarySearch(dp, 0, length, num, Collections.reverseOrder());
            if (i &lt; 0) {
                i = -(i + 1);
            }
            dp[i] = num;
            if (i == length) {
                length++;
            }
        }

        return length;
    }
}


<br><br>import java.util.Arrays;

public class LISBinarySearch {
    public static void main(String[] args) {
        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println("Length of LIS: " + lengthOfLIS(nums));
    }

    public static int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int[] dp = new int[nums.length];
        int length = 0;

        for (int num : nums) {
            int i = Arrays.binarySearch(dp, 0, length, num);
            if (i &lt; 0) {
                i = -(i + 1);
            }
            dp[i] = num;
            if (i == length) {
                length++;
            }
        }

        return length;
    }
}


]]></description><link>알고리즘과-자료구조/알고리즘/이진탐색/이진탐색.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/이진탐색/이진탐색.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Tue, 11 Jun 2024 05:31:48 GMT</pubDate></item><item><title><![CDATA[Parametric Search]]></title><description><![CDATA[ 
 <br><br>
문제를 결정 문제로 변형하여 이분탐색으로 해결하는 방식입니다. 
<br><br>처음들으면 잘 와닿지 않을 수 있다. 예시를 통해서 살펴봅시다. <br>예를들어 손님이 고기 200g을 달라고 해서 고기 덩이에서 200g을 잘라내야한다고 해봅시다.우리는 보통 눈대중으로 잘라서 저울에 재본 후 200g보다 부족하면 조금 더 잘라넣고 200g을 넘어가면 덩어리를 잘라서 저울에 잰다. <br>즉 우리는 "고기 200g을 잘라라"라는 문제를 "지금 자른 고기가 200g보다 무거운가"라는 결정문제로 변형한 뒤 조금씩 고기를 추가하거나 덜어내면서((=이분탐색)으로 문제를 해결한다. 이렇게 원래 주어진 문제를 결정문제로 변형하여 이분탐색을 통해 해결하는 것을 파라메트릭 서치라고 한다. <br><br>
아래 세 조건을 만족하는 문제에서만 사용할 수 있습니다. 
<br>1.특정 조건을 만족하는 최대/최소를 구하는 형식의 문제여야 합니다.<br>
조건이 보이지 않더라도 최소한 해당 조건으로 문제를 변경할 수 있어야합니다. 수행할 변수를 가지고 함수를 세웠을 때 그 함수가 감소함수거나 증가함수이어야 합니다.<br>2.어떤 값이 조건을 만족하면 이후 탐색 범위 내의 모든 값은 모두 조건을 만족해야한다.<br>
최대값을 구하는 문제의 경우 어떤 값이 조건을 만족하면 그 값보다 작은 값은 모두 조건을 만족해야한다. 또한 최솟값을 구하는 경우 어떤 값이 조건을 만족하면 그 값보다 큰 값은 모두 조건을 만족해야합니다. 그래야 조건을 만족하는 경우, 만족하지 않는 경우 다음 범위를 탐색하면서 답을 구할 수 있습니다. <br>3.범위가 이산적이거나 허용오차 범위가 있어야합니다.<br>
이분탐색으로는 연속적인 범위에서는 정답에 한없이 가까워질 뿐 정확한 값은 구할 수 없습니다. (=고등수학에서의 극한을 떠올리면 됩니다.)<br><br><br>
condition(x)를 만족하는 최대값을 찾는 문제라고 가정합니다. 
<br><br>목표 : 후보 범위의 최솟값인 l과 h를 넉넉하게 잡아준 뒤 이를 점점 줄여나가면서 l과 h가 같아지도록 합니다. <br>whlie(l&lt;h){
	int m = (l+h+1)/2; 

	if(condition(m)){
		l = m;
	}else{
		h = m-1;
	}
}


<br>주의 : 무한 루프에 빠지지 않는지 확인하기 <br>m=(l+h)/2인지, m=(l+h+1)/2인지에 따라 무한루프에 걸릴 수 있습니다. <br>무한 루프에 빠지지 않게하려면 이분탐색에 의해 두 구역으로 나눠졌을 때 m이 어디에 속하는지를 확인하면 됩니다. 예를 들어 조건을 만족하는 최댓값을 구하는 경우 m은 h쪽 범위에 속합니다. l과 h가 1차이로 붙어 있을 때 그림은 다음과 같습니다. <br><img src="https://i.imgur.com/JGxXFz2.png" referrerpolicy="no-referrer"><br>
m=(l+r)/2일 경우, 그림처럼 m은 항상 왼쪽 범위로 고정되고 오른쪽 범위는 변하지 않아서 무한 루프에 빠집니다.<br><img src="https://i.imgur.com/Yt8EEkN.png" referrerpolicy="no-referrer"><br>
m=(l+r+1)/2일 경우 m은 오른쪽 범위속하게 되면서 다음 범위는 [m,m]이 됩니다. <br>표로 정리해보겠습니다. <br><br><br>
<br>범위가 m이면 루프는 logM번 실행됩니다. 
<br>조건 함수의 시간 복잡도 = O(C(n))
<br>위 조건을 모두 고려하면 총 시간 복잡도는 O(C(n)logM)이 됩니다. 
<br><br><br>parametirc search에서 결정 문제라는 표현을 썼었습니다. 그게 이 문제에서 어떻게 적용되는지 살펴보겠습니다. 이 문제는 N개를 만들 수 있는 랜선의 최대 길이를 구하는 것이 목표입니다. 이걸 결정 문제로 바꾸면 우리가 구해야하는 답을 인자로, 조건의 참 거짓을 판단하는 문제로 만들 수 있습니다. <br>1. 변수를 지정합니다. (보통은 문제에서 요구하는 최대값/최솟값입니다.)
2. 해당 변수를 이진탐색하면서 codition에 만는지 판단합니다. 
3. condition을 정의합니다. 
4. 기본 템플릿에 맞춰서 구현합니다. 

<br>기본 템플릿을 다시 봐봅시다. <br>whlie(l&lt;h){
	int m = (l+h+1)/2; 

	if(condition(m)){
		l = m;
	}else{
		h = m-1;
	}
}


<br>길이 m을 임의로 선택하여 condition 함수에 넣으면 condition 함수에서는 랜선이 n개 이상일 수 있는지 판단합니다. <br>다음은 완성된 코드입니다. ]]></description><link>알고리즘과-자료구조/알고리즘/이진탐색/parametric-search.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/이진탐색/Parametric Search.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 10 Jun 2024 06:34:05 GMT</pubDate><enclosure url="https://i.imgur.com/JGxXFz2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/JGxXFz2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2. 최단거리]]></title><description><![CDATA[ 
 <br><a data-href="다익스트라" href="알고리즘과-자료구조/알고리즘/최단거리/다익스트라.html" class="internal-link" target="_self" rel="noopener nofollow">다익스트라</a><br>
<a data-href="플로이드워샬" href="알고리즘과-자료구조/알고리즘/최단거리/플로이드워샬.html" class="internal-link" target="_self" rel="noopener nofollow">플로이드워샬</a>]]></description><link>알고리즘과-자료구조/알고리즘/최단거리/2.-최단거리.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/최단거리/2. 최단거리.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:21:49 GMT</pubDate></item><item><title><![CDATA[다익스트라]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/알고리즘/최단거리/다익스트라.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/최단거리/다익스트라.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:17:35 GMT</pubDate></item><item><title><![CDATA[플로이드워샬]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/알고리즘/최단거리/플로이드워샬.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/최단거리/플로이드워샬.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:17:51 GMT</pubDate></item><item><title><![CDATA[Untitled Overview]]></title><description><![CDATA[ 
 <br>]]></description><link>알고리즘과-자료구조/알고리즘/dp/2.-dp.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/DP/2. DP.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:12:03 GMT</pubDate></item><item><title><![CDATA[다이나믹 프로그래밍 기본]]></title><description><![CDATA[ 
 <br><br>1: 문제가 원하는 정답을 찾기 위해 가장 먼저 완전 탐색 접근을 시도합니다.<br>
2: 완전 탐색 과정에서 탐색하게 되는 경우가 지나치게 많아서 안될 것 같은 경우 DP를 시도합니다. <br><br><br>코딩 테스트에서는 다음 3가지 유형의 빈출 주제가 정해져 있습니다. <br>1: 1~i 번 원소에 대해서 조건을 만족하는 경우의 수 <br>D[i] = 경우의 수 
<br>2: i~j 번 원소에 대해서 조건을 만족하는 최댓값 / 최솟값 <br>D[i][j] = i~j 원소에 대해서 조건을 만족하는 최대/최소 
<br>3: 수열 A[i...1]과 수열 B[j...1]에 대해 무언가를 계산한 값 <br>D[i][j] = 수열 A[i...1]과 수열 B[j...1]에 대해 무언가를 계산한 값 
<br><br>만들어진 가짜 문제들에 대한 답으로 진짜 문제를 어떻게 구할지 정해야합니다. 예시를 들어서 설명하겠습니다. <br>진짜 문제 : 수열 A[1...N]에서 조건을 만족하는 부분 수열의 개수<br>
가짜 문제 : 수열 A[1...i]에서 조건을 만족하는 부분 수열의 개수 <br>가짜 문제를 푼다면 D[1], D[2], ... D[N]을 모두 계산한다.<br>
-&gt; D[N]에 적혀 있는 값이 진짜 문제가 원하는 답이다. <br><br>가장 작은 원소는 굳이 쪼개지 않아도 문제를 풀 수 있습니다. 때문에 가장 작은 원소의 답안(=초기값)을 미리 초기화해야합니다. <br><br>가짜 문제끼리의 연결 고리를 잘 판단해야합니다. <br><br><br><br>진짜 문제 = 주어진 n에 대해서 n을 1,2,3의 합으로 표현하는 경우의 수<br>
가짜 문제 = d[i] = i를 1,2,3의 합으로 표현하는 경우의 수 <br><br>d 배열을 전부 채우고 d[n]을 구한다. <br><br>d[1] = 1<br>
d[2] = 2<br>
d[3] = 4 <br><br>점화식을 구하는 과정은 다음과 같습니다.<br>
1: d[i] 계산에 필요한 탐색 경우를 공통점끼리 묶어냅니다.<br>
2: 묶어낸 부분의 정답을 d 배열을 이용해서 빠르게 계산해봅니다. <br>예시를 이용해 위 프로세스를 연습해보겠습니다.<br>
<img src="https://i.imgur.com/fxzGROr.png" referrerpolicy="no-referrer"><br>
공통점을 묶어낼 때는 마지막의 공통을 찾아보는 것만으로 쉽게 찾아낼 수 있습니다. 가장 마지막에 더하는 숫자를 기준으로 파티션을 묶어보겠습니다. <br><img src="https://i.imgur.com/VUuqPho.png" referrerpolicy="no-referrer"><br>
전체 경우의 수는 각 파티션의 경우의 수의 합이 됩니다. 각 파티션이 무엇을 의미하는지 정의해보겠습니다. <br><img src="https://i.imgur.com/Tba0Y66.png" referrerpolicy="no-referrer"><br>
각 파티션은 마지막에 1을 더하는 경우 + 마지막에 2를 더하는 경우 + 마지막에 3을 더하는 경우로 나눌 수 있습니다. 즉 점화식은 다음과 같이 도출할 수 있습니다. <br>D[i-1] + D[i-2] + D[i-3]
<br><br><br>1: 한 계단 혹은 두개의 계단을 올라갈 수 있음.<br>
2: 연속된 세 개의 계단을 밟을 수는 없음.<br>
3: 도착 계단은 반드시 밟아야한다. <br>-&gt; 각 계단에서 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총점의 최댓값 구하기 <br><br>다음과 같은 가짜 문제를 정의할 수 있습니다. <br>D[i] = i번째 계단을 밟을 때 최댓값 
<br>위와 같은 가짜문제로 점화식을 정의하면 다음과 같습니다. <br>//한칸 전 계단을 밟을 때 최댓값 + 두칸 전 계단을 밟을 때 최댓값 

D[i] = max( D[i-1]+A[i] , D[i-2] + A[i] );
<br>하지만 위 점화식에서는 계단을 어떤식으로 도착했는지의 정보가 없습니다. i-1번째 계단 직전에 i-2번째 계단도 밟았는지에 대한 정보가 누락되어있습니다. 즉 연속된 세 개의 계단을 밟았는지 밟지 않았는지 판단할 수 없습니다. <br><br>D[i][0] = i-1번째 계단을 밟지 않고 I계단을 밟았을 때의 총점 총합.
D[i][1] = i-1번째 계단을 밟고 i계단을 밟았을 때의 총점 총합.
<br><br>max( D[n][0], D[n][1])
<br><br>D[i][0] =Max(d[i-2][1], d[i-2][0]) + a[i]
D[i][1] = d[i-1][0] + a[i]
<br>i-1번째를 밟지 않는 경우의 수를 고려하려면 i-2번지를 밟고 올라는 경우의 수만 고려하면 됩니다. 이 때 i-2번지에서는 i-3을 밟던 밟지 않던 i를 연속으로 밟을 때 포함되지 않습니다. 즉 모든 경우의 수를 고려하여 최댓값만 추출합니다. <br>반대로 i-1번째를 밟아야하는 경우는 i-2번째 칸은 밟으면 안됩니다. d[i-1][0] 만 고려하면 됩니다. <br><br>public static void main(String[] args )throws IOException{  
	int n= Integer.parseInt(buffer.readLine());  

	int[] scores = new int[301];  

	for(int i=1; i&lt;=n; i++){  
		scores[i] = Integer.parseInt(buffer.readLine());  
	}  

	int[][] d = new int[301][2];  
	  
	d[1][0] = 0;  
	d[1][1] = scores[1];  

	d[2][1] = scores[1]+scores[2];  
	d[2][0] = scores[2];  
	//d[i][0] = i-1번째 계단을 밟지 않았을 때의 총합 중 최대  
	//d[i][1] = i-1번째 계단을 밟았을 때의 총합 중 최대  

	//d[i][0] = d[i-2][1], d[i-2][0]  
	//d[i][1] = d[i-1][0]  

	for(int i=3; i&lt;=n; i++){  
		d[i][0] = Math.max(d[i-2][1], d[i-2][0]) + scores[i];  
		d[i][1] = d[i-1][0]+scores[i];  
	}  
	System.out.println(Math.max(d[n][0], d[n][1]));  
}  
<br><br>dp 테이블을 채워 나갈 때에 기록을 함께 한다면 실제 방법 도 찾을 수 있습니다. 이를 역추적 혹은 bactrack이라고 합니다. <br><br>
<br>prev 배열을 추가하여 이동 경로를 추적합니다.
<br>prev 배열을 사용하여 각 상태로 이전에 어떤 계단에서 왔는지 기록합니다.
<br>마지막 계단에서 최대 값(d[n][0] 또는 d[n][1])을 선택하고, 그 상태에서부터 거꾸로 추적하여 경로를 구합니다.
<br>LinkedList를 사용하여 경로를 저장하고, 마지막에 출력합니다.
<br>
int n= Integer.parseInt(buffer.readLine());  

int[] scores = new int[301];  

for(int i=1; i&lt;=n; i++){  
	scores[i] = Integer.parseInt(buffer.readLine());  
}  

int[][] d = new int[301][2];  


d[1][0] = 0;  
d[1][1] = scores[1];  

d[2][1] = scores[1]+scores[2];  
d[2][0] = scores[2];  

int[][] prev = new int[301][2];  
prev[2][0] = 0;  
prev[2][1] = 1;  


for(int i=3; i&lt;=n; i++){  
	if (d[i-2][1] &gt; d[i-2][0]) {  
		d[i][0] = d[i-2][1] + scores[i];  
		prev[i][0] = 1; // 2칸 이전의 1 상태에서 온 것  
	} else {  
		d[i][0] = d[i-2][0] + scores[i];  
		prev[i][0] = 0; // 2칸 이전의 0 상태에서 온 것  
	}  
	d[i][1] = d[i-1][0] + scores[i];  
	prev[i][1] = 0; // 1칸 이전의 0 상태에서 온 것  
}  

int maxIndex = (d[n][0] &gt; d[n][1]) ? 0 : 1;  
System.out.println(Math.max(d[n][0], d[n][1]));  

LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();  
int current = n;  
int state = maxIndex;  

while (current &gt; 0) {  
	path.addFirst(current);  
	if (state == 1) {  
		state = prev[current][state];  
		current -= 1;  
	} else {  
		state = prev[current][state];  
		current -= 2;  
	}  
}  

for (int step : path) {  
	System.out.print(step + " ");  
}  


System.out.println(Math.max(d[n][0], d[n][1]));  
<br><br>1: 크기가 존재하는 파일들이 k개 존재함<br>
2: 연속한 두 파일을 하나로 합치려면 합친 크기 만큼의 비용이 발생<br>
3: 전체 k개의 파일을 하나로 합치는 방법 중 비용의 최솟값을 계산하기 <br><br>D[i][j] = i~j 번 파일을 하나로 합치는 최소 비용 
<br><br>D[1][k] = 1~k번 파일을 하나로 합치는 최소 비용 
<br><br> 공통점끼리 묶어내는 파티셔닝을 먼저 적용해봅시다.<br>
<img src="https://i.imgur.com/Pxac9Ap.png" referrerpolicy="no-referrer"><br>
마지막으로 행위가 같은 경우의 수 끼리 묶어볼 수 있습니다.<br>
<img src="https://i.imgur.com/BopQRHt.png" referrerpolicy="no-referrer"><br>요소간의 구간을 나누는 것이 기준이 되기 때문에 항상 전체 길이의 -1 만큼 구간이 발생합니다.<br><img src="https://i.imgur.com/mBx6S2w.png" referrerpolicy="no-referrer"><br><br>점화식을 채울 때마다 총량 계산을 진행해도 되지만 누적합 테크닉을 사용해서 전처리를 미리 진행합니다. <br>Sum[i][j] = i번~j번 파일의 총합 = Sum[i][j-1] + a[j]
<br>
int[][] sum = new int[K+1][K+1];  
  
sum[0][0] = sizes[0];  
for(int i=1; i&lt;=K; i++){  
    sum[i][i] = sizes[i];  
    for(int j=i; j&lt;=K;j++){  
        if(j==1) continue;  
        sum[i][j] = sum[i][j-1]+sizes[j];  
    }  
}

<br><br>시작하는 구간과 끝나는 구간이 정의되는 D 배열의 경우 채워나가는 순서가 중요합니다. 기존의 문제들은 첫행부터 차례대로 채워나가지만, 해당 문제는 다른 순서를 적용해야합니다. <br>d[1][4]을 채우기 위해서는 d[1][1] 와 d[2][4]가 필요합니다. 즉 첫행부터 채워지면 필요한 부분 문제의 정답을 가져올 수 없습니다. <br>dp에서는 항상 짧은 구간부터 풀어나가는 것을 원칙으로 합니다. 해당 문제도 구간의 길이가 짧은 문제들을 먼저 풉니다. <br>for len = 1~k 
	for i = 1 ~ (k-len+1)
		for j = i + len-1 
<br><img src="https://i.imgur.com/crvrWlo.png" referrerpolicy="no-referrer"><br>
for(int length =2; length&lt;=K; length++ ){  
    for(int i=1; i&lt;=K-length+1; i++){  
        int j = i + length-1;  
  
        d[i][j] = Integer.MAX_VALUE;  
  
        for(int k=i; k&lt;j; k++){  
            d[i][j] = Math.min(d[i][j], d[i][k]+d[k+1][j]+sum[i][j]);  
        }  
  
    }  
}
<br><br>
int K = Integer.parseInt(buffer.readLine());  
int[][] d = new int[K+1][K+1];  
int[] sizes = new int[K+1];  
  
tokens = new StringTokenizer(buffer.readLine());  
  
for(int i=1; i&lt;=K; i++){  
    sizes[i] = Integer.parseInt(tokens.nextToken());  
}  
  
int[][] sum = new int[K+1][K+1];  
  
sum[0][0] = sizes[0];  
for(int i=1; i&lt;=K; i++){  
    sum[i][i] = sizes[i];  
    for(int j=i; j&lt;=K;j++){  
        if(j==1) continue;  
        sum[i][j] = sum[i][j-1]+sizes[j];  
    }  
}  
  
for(int length =2; length&lt;=K; length++ ){  
    for(int i=1; i&lt;=K-length+1; i++){  
        int j = i + length-1;  
  
        d[i][j] = Integer.MAX_VALUE;  
  
        for(int k=i; k&lt;j; k++){  
            d[i][j] = Math.min(d[i][j], d[i][k]+d[k+1][j]+sum[i][j]);  
        }  
  
    }  
}  
  
result.append(d[1][K]).append("\n");
]]></description><link>알고리즘과-자료구조/알고리즘/dp/다이나믹-프로그래밍-기본.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/DP/다이나믹 프로그래밍 기본.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 13 Jul 2024 12:31:09 GMT</pubDate><enclosure url="https://i.imgur.com/fxzGROr.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/fxzGROr.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[완전탐색을 DP로 바꾸기 (Memoization)]]></title><description><![CDATA[ 
 <br><br>완전 탐색은 서로 다른 여러 경우의 수를 탐색하는 중복이 많으면 많을 수록 비효율적으로 변합니다.<br><img src="https://i.imgur.com/3fizcUr.png" referrerpolicy="no-referrer"><br>fib(5)의 왼쪽 fib(4)에서 fib(3)과 fib(2)를 호출합니다. 바로 오른쪽 fib(3)에서 또한 fib(2)를 호출하기 때문에 동일한 결과를 반환하는 연산을 계속해서 시행합니다.<br><br>한 번 풀었던 부분 문제에 대한 답을 저장해 놓았다가 해당 부분 문제를 다시 풀 일이 생기면 재사용하는 것이 메모이제이션입니다.<br><br>재귀 구현에 메모이제이션을 적용하려면 다음 과정을 거치면 됩니다.<br>1: 문제에서 제시된 범위에 따라 메모이제이션 배열 선언과 초기화<br>
2: 재귀 종료 조건에 메모이제이션 조건 추가<br>
3: 부분 문제에 대한 답을 구한 후 메모이제이션 배열에 기록하기<br><br>메모이제이션을 활용해 피보나치 수열을 구하는 백트래킹 코드를 개선해 보겠습니다. 다음과 같은 사고의 흐름으로 재귀 코드를 작성한 후 메모이제이션을 적용해 시간 복잡도를 개선할 수 있습니다. <br>문제에서 제시된 범위에 따라 메모이제이션 배열 선언과 초기화합니다.<br>-차원 : 상태에 포함된 변수 개수<br>
-변수 : 차원의 인덱스<br>실제 코드<br>-피보나치 수 문제의 상태는 n 하나이므로 1차원 배열입니다.<br>
-부분 문제의 답은 피보나치 수 이므로 Long 배열이어야합니다.<br>
-최대 100까지 입력된다고 가정하면 배열의 크기는 101입니다.<br>위 3가지 조건을 고려하여 다음 코드를 작성합니다. <br>private static final long[] mem = new long[101];
<br>-배열을 선언 후에는 정답이 될 수 없는 값으로 배열을 모두 채웁니다.<br>Arrays.fill(mem, -1); 
<br>재귀의 종료 조건에 메모이제이션 추가합니다<br>→ 이미 풀어본 문제를 다시 풀 필요가 없습니다.<br>→ 메모이제이션이 되어 있는지 먼저 확인합니다.<br>종료 조건 vs 메모이제이션 조건의 순서<br>-종료 조건에서 비용이 큰 연산이 있다면 메모이제이션 검사를 우선으로 하는 것이 좋습니다.<br>
-종료 조건이 불가능한 상태를 검사하는 것이라면 기존 종료 조건을 먼저 검사해야합니다.<br>위 조건을 고려하면 다음 코드를 작성합니다. <br>if(mem[n] != -1) return mem[n];
if(n=0||n==1) return n; 
<br>부분 문제에 대한 답을 구한 후 메모이제이션 배열에 기록<br>메모이제이션이 되어 있지 않을 경우 부분 문제를 풉니다. 이후 결과를 메모이제이션 배열에 저장합니다.<br>return mem[n] = fib(n-1) + fib(n-2); 
<br>전체 코드<br>private static final long = new long[101];
private static long fib(int n){

	if(mem[n]!=-1) return men[n]; 
	
	if(n==0 || n==1) return n; 
	
	return mem[n] = fib(n-1) + fib(n-2); 
	
}

public static void main(String[] args){
	Arrays.fill(mem, -1);
	System.out.println(fib(10)); 
}
<br><br>동적 프로그래밍 문제는 대부분 점화식을 이용한 재귀로 우선 구현하고 메모이제이션 처리를 추가하는 방식으로 해결 가능합니다.<br>문제 해결은 다음과 같이 진행합니다.<br>1: 상태 (부분 문제) 정의하기<br>
2: 종료 조건 찾기<br>
3: 점화식 세우기<br>
4: 재귀로 구현하기<br>
5: 메모이제이션 적용하기<br><br>1: 중복이 많이 발생하지 않는 재귀 문제는 메모이제이션 처리를 하더라도 효율적이지 않습니다.<br>→ 동적 프로그래밍을 적용하기 위해서는 중복되는 부분 문제가 많이 발생하는지 따져 보아야합니다.
<br>2: 재귀 호출이 너무 깊어지면 StackOverflowError가 발생합니다. 일반적으로 재귀는 깊이를 10,000번 이하로 유지 시켜야 합니다.<br><br>
<br>탑 다운 방식은 다음과 같이 진행됩니다.
fibo(10) -&gt; fibo(9) -&gt; fibo(8) -&gt; ... -&gt; fibo(2) -&gt; fibo(1)

  n이 조금만 커져도 재귀의 깊이가 굉장히 깊어집니다.<br>

<br>-같은 부분 문제의 답은 항상 같다 는 재귀의 특성을 이용하여 다음과 같이 작은 부분 문제부터 미리 풉니다.<br>    for(int i=0; i&lt;=10000; i++){
    	fibo(i); 
    }
    ```
]]></description><link>알고리즘과-자료구조/알고리즘/dp/완전탐색을-dp로-바꾸기-(memoization).html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/DP/완전탐색을 DP로 바꾸기 (Memoization).md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Fri, 12 Jul 2024 15:54:29 GMT</pubDate><enclosure url="https://i.imgur.com/3fizcUr.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/3fizcUr.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[트리에 DP를 적용해보기]]></title><description><![CDATA[ 
 <br><br>Rooted Tree이기 때문에 항상 부모 자식 관계가 존재합니다. 자식 노드의 결과를 활용해 부모 노드의 결과를 유추할 수 있습니다. dfs로 리프노드까지 도달 후 올라오면서 자식의 결과로 dp 배열을 채워나갑니다. <br><br>Rooted Tree 문제를 DP로 풀 경우 대부분 DFS로 한번에 해결합니다. DFS의 시간 복잡도인 O(V+E)만에 문제를 해결할 수 있습니다. <br><br><br>정점을 루트로 하는 서브트리에 속한 정점의 수를 출력하는 문제입니다. <br><br>D[i] = i를 루트로 하는 subtree의 정점 개수 
<br><br>리프노드는 자식을 가지고 있지 않아, 해당 노드만 1로 초기화합니다. <br><br>D[부모노드] = sum(d[자식노드들])+1(자기자신)
<br><br>
private static void dfs(int current, int parent){  
	//어떤 노드건 자기 자신도 무조건 서브 트리에 속합니다. 
	//최소한 개수가 1은 보장됩니다. 
    d[current] = 1;  
  
    for(int child : graph[current]){  
        if(child==parent) continue;  
  
        dfs(child, current);  
        d[current]+=d[child];  
    }  
}

]]></description><link>알고리즘과-자료구조/알고리즘/dp/트리에-dp를-적용해보기.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/DP/트리에 DP를 적용해보기.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 13 Jul 2024 13:25:49 GMT</pubDate></item><item><title><![CDATA[2. 그리디]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/알고리즘/2.-그리디.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/2. 그리디.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:15:58 GMT</pubDate></item><item><title><![CDATA[알고리즘]]></title><description><![CDATA[<a class="tag" href="?query=tag:Root" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Root</a> 
 <br><a href=".?query=tag:Root" class="tag" target="_blank" rel="noopener nofollow">#Root</a> <br><a data-href="2. DP" href="알고리즘과-자료구조/알고리즘/dp/2.-dp.html" class="internal-link" target="_self" rel="noopener nofollow">2. DP</a><br>
<a data-href="2. 그리디" href="알고리즘과-자료구조/알고리즘/2.-그리디.html" class="internal-link" target="_self" rel="noopener nofollow">2. 그리디</a><br>
<a data-href="2. 이진탐색" href="알고리즘과-자료구조/알고리즘/이진탐색/2.-이진탐색.html" class="internal-link" target="_self" rel="noopener nofollow">2. 이진탐색</a><br>
<a data-href="2. 최단거리" href="알고리즘과-자료구조/알고리즘/최단거리/2.-최단거리.html" class="internal-link" target="_self" rel="noopener nofollow">2. 최단거리</a><br>
<a data-href="2. 완전탐색" href="알고리즘과-자료구조/알고리즘/완전탐색/2.-완전탐색.html" class="internal-link" target="_self" rel="noopener nofollow">2. 완전탐색</a><br>
<a data-href="2. 문자열" href="알고리즘과-자료구조/알고리즘/문자열/2.-문자열.html" class="internal-link" target="_self" rel="noopener nofollow">2. 문자열</a>]]></description><link>알고리즘과-자료구조/알고리즘/알고리즘.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘/알고리즘.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:40:48 GMT</pubDate></item><item><title><![CDATA[Untitled Overview]]></title><description><![CDATA[ 
 <br><br><a data-href="Kruscal" href="알고리즘과-자료구조/자료구조/mst/kruscal.html" class="internal-link" target="_self" rel="noopener nofollow">Kruscal</a><br>
<a data-href="Prim" href="알고리즘과-자료구조/자료구조/mst/prim.html" class="internal-link" target="_self" rel="noopener nofollow">Prim</a><br>
<a data-href="Union Find" href="알고리즘과-자료구조/자료구조/mst/union-find.html" class="internal-link" target="_self" rel="noopener nofollow">Union Find</a>]]></description><link>알고리즘과-자료구조/자료구조/mst/2.-mst.html</link><guid isPermaLink="false">알고리즘과 자료구조/자료구조/MST/2. MST.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:27:33 GMT</pubDate></item><item><title><![CDATA[Kruscal]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/자료구조/mst/kruscal.html</link><guid isPermaLink="false">알고리즘과 자료구조/자료구조/MST/Kruscal.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:26:18 GMT</pubDate></item><item><title><![CDATA[Union Find]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/자료구조/mst/union-find.html</link><guid isPermaLink="false">알고리즘과 자료구조/자료구조/MST/Union Find.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:26:12 GMT</pubDate></item><item><title><![CDATA[연결리스트]]></title><description><![CDATA[ 
 <br><br>야매 연결리스트는 원소를 배열로 관리합니다. 3가지의 배열이 사용됩니다. pre, nxt에 이전 다음 노드의 포인터 대신 배열 상의 인덱스를 저장하는 방식으로 구현합니다. <br>야매 연결리스트는 erase 함수의 구현 방식 때문에 메모리 누수가 발생합니다. 즉, 실무에서는 절대로 쓰면 안되고,,,, 코딩테스트에서는 시간복잡도에 한해 일반적인 STL/라이브러리와 동일하기 때문에 그대로 사용해도 무방합니다. <br><br>private final int MAX = 100005;
int[] data[MAX], pre[MAX], nxt[MAX]; 
int unused = 1; 
<br>
<br>pre, nxt가 1이라면 해당 원소의 이전/다음 원소가 존재하지 않습니다. 
<br>unused는 현재 사용되지 않는 인덱스 (= 새로운 데이터를 삽입할 수 있는 인덱스)입니다. 
<br>0번지는 연결리스트의 시작 더미 노드로 고정합니다.<br>
: 삽입과 삭제를 구현할 때 원소가 아예 없는 경우의 예외처리가 쉽습니다. 
<br><br>연결리스트의 모든 원소를 출력하는 함수를 구현해봅시다.<br>
0번지에서 출발해 nxt에 적힌 값을 보고 계속 넘어가면서 data를 출력합니다. <br>public String traverse(){
	StringBuilder result= new StringBuilder(); 
	//시작 더미 노드에서 출발합니다. 
	int cur = nxt[0];
	while(cur!=-1){
		cur = next[cur]; 
		result.append(data[cur]).append("-&gt;");
	}	
	result.append("\n");
	return result.toString();
}
<br><br>연결리스트에 특정 노드를 추가하는 함수를 구현해봅시다. <br>public void insert(int addr, int num){
	data[unused] = num; 

	//삽입하는 노드의 전 노드를 갱신합니다. 
	pre[unused] = addr; 

	//삽입하는 노드의 다음 노드를 갱신합니다. 
	nxt[unused] = nxt[addr]; 
	
	//다음 위치의 pre를 삽입한 노드로 변경합니다. 
	if(nxt[addr]!=-1) pre[nxt[addr]] = unused;

	//전 노드의 nxt를 삽입하는 노드로 변경합니다. 
	nxt[addr] = unused; 	

}
<br>첫번째, 새로운 노드 생성하기<br>
: unused가 가르키는 곳이 원소가 들어갈 수 있는 배열의 인덱스입니다.<br>두번째, pre에 삽입할 위치의 주소를 대입합니다. <br>세번째, nxt에 삽입할 위치의 다음 주소를 대입합니다. <br>네번째, 삽입할 위치의 nxt와 삽입할 위치의 다음 원소의 pre를 새 원소로 변경합니다. <br>마지막, unused를 갱신합니다. <br><br>
public void erase(int addr){
	nxt[prev[addr]] = nxt[addr];
	if(nxt[addr]!=-1) pre[next[addr]] = pre[addr];
}

<br>첫번째, 이전 위치의 nxt를 삭제할 위치의 nxt로 변경합니다.<br>두번째, 다음 위치의 pre를 삭제할 위치의 pre로 변경합니다.]]></description><link>알고리즘과-자료구조/자료구조/연결리스트.html</link><guid isPermaLink="false">알고리즘과 자료구조/자료구조/연결리스트.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 28 Jul 2024 07:46:50 GMT</pubDate></item><item><title><![CDATA[우선순위 큐]]></title><description><![CDATA[ 
 ]]></description><link>알고리즘과-자료구조/자료구조/우선순위-큐.html</link><guid isPermaLink="false">알고리즘과 자료구조/자료구조/우선순위 큐.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:15:05 GMT</pubDate></item><item><title><![CDATA[자료구조]]></title><description><![CDATA[<a class="tag" href="?query=tag:Root" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Root</a> 
 <br><a href=".?query=tag:Root" class="tag" target="_blank" rel="noopener nofollow">#Root</a> <br><a data-href="덱" href="알고리즘과-자료구조/자료구조/덱.html" class="internal-link" target="_self" rel="noopener nofollow">덱</a><br><a data-tooltip-position="top" aria-label="알고리즘과 자료구조/자료구조/스택" data-href="알고리즘과 자료구조/자료구조/스택" href="알고리즘과-자료구조/자료구조/스택.html" class="internal-link" target="_self" rel="noopener nofollow">스택</a><br>
<a data-href="연결리스트" href="알고리즘과-자료구조/자료구조/연결리스트.html" class="internal-link" target="_self" rel="noopener nofollow">연결리스트</a><br>
<a data-href="우선순위 큐" href="알고리즘과-자료구조/자료구조/우선순위-큐.html" class="internal-link" target="_self" rel="noopener nofollow">우선순위 큐</a><br>
<a data-href="큐" href="알고리즘과-자료구조/자료구조/큐.html" class="internal-link" target="_self" rel="noopener nofollow">큐</a><br>
<a data-href="트리맵" href="알고리즘과-자료구조/자료구조/트리맵.html" class="internal-link" target="_self" rel="noopener nofollow">트리맵</a><br>
<a data-href="해시맵" href="알고리즘과-자료구조/자료구조/해시맵.html" class="internal-link" target="_self" rel="noopener nofollow">해시맵</a><br>
<a data-href="2. MST" href="알고리즘과-자료구조/자료구조/mst/2.-mst.html" class="internal-link" target="_self" rel="noopener nofollow">2. MST</a>]]></description><link>알고리즘과-자료구조/자료구조/자료구조.html</link><guid isPermaLink="false">알고리즘과 자료구조/자료구조/자료구조.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:41:46 GMT</pubDate></item><item><title><![CDATA[No title]]></title><description><![CDATA[ 
 <br><br>만약 문제를 읽는데<br>
1: 배열이 등장하고,<br>
2: 연속된 부분수열로 무언가를 수행하고<br>
3: 연속된 부분 수열의 구간이 계속 바뀐다면<br>
세그먼트 트리 문제일 확률이 높습니다. <br>세그먼트 트리로만 풀 수 있는 문제는 없지만, 세그먼트 트리를 활용하면 쉽게 풀리는 문제가 존재합니다. <br><br>원소에 대한 갱신이 일어나는 경우 <br>세그먼트 트리에서 세그먼트가 의미하는 것 <br>많이 계산할 유형에 대해서 미리 계산함.<br>
절반씩 나눠서 조각으로 만들고 해당 조각 내 원소의 총합을 저장함.<br>
궁금한 구간의 쿼리가 들어올 경우 미리 만들어놓은 조각을 합쳐서 쿼리와 동일한 구간을 만든다. <br>조각이 많이 생기면 어떡하나요?<br>
생각보다 조각이 많이 생기지 않습니다. 조각의 개수는 최대 2~4배까지 생성됩니다. 마지막 층에는 길이 1짜리 조각이 데이터 개수 만큼 생성이 됩니다. 위로 올라갈 수록 조각의 수는 1/2배가 됩니다.<br>
n, n/2, n/4, ..., 1개처럼 1/2가 공비인 수열의 총합이기 때문에 대부분의 케이스에서 데이터가 개수를n으로 할 때, 4배에서 2배 정도 사이의 조각이 생성됩니다. <br>부모 노드의 대표값은 자식 노드의 대표값을 활용해서 계산할 수 있음<br>원소의 값이 바뀐다면?<br>
루트노드부터 시작하여 대표값을 변경합니다. 이후 루트에서 리프노드에 도달하는 경로를 찾는다. 리프노드에서 경로를 따라 루트노드까지 다시 이동하면서 각 노드의 대표값을 수정합니다. <br>특정 구간의 합을 구할 경우?<br>
// 세그먼트 트리 초기화
public static void init(int node, int nodeLeft, int nodeRight) {
	if (nodeLeft == nodeRight) {
		maxTree[node] = a[nodeLeft];
		minTree[node] = a[nodeLeft];
		return;
	}

	int mid = (nodeLeft + nodeRight) / 2;

	init(
			node * 2,
			nodeLeft,
			mid
	);

	init(
			node * 2 + 1,
			mid + 1,
			nodeRight
	);

	maxTree[node] = Math.max(maxTree[node * 2], maxTree[node * 2 + 1]);
	minTree[node] = Math.min(minTree[node * 2], minTree[node * 2 + 1]);
}
<br>노드의 왼쪽구간과 오른쪽 구간이 같은 경우는 현재 노드가 리프 노드인 상황입니다. 최소 트리, 최대 트리, 총합트리 모두 구간이 1인 경우의 대표값은 자기 자신이므로 바로 값을 초기화하면됩니다. <br>if (nodeLeft == nodeRight) {
	maxTree[node] = a[nodeLeft];
	minTree[node] = a[nodeLeft];
	return;
}
<br>구간을 분할할 때는 절반씩 나누어 분배합니다. <br>int mid = (nodeLeft + nodeRight) / 2;

init(
		node * 2,
		nodeLeft,
		mid
);

init(
		node * 2 + 1,
		mid + 1,
		nodeRight
);
<br>왼쪽 자식과 오른쪽 자식의 대표값 계산이 끝났으므로, 현재 노드의 대표값을 계산해야합니다. <br>maxTree[node] = Math.max(maxTree[node * 2], maxTree[node * 2 + 1]);
minTree[node] = Math.min(minTree[node * 2], minTree[node * 2 + 1]);
<br>특정 원소가 변경될 경우?<br>

public static void update(int node, int nodeLeft, int nodeRight, int queryIndex, int value) {
	if (queryIndex &lt; nodeLeft || nodeRight &lt; queryIndex) {
		return;
	}

	if (nodeLeft == nodeRight) {
		maxTree[node] = value;
		minTree[node] = value;
		return;
	}

	int mid = (nodeLeft + nodeRight) / 2;

	update(
			node * 2,
			nodeLeft,
			mid,
			queryIndex,
			value
	);

	update(
			node * 2 + 1,
			mid + 1,
			nodeRight,
			queryIndex,
			value
	);

	maxTree[node] = Math.max(maxTree[node * 2], maxTree[node * 2 + 1]);
	minTree[node] = Math.min(minTree[node * 2], minTree[node * 2 + 1]);
}

<br>update 함수에 들어오는 인자는 5개입니다.<br>
queryIndex 위치의 값을 value 로 변경해야합니다.<br>
node는 현재 탐색중인 노드를 의미하며 nodeLeft와 nodeRight는 현재 노드가 담당하고 있는 구간이 됩니다. <br>내가 담당하고 있지 않는 구간의 업데이트일 경우 <br>if (queryIndex &lt; nodeLeft || nodeRight &lt; queryIndex) {
	return;
}
<br>하위 노드에 대해서 먼저 업데이트 처리를 진행해봅니다. <br>
int mid = (nodeLeft + nodeRight) / 2;

update(
		node * 2,
		nodeLeft,
		mid,
		queryIndex,
		value
);

update(
		node * 2 + 1,
		mid + 1,
		nodeRight,
		queryIndex,
		value
);
<br>자식 노드를 이용해서 현재 노드의 대표값을 업데이트합니다. <br>maxTree[node] = Math.max(maxTree[node * 2], maxTree[node * 2 + 1]);
minTree[node] = Math.min(minTree[node * 2], minTree[node * 2 + 1]);
<br>특정 구간에서 변경이 일어날 경우 <br>public static int queryMax(int node, int nodeLeft, int nodeRight, int queryLeft, int queryRight) {
	if (queryRight &lt; nodeLeft || nodeRight &lt; queryLeft) {
		return 0;
	}

	if (queryLeft &lt;= nodeLeft &amp;&amp; nodeRight &lt;= queryRight) {
		return maxTree[node];
	}

	int mid = (nodeLeft + nodeRight) / 2;
	int leftMax = queryMax(
			node * 2,
			nodeLeft,
			mid,
			queryLeft,
			queryRight
	);
	int rightMax = queryMax(
			node * 2 + 1,
			mid + 1,
			nodeRight,
			queryLeft,
			queryRight
	);

	return Math.max(leftMax, rightMax);
}

<br>case1. 완전히 안겹치는 경우 = 업데이트할 필요 없는 경우<br>
쿼리의 최대범위 &lt; 현대 노드의 최소 범위<br>
현재 노드의 최대 범위 &lt;쿼리의 최소 범위 <br>if (queryRight &lt; nodeLeft || nodeRight &lt; queryLeft) {
	return 0;
}
<br>이 때 아무값이나 반환하면 안되고, 내가 구하고자하는 연산의 항등원 반환해야합니다.<br>
더하거나 뺄 경우에는 0<br>
최대값을 계산할 경우에는 -무한대나 문제 범위의 최소값 <br>case2. 궁금한 구간이 현재 노드에서 전부 커버하는 경우 <br>if (queryLeft &lt;= nodeLeft &amp;&amp; nodeRight &lt;= queryRight) {
	return maxTree[node];
}
<br>case3. 그 외 경우 <br>int mid = (nodeLeft + nodeRight) / 2;
int leftMax = queryMax(
		node * 2,
		nodeLeft,
		mid,
		queryLeft,
		queryRight
);
int rightMax = queryMax(
		node * 2 + 1,
		mid + 1,
		nodeRight,
		queryLeft,
		queryRight
);

return Math.max(leftMax, rightMax);
<br>하위 노드를 찾아보면서 진행합니다. <br>비재귀 형식 vs 재귀형식<br>
비재귀 형식 구현 (바텀업)은 특정 원소를 바꾸는 연산을 구현할 수 있지만, 특정 구간의 원소 전체를 변경하는 연산은 구현할 수 없습니다. ]]></description><link>알고리즘과-자료구조/세그먼트-트리.html</link><guid isPermaLink="false">알고리즘과 자료구조/세그먼트 트리.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 29 Jun 2024 07:43:06 GMT</pubDate></item><item><title><![CDATA[알고리즘과 자료구조]]></title><description><![CDATA[<a class="tag" href="?query=tag:Root" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Root</a> 
 <br><a href=".?query=tag:Root" class="tag" target="_blank" rel="noopener nofollow">#Root</a> <br><a data-href="알고리즘" href="알고리즘과-자료구조/알고리즘/알고리즘.html" class="internal-link" target="_self" rel="noopener nofollow">알고리즘</a><br>
<a data-href="자료구조" href="알고리즘과-자료구조/자료구조/자료구조.html" class="internal-link" target="_self" rel="noopener nofollow">자료구조</a>]]></description><link>알고리즘과-자료구조/알고리즘과-자료구조.html</link><guid isPermaLink="false">알고리즘과 자료구조/알고리즘과 자료구조.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 11:40:39 GMT</pubDate></item><item><title><![CDATA[Hash 함부로 쓰면 메모리 터진다]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/2121" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2121" target="_blank">문제풀어보기</a><br>실버 3의 비교적 쉬운 문제처럼 보이는데요. 위 문제는 생각없이 풀면 머리에 ? 띄우기 딱 좋은 문제입니다. 특히 잘못된 풀이의 경우 논리적, 시간복잡도 측면에서도 틀린 것이 전혀 없기 때문에 헤매기 매우 쉽습니다. 풀이방향 잘못 잡으면 메모리 초과가 발생하기 때문에, 공간복잡도를 건드는 문제는 조심해서 접근해야합니다. <br>심지어 python, cpp에서는 문제 없이 통과되는 코드가 Java 특유의 객체지향성과 JVM/GC 특성이 환장의 시너지를 일으켜 통과가 안되는 경우가 꽤 있습니다. (억울) Java 쓴다고 이런 패널티를 받을 수는 없으니, 유의하도록합시다. (혹은 빠른 시일 내에 cpp나 python으로 갈아ㅌ..)<br>대기업 공채에서 이런 문제에 잘못 낚일 경우 6개월에서 1년동안 손가락 빨고 있어야합니다 ㅎㅅㅎ<br><img src="https://i.imgur.com/vhS6I39.png" referrerpolicy="no-referrer"><br>문제를 간단히 요약하면 다음과 같습니다. <br>
<br>n개의 좌표가 입력으로 주어진다. 
<br>직사각형의 길이 a,b가 주어진다. 
<br>n개의 좌표로 직사각형을 만들 때 길이가 일치하는 경우의 수 구하기 
<br>특이한건 전체 데이터의 개수가 약 10^5 개, 각 좌표값은 long 타입 써야할 정도로 숫자가 매우 흉악한데요. 전형적인 데이터 개수 &amp; 크기로 내리찍는 문제입니다. 이 부분을 유의하면서 풀어봅시다. 불행 중 다행으로 전체 경우의 수는 2^31 안으로 나온다했으니, 정답 변수 만큼은 int로 선언할 수 있겠네요.<br><br> 정말 간단하게 접근했을 때의 풀이입니다. 백트래킹이나 4중 반복문을 써서 가능한 모든 조합을 테스트 해보는 것입니다. 먼저 시간 복잡도를 계산해보겠습니다. 백트래킹으로 구현할 경우 조합의 개수 만큼 시간 복잡도가 나옵니다. nC4가 되므로 n=500,000을 넣어 계산해보겠습니다.<br>
500000C4 = 2,60,385,417,812,487,500(~=10^17)이므로 택도 없는 풀이네요.<br><br>그렇다면 고려해볼만한 것은 해시입니다. 풀이는 다음과 같습니다. <br>답안 로직<br>
<br>x와 y좌표를 속성으로 갖고 x,y로 고유성을 판별할 수 있는 Position클래스를 정의합니다. 
<br>주어진 모든 점을 해시셋에 넣습니다. 
<br>가장 왼쪽 아래의 점(x y)을 잡았다 치고 주어진 모든 점을 순회합니다. 
<br>해시셋에서 나머지 3개의 점 (x+a, y+b), (x,y+b), (x+a,y) 이 있는지 확인합니다. 
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/submit/2121/79462950" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/submit/2121/79462950" target="_blank">전체 코드는 다음과 같습니다.</a><br>시간복잡도를 계산해볼까요?<br>
<br>주어진 입력을 Position 객체로 만들어 해시셋에 저장합니다.(=O(n))
<br>전체 좌표에 대해 순회합니다. (=O(n))
<br>기준 좌표에 대해서 나머지 3개의 좌표가 존재하는 지 해시를 통해 확인합니다. (=O(3x1))
<br>전체 시간 복잡도는 다음과 같습니다. O(n+3*n) = O(n)
<br>전체 시간복잡도는 O(n)으로 매우 무난하게 통과해야하는데요. <br><img src="https://i.imgur.com/l3ixUdK.png" referrerpolicy="no-referrer"><br>????????<br>보시는 바와 같이, 메모리 초과가 발생합니다. 왜 메모리 초과가 발생할까요? 그리고 실전에서 이와 같은 풀이를 방지하려면 어떻게 해야할까요??<br><br>128MB 메모리 제한이 있을 때, Set&lt;Position&gt;가 최대 몇 개의 키를 가질 수 있는지 계산하기 위해서는 각 Position 객체가 차지하는 메모리 크기를 알아야 합니다. 이를 위해 Position 클래스의 메모리 크기를 분석해야 합니다.<br>Position 클래스는 두 개의 long 필드를 가지고 있습니다. long 타입은 64비트(8바이트)이므로, 두 개의 long 필드는 16바이트를 차지합니다. 그러나 Java 객체에는 추가적인 오버헤드가 존재합니다.<br>Java 객체의 메모리 오버헤드는 다음과 같이 계산됩니다:<br>
<br><a data-href="객체 헤더" href="java/객체-헤더.html" class="internal-link" target="_self" rel="noopener nofollow">객체 헤더</a>: 12바이트 (8바이트는 기본 객체 헤더, 4바이트는 정렬 패딩)
<br>long 필드 두 개: 16바이트 (각각 8바이트)
<br>따라서, Position 객체는 12바이트(헤더) + 16바이트(필드) = 28바이트가 됩니다. 그러나 Java 객체는 메모리 정렬 패딩에 따라 8바이트 단위로 정렬됩니다. 그러므로 28바이트는 32바이트로 정렬됩니다.<br>하지만 실제로 Map에 키로 사용될 때는 추가적인 메모리 오버헤드가 발생합니다. 일반적으로 HashSet을 예로 들면:<br>
<br>HashSet.Entry 객체: 약 32바이트 (참조 변수와 정렬 패딩 포함)
<br>기타 오버헤드 (해시 테이블 등): 해시 테이블 크기에 따라 다름
<br>보수적으로 계산해보면, 하나의 Position 객체가 HashSet의 키로 사용될 때 약 64바이트의 메모리를 차지한다고 가정할 수 있습니다.<br>이제 전체 메모리 사용량을 계산해 보겠습니다:<br>
<br>주어진 메모리 제한: 128MB = 128  1024  1024 바이트 = 134,217,728 바이트
<br>각 Position 객체가 약 64바이트를 차지하므로, Map이 가질 수 있는 최대 키의 개수는:<br><br>따라서, 128MB 메모리 제한이 있을 때 Set&lt;Position&gt;은 최대 약 2,097,152개의 키를 가질 수 있습니다.<br>문제에서 풀이는 처음 해시셋에 키를 저장할 때 최대 50만개의 키, 3개의 점으로 판단할 때 최대 200만(4x50만)개의 키를 사용합니다. <br>즉 최대 250만개의 키를 사용할 가능성이 있기 때문에 128MB의 메모리 제한이 있을 때 메모리 초과가 발생합니다. <br><br>그렇다면 해시를 사용하지 않으면 어떻게 해야할까요? 바로 이진탐색을 사용하는 것입니다. 속성이 2가지라 이진 탐색 사용이 어려울 것 같지만, java의 comparable 인터페이스를 구현하여 정렬을 하면 비교적 쉽게 구현할 수 있습니다. <br>풀이는 해시와 비슷합니다. <br>
<br>전체 좌표에 대해서 순회한다. 
<br>해당 좌표를 좌하단 좌표로 기준을 잡고 판단한다. 
<br>나머지 3개의 좌표((x+a, y+b), (x,y+b), (x+a,y))를 이진탐색을 활용해 있는지 없는지만 빠르게 판단한다. 
<br>보시는 바와 같이 기본적인 논리구조는 같은데, 실제 값을 찾을 때 해시를 사용할 것이냐, 이진탐색을 사용할 것이냐의 차이로 갈리게 됩니다.<br>시간복잡도는 전체 좌표에 대해서 순회하는 시간 O(n), 이진탐색을 이용해서 나머지 3개의 좌표가 있는지 없는지 판단하는 시간 O(logN) 총 O(3nlogN)이므로 해시보다는 느려도, 매우 넉넉하게 시간 제한 안에 들어올 수 있습니다. <br>실제 코드를 통해 확인해보겠습니다. <br>이진탐색에서 활용할 데이터 셋은 정렬이 필수기 때문에 정렬을 해주는 모습입니다. <br>

for (int i = 0; i &lt; n; i++) {
	tokens = new StringTokenizer(buffer.readLine());

	positions[i] = new Position(
		Long.valueOf(tokens.nextToken()), 
		Long.valueOf(tokens.nextToken())
		);
	}

Arrays.sort(positions);
<br>전체 좌표를 순회하며 좌하단으로 고정했을 때 나머지 3개의 좌표가 있을 때만 세는 코드입니다.<br>long result = Arrays.stream(positions)
                .filter(p-&gt;isValid(positions, p, a,b))
                .count();
<br>
private static boolean isValid(Position[] positions, Position position, int a, int b){
	return binarySearch(positions, position.x+a, position.y+b)&amp;&amp;
			binarySearch(positions, position.x, position.y+b)&amp;&amp;
			binarySearch(positions, position.x+a, position.y);

}
<br>객체의 comparable 인터페이스를 구현하여 두 종류 이상의 변수가 있어도 쉽게 이진탐색을 수행하는 코드입니다. <br>
private static boolean binarySearch(Position[] positions, long targetX, long targetY) {
	int l = 0;
	int h = positions.length;


	while(h&gt;l){
		int mid = (l+h)/2;

		Position midPosition = positions[mid];

		if(midPosition.x==targetX&amp;&amp;midPosition.y==targetY){
			return true;
		}else if(midPosition.compareTo(new Position(targetX, targetY))&lt;0){
			l=mid+1;
		}else{
			h=mid;
		}
	}

	return false;

}

<br>class Position implements Comparable&lt;Position&gt;{
    long x, y;


    public Position(long x, long y){
        this.x = x;
        this.y = y;
    }
	//equals와 compareTo를 오버라이딩한 메서드는 중략... 

    @Override
    public int compareTo(Position o){
        if(this.x==o.x){
            return Long.compare(this.y, o.y);
        }
        return Long.compare(this.x, o.x);
    }
}
<br><br>
<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/source/79467346" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/source/79467346" target="_blank">파이썬 해시 활용 제출코드</a><br>
<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/source/79464005" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/source/79464005" target="_blank">자바 이진탐색 활용 제출코드</a>
<br>def is_rectangle_present(x, y, A, B, point_set): 
	return ((x + A, y) in point_set 
				and (x, y + B) in point_set 
				and (x + A, y + B) in point_set)

def count_rectangles(points, A, B):
    point_set = set(points)
    count = 0

    for (x, y) in points:
        if is_rectangle_present(x, y, A, B, point_set):
            count += 1

    return count

import sys
input = sys.stdin.read
data = input().split()

N = int(data[0])
A = int(data[1])
B = int(data[2])

points = []
for i in range(N):
    x = int(data[3 + 2 * i])
    y = int(data[4 + 2 * i])
    points.append((x, y))

result = count_rectangles(points, A, B)


print(result)

<br>해쉬를 사용하는 동일한 풀이를 python으로 작성하고 제출해봤습니다. <br><img src="https://i.imgur.com/mTfnu0R.png" referrerpolicy="no-referrer"><br>자바는 오늘도 연전연패..]]></description><link>알고리즘과-자료구조/hash-함부로-쓰면-메모리-터진다.html</link><guid isPermaLink="false">알고리즘과 자료구조/Hash 함부로 쓰면 메모리 터진다.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 10 Jun 2024 12:07:28 GMT</pubDate><enclosure url="https://i.imgur.com/vhS6I39.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/vhS6I39.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[운영체제 정리]]></title><description><![CDATA[ 
 <br><br>
보조기억에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 프로세스가 됩니다. 
<br><br><br>
부모가 자식을 어떻게 만들고, 자식은 자신의 코드를 어떻게 실행하는가 
<br><br>
자신의 메모리 공간을 다른 프로그램으로 교체합니다. 
<br><br>
자신의 복사본을 자식 프로세스로 생성합니다. 
<br><br>
프로그래머가 직접 할당할 수 있는 저장공간<br>
할당했다면 언젠가는 반환해야한다.<br>
제대로 반환하지 않는다면 메모리 누수가 발생한다. 
<br><br><br>
데이터를 일시적으로 저장합니다.<br>
매개변수, 지역변수가 대표적입니다. 
<br><br><br><br>
실행할 수 있는 기계어(명령어)가 저장됩니다.<br>
읽기 전용 공간입니다. 
<br><br>
프로그램이 실행되는 동안 유지할 데이터가 저장됩니다.<br>
전역변수 
<br><br>
보조기억에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 프로세스가 됩니다. 
<br><img src="https://i.imgur.com/WY1kAsJ.png" referrerpolicy="no-referrer"><br><br><br><br><br><br>
프로세스 간의 자원을 공유하고 데이터를 주고 받는 방법 
<br><br><br><br><br><br>
<br>기본적으로 정해진 타임 슬라이스 만큼 사용 
<br>다음 프로세스는 남아있는 작업시간이 가장 적은 프로세스로 당첨 
<br><br><br><br>
우선순위가 낮은 프로세스가 실행될 수 없음
<br><br><br><br>
오랫동안 대기한 프로세스의 우선순위를 점차 증가시킴
<br><br>
우선 순위 별로 여러개의 큐를 둬서 관리합니다. 
<br>
<br>큐마다 타임슬라이스, 스케줄링 알고리즘을 다르게 적용가능
<br><br>
우선 순위 별로 여러개의 큐를 둬서 관리합니다. 
<br>
<br>CPU를 너무 오랫동안 사용할 경우 후순위 큐로 내립니다. 
<br>너무 오래 대기하면 상위 큐로 올립니다.(에이징)
<br><br>
프로세스에게 CPU 자원을 배분하기 
<br><br>
당장 CPU를 할당받아 실행할 수 있지만,<br>
차례가 아니라 기다리고 있는 상태 
<br><br>
CPU를 할당받아 실행중인 상태<br>
일정 시간동안(타이머 인터럽트 발생전) 사용
<br><br>
입출력 작업이 끝날때까지 기다리는 상태 
<br><br>
운영체제는 PCB와 프로세스가 사용한 메모리를 정리
<br><br>
막 메모리에 적재되어 PCB를 할당 받은 상태 
<br><br>
교착 상태 없이 안전하게 자원을 할당할 수 있는 순서 
<br><br>
교착이 해결될 때까지 한 프로세스씩 자원 몰아주기
<br><br>
교착이 해결될 때까지 한 프로세스씩 자원 몰아주기
<br><br>
모든 자원에 번호를 붙여 순서를 부여한다.<br>
번호를 어떻게 붙이느냐에 따라 자원 활용률이 달라진다. 
<br><br>
CPU와 같은 일부 자원에 대해서는 효율적이지만 프린터 같은 자원이 있기 때문에 범용성은 떨어진다.
<br><br>
한방에 해결할 수 있으나, 많은 프로세스가 작업 내역을 잃음
<br><br>
작업 내역을 잃는 프로세스는 최대한 줄일 수 있지만, 종료-&gt;확인 과정에서 오버헤드가 발생한다. 
<br><br>
안전 순서열 대로 프로세스에 자원을 분배하여 교착 상태가 발생하지 않음 
<br><br>
안전 순서열이 없는 상황 -&gt; 교착 상태가 발생할 확률이 높다.
<br><br><br><br>
4가지 발생조건중 하나를 깨뜨림
<br><br>
교착 상태가 발생하지 않도록 자원 양을 고려해  할당함
<br><br>
자원을 요구할 때마다 바로 할당하며,<br>
교착 상태 발생 여부를 주기적으로 검사함 
<br><br>
어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 상태
<br><br>
자원할당 그래프가 원의 형태로 그려지는 상태 
<br><br>
현실적으로 불가능함
<br><br>
특정 프로세스에 자원을 모두 할당하거나, 안하거나 

<br>자원 활용률이 낮아진다. 
<br>많은 자원을 활용하는 프로세스가 불리해진다.

<br><br>
한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때 발생합니다. 
<br><br>
자원을 할당 받은 상태에서 다른 자원을 기다리는 상태
<br><br>
<br><br>
프로세스 제어 블록은 프로세스와 관련된 정보를 저장하는 자료구조입니다.<br>
프로세스의 실행 순서를 관리하고 자원을 배분하기 위해서 사용합니다. 
<br><br>
특정 프로세스를 식별하기 위해 부여한 고유번호
<br><br>
프로세스마다 메모리에 저장된 위치가 달라 , 프로세스가 어느 주소에 저장되어 있는지에 대한 정보가 필요함<br>
베이스 레지스터, 한계 레지스터, 페이지 테이블 정보
<br><br><br>
작업을 이어나가기 위해, 자신의 실행 차례가 돌아오면<br>
이전까지 사용했던 레지스터 중간값을 복원해야함<br>
복원에 필요한 데이터를 저장하는 공간 
<br><br>
프로세스가 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보
<br><br><br><br>
프로세스를 구성하는 실행 흐름의 단위<br>
스레드를 이용해서 하나의 프로세스에서 여러 부분을 동시 실행함 
<br><br><br><br><br><img src="https://i.imgur.com/Ng6pp3M.png" referrerpolicy="no-referrer"><br><br><img src="https://i.imgur.com/ifUi3dF.png" referrerpolicy="no-referrer"><br><img src="https://i.imgur.com/HTiSwcY.png" referrerpolicy="no-referrer"><br><br>
다중 프로세스 환경에서 여러 프로세스가 동시에 실행될 때, 상호 간섭 없이 올바른 결과를 보장하기 위해 실행순서를 조정하는 기법 
<br><br>
공유 불가능한 자원의 동시 사용을 피하기 위해 사용 
<br><br><br>
동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 
<br><br>
여러 프로세스가 동시에 임계구역 코드를 실행해 문제 발생
<br><br>
파일, 입출력 장치, 보조 기억 장치 등 
<br><br>
하나의 프로세스가 임계구역에 진입했을 경우<br>
다른 프로세스는 진입 불가 
<br><br>
임계 구역이 비어있다면 진입하고자하는 프로세스는<br>
바로 들어갈 수 있어야한다. 
<br><br>
임계 구역에 진입하고 싶다면<br>
그 프로세스는 언젠가는 임계구역에 들어가야한다. 
<br><br>디스패치타이머 인터럽트입출력 끝입출력 시작fork:
자신의 복제본을 
자식 프로세스로exec:
ls를 실행하기 위한 
프로세스로 변환- 어느 한 프로세스의 자원 독점을 막을 수 있음
- 문맥 교환이 빈번하게 일어나 오버헤드 발생- 문맥교환 횟수가 적어 오버헤드가 적음 
- 당장 자원을 사용해야해도 기다려야함일반적인 특성 
때문에 발생타임슬라이스가 지나치게 클 경우타임슬라이스가 지나치게 작을 경우 선점형으로 구현될 경우+SJF여러개를 가질 수 있음]]></description><link>운영체제/운영체제-정리.html</link><guid isPermaLink="false">운영체제/운영체제 정리.canvas</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 03 Jun 2024 08:59:25 GMT</pubDate><enclosure url="https://i.imgur.com/WY1kAsJ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/WY1kAsJ.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[데이터 탐색하기]]></title><description><![CDATA[ 
 <br><br>SQL 쿼리문은 아래와 같은 문법으로 작성합니다. 우선 가장 기본적인 SELECT, FROM, WHERE만 사용하는 경우입니다. <br>
SELECT
col_2 as name
FROM Dataset.table 
WHERE 
col1 = 1
<br><br>어떤 테이블에서 데이터를 확인할지 출처를 정합니다.<br>
이름이 너무 길다면 AS 별칭으로 지정할 수 있습니다. <br><br>원하는 필터링 조건을 결정합니다. <br><br>테이블의 어떤 칼럼을 선택(출력)할 것인지 결정합니다.<br>
이름이 너무 길다면 AS 별칭으로 지정할 수 있습니다. <br><br><br>Group By를 사용하면 같은 값끼리 모아서 그룹화할 수 있습니다.<br>
<img src="https://i.imgur.com/gTD8Olz.png" referrerpolicy="no-referrer"><br>Group By는 집계 함수와 같이 쓰일 때 진가를 발휘합니다. 집계 함수와 같이 활용하면, 특정 칼럼을 기준으로 모으면서 다른 칼럼에선 집계할 수 있습니다.<br>
<img src="https://i.imgur.com/PVVv3Bf.png" referrerpolicy="no-referrer"><br><br>SELECT 
col_1,
집계함수(COUNT, MAX, MIN 등)
FROM Table
GROUP BY col_1

<br>반드시 집계할 칼럼을 SELECT에 명시 후 그 칼럼을 GROUP BY에 작성해야합니다. <br><br><br><br>중복을 제거합니다.<br>
보통은 이렇게 많이 작성합니다.<br>
특정 칼럼 내에서 고유한 값만 count하는 예제<br>count(distinct 칼럼)
<br>메인페이지 조회수 <br>count(user_id)
<br>메인 페이지 유저별 조회수 <br>count(distinct user_id)
<br><br><br>테이블에 바로 조건을 설정하고 싶은 경우 사용합니다. raw데이터인 table 자체 데이터 내에서 조건을 설정할 경우 사용합니다. <br><br>GROUP BY 후 집계가 완료된 칼럼에 대해 조건을 설정하고 싶은 경우 사용합니다. <br><br>SELECT 문 안에 존재하는 SELECT 쿼리입니다. FROM 절 안에도 넣을 수 있습니다. 괄호로 묶어서 표현합니다. <br>서브 쿼리를 작성하고 서브 쿼리 바깥에서 where 조건을 설정하는 것은 Having과 동일하게 동작합니다. <br><br>SELECT
*
FROM(
	SELECT 
		count(col) as col_count
	FROM table 
	GROUP BY col
)
where 
col_count
<br><br>칼럼을 지정해 해당 칼럼의 데이터에 맞게 정렬을 진행합니다. ORDER BY는 쿼리 중간에 작성할 필요가 없습니다. 맨 마지막에만 작성하면 됩니다. 중간에 있어봤자 연산만 느려집니다. <br>SELECT 
col
FROM 
ORDER BY &lt;칼럼&gt; &lt;순서&gt;
<br><br><br><br>패턴 매칭을 위해 LIKE 연산자와 와일드 카드 문자를 사용합니다. <br><br><br><br>일반적인 비교 연산자를 사용하여 다른 값과 비교를 수행할 수 없습니다.<br>
IS NULL 또는 IS NOT NULL 연산자를 사용해야합니다. <br>SELECT * FROM table_name WHERE column_name IS NULL;
<br><br>IFNULL 또는 COALESCE를 사용할 수 있습니다. <br>
<br>IFNULL(expr1, expr2)&nbsp;함수는 expr1이 NULL이 아니면 expr1을 반환하고, expr1이 NULL이면 expr2를 반환합니다.
<br>COALESCE(expr1, expr2, ...)&nbsp;함수는 여러 개의 표현식을 순차적으로 평가하고, 첫 번째로 NULL이 아닌 값을 반환합니다. 모든 표현식이 NULL인 경우 NULL을 반환합니다.
]]></description><link>db/big-query/데이터-탐색하기.html</link><guid isPermaLink="false">DB/Big Query/데이터 탐색하기.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 13 Jul 2024 15:25:56 GMT</pubDate><enclosure url="https://i.imgur.com/gTD8Olz.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/gTD8Olz.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Big Query  특징]]></title><description><![CDATA[ 
 <br><br><br>Online Transaction Processing의 약자로 거래를 하기 위해 사용되는 데이터베이스입니다. 데이터의 무결성을 보장해야하기 때문에 보류, 중간 등의 상태가 존재하지 않습니다. 또한 특성상 데이터의 추가, 변경이 많이 발생합니다. MySQL, Postgres, Aurora 등이 있습니다. <br>SQL을 사용할 수 있으나, 분석을 위해 만든 DB가 아니기 때문에 쿼리 속도가 느려질 수 있습니다. <br><br>Online Analytical Processing의 약자로 분석에 치중된 DB입니다. OLTP로 데이터 분석을 하기에는 속도와 기능 부족 등 여러 한계가 있었기 때문에 OLAP가 등장하게 됩니다. <br><br>구글 클라우드의 OLAP + 데이터 웨어하우스의 개념입니다. ]]></description><link>db/big-query/big-query-특징.html</link><guid isPermaLink="false">DB/Big Query/Big Query  특징.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 13 Jul 2024 13:45:59 GMT</pubDate></item><item><title><![CDATA[레디스 클러스터의 요청 흐름]]></title><description><![CDATA[ 
 <br>레플리카<br>마스터<br>READONLY 명령어 실행 +<br>
키가 노드의 슬롯 범위에 있음 <br>그외 <br>읽기 쿼리<br>쓰기 쿼리<br>접근 노드의 종류가 무엇인가?<br>요청 키가 노드의 슬롯범위 내인가?<br>
<br>요청된 캐시 노드에서 요청을 처리합니다. 
<br>
<br>레디스 서버가 MOVED 리다이렉트를 클라이언트에 응답합니다.
<br>클라이언트가 MOVED 리다이렉트를 받고 로컬 슬롯 매핑을 업데이트 합니다. 
<br>클라이언트가 해당 키의 슬롯을 가진 샤드의 마스터에 접근합니다.
<br>
<br>요청된 캐시 노드에서 요청을 처리합니다. 
NoYes]]></description><link>db/cache/레디스-클러스터의-요청-흐름.html</link><guid isPermaLink="false">DB/Cache/레디스 클러스터의 요청 흐름.canvas</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 13 Jun 2024 04:27:53 GMT</pubDate></item><item><title><![CDATA[Redist Cluster]]></title><description><![CDATA[ 
 <br><br><br>레디스 클러스터는 페일오버와 샤딩을 통해 높은 가용성을 보장하며,  쓰기 및 읽기 작업의 확장성을 높일 수 있습니다. <br>페일 오버<br>
레디스 클러스터는 여러 레디스 노드를 연결하여 일부 노드에서 장애가 발생해도 운영할 수 있습니다. <br>샤딩<br>
레디스 서버가 실행 중일 때 노드 사이에 키를 옮길 수 있습니다. <br><br><br><img src="https://i.imgur.com/2ELVfy9.png" referrerpolicy="no-referrer"><br>데이터를 저장할 해시 슬롯을 선택하기 위해서 키 값의 해시 결과를 사용합니다. 레디스 클러스터에는 16,384개의 해시 슬롯이 있습니다. 이 슬롯은 각 샤드에 할당됩니다. <br>저장되는 키는 CRC16 해시 함수를 사용하여 해시값을 계산합니다. 그 값을 16384로 나눈 나머지를 구한다음 해당 값의 슬롯을 가진 샤드가 요청을 처리합니다. <br>샤드의 데이터 분산은 키를 해싱한 결과를 슬롯에 할당하고, 슬롯을 다시 각 샤드에 할당하는 방식으로 진행합니다. 이 과정은 슬롯의 개수를 기준으로 하며, 데이터 크기를 고려하지 않습니다. 따라서 특정 샤드에 데이터가 집중되는 경우, 슬롯 할당에 편향이 생기거나 특정 슬롯에 속하는 데이터의 크기가 커질 수 있습니다. <br><br>{user:1000}:name
{user:1000}:email
<br>데이터를 저장할 때 해시 태그 기능을 사용해, 키가 달라도 같은 슬롯에 접근할 수 있습니다. 해시 태그를 사용하기 위해서는 키 내의 공통 문자열을 {}로 감싸야합니다. 단, 해시태그를 남용하면 특정 샤드에 편향이 발생할 수 있으므로 주의해서 사용해야합니다. <br>해시 태그 인식 조건 <br>1. 키에 {를 포함해야합니다. 
2. {의 오른쪽에 }를 포함해야합니다. 
3. {} 사이에 하나 이상의 문자가 포함되어야 합니다.
4. 대상이 여러개 있을 경우 가장 먼저 조건을 만족하는 것이 대상이 됩니다. 
	-&gt; {{foo}}}bar가 있으면 {foo가 해시 대상이 됩니다. 
<br><br>클러스터 버스<br>
레디스 클러스터 내 각 노드는 클러스터 버스라고 하는 TCP 버스를 통해 이진 프로토콜과 완전 메시 구조로 서로 연결되어 있습니다. <br><img src="https://i.imgur.com/t17VsDP.png" referrerpolicy="no-referrer"><br><br>클러스터 버스 포트<br>
레디스 클러스터 내에서 노드간 통신에 사용하는 포트입니다. 각 노드는 클러스터 버스를 통해 다른 모든 노드와 연결됩니다. 통신에는 이진 프로토콜이 사용되며, 노드는 완전 메시 구조로 구성됩니다.<br>주로 구성 정보, 상태 정보 교환이 이루어집니다. 페일 오버 인증, 설정 업데이트 증에 사용되는 하트비트 패킷 교환도 이뤄집니다. <br>노드가 클러스터의 일부로 인식되는 과정 <br>가십 프로토콜<br>
노드의 상태를 서로 파악하기 위해 사용하는 프로토콜입니다. 클러스터의 노드가 증가해도 노드 간 메시지 수가 지수적으로 증가하지 않도록 고안되었습니다. 내부적으로는 클러스터 내의 노드 간에 설정 정보를 서로 공유하고 인지하기 위해 Raft라는 분산 합의 알고리즘을 기반으로 시스템이 구현되어 있습니다. <br>완전 메시라고 모든 노드 쌍에 핑을 주고 받지 않습니다.<br>
완전 메시 방식으로 통신하지 않습니다. 그 이유는 노드 수가 늘어날 수록 보내야하는 핑의 양이 기하급수적으로 증가해 성능이나 대역폭에 영향을 미칩니다. <br>각 노드는 다른 노드를 무작위로 선택하여 핑을 보내고 응답을 받습니다. 이 과정에서 각 노드가 보내는 전체 핑 패킷의 총량은 일정하도록 유지합니다. 만약 cluster-node-timeout 설정 시간의 절반을 초과하는 동안 다음 조건 중 하나라도 만족하는 노드가 있을 경우 모든 노드에 핑을 보냅니다. <br>1. ping이 전송되지 않은 노드 
2. ping의 응답을 받지 못한 노드 
<br>슬롯 배치<br>
노드 사이의 슬롯 배치는 아래 두 종류의 메시지로 관리됩니다. 메시지를 통해 슬롯 구성이 업데이트 됩니다. <br><br><br>레플리케이션의 한계를 샤딩으로 극복<br>
마스터의 레플리카 수를 늘려 읽기 작업의 확장성을 늘릴 수 있지만, 쓰기 작업은 마스터에서만 수행되기 때문에 레플리케이션에서 확장성을 높이기 어려웠습니다. 이를 해결하기 위해 레디스 클러스터는 샤딩을 제공합니다. <br>각 샤드는 한 개의 마스터와 0개 이상의 레플리카로 구성됩니다. DB 내의 데이터 슬롯에 할당한 후 샤드들이 담당할 슬롯을 결정해 어느 샤드에 데이터를 저장할지 결정합니다. <br>데이터를 갖고 있지 않은 노드에 요청이 들어올 경우 오버헤드가 없습니다<br>
레디스 클러스터는 클라이언트에게 데이터를 가진 마스터 노드의 정보를 제공하고, 해당 노드로 요청을 리다이렉트합니다. 이후 클라이언트는 리다이렉트된 노드 정보를 저장하고 있기 때문에 리다이렉트에 의한 오버헤드가 없습니다. 또한 클러스터 내 각 노드로 요청을 분배하는 과정에서 프록시를 사용하지 않으므로, 프록시로 인한 오버헤드가 없습니다. <br><br><img src="https://i.imgur.com/5p8cB4A.png" referrerpolicy="no-referrer"><br>
<a data-tooltip-position="top" aria-label="레디스 클러스터의 요청 흐름.canvas" data-href="레디스 클러스터의 요청 흐름.canvas" href="db/cache/레디스-클러스터의-요청-흐름.html" class="internal-link" target="_self" rel="noopener nofollow">레디스 클러스터의 요청 흐름</a><br><br>마스터 노드에 편향이 발생하는 경우<br>
: READONLY 명령어를 사용하여 읽기쿼리를 전부 레플리카로 분산시키는지 여부 <br>마스터 노드 여부와 상관없이 발생하는 경우<br>
: DNS 리졸버에 의존하는 노드 IP 주소 선택 방식 검토<br>
: DNS 캐시<br>
: 슬롯 배치 편향 및 특정 슬롯에 저장되는 아이템 크기의 편향<br>
: 해시 태그 사용여부 <br><br>
레디스 클러스터는 문제가 발생한 마스터가 속한 샤드 내의 레플리카를 마스터로 승격시키도록 동작합니다. 이 동작의 수행 시점에 따라 매커니즘을 분류합니다. 
<br><br>캐시노드 상태<br>
레디스 클러스터의 캐시 노드 상태는 총 2가지 입니다. <br><br>가십 프로토콜<br>
레디스 클러스터는 가십 프로토콜을 사용해 주기적으로 핑을 보냅니다. 가십 부분에 다른 노드의 상태 정보를 담고 있는 내용을 포함합니다. 클러스터 내의 노드들은 신뢰할 수 있는 노드에서 다른 노드의 상태 정보를 공유하는 형태로 노드 간 상태를 파악합니다. <br><br>과반수 이상의 마스터가 뻗으면 소용없습니다.<br>
레디스 클러스터의 페일오버는 마스터 노드의 과반수가 정상 동작하는 것을 전제로 합니다. 때문에 클러스터 내 대부분의 노드가 사용 불가능한 상태라면 복구되지 않습니다. 단, 관리형 서비스(AWS 등)을 사용하는 경우에는 복구가 가능할 수도 있습니다. <br>데이터가 손실될 위험이 있습니다.<br>
case1.<br>
한 샤드가 마스터와 레플리카로 구성되어 있고, 장애가 발생한 동안 샤드 내에서 마스터가 두 개로 나뉜 상황을 가정합니다. 장애 복구 과정에서 각 마스터에 저장된 데이터를 병합할 때는 last failover wins 방식을 사용해 마스터를 포함하는 레플리카가 새로운 마스터로 승격됩니다. 이 때 승격되지 않은 다른 마스터의 기록은 손실 됩니다.<br>예를 들어, 원래 하나의 마스터(A)와 하나의 레플리카(B)가 있는 샤드가 있다고 가정해 봅시다. 네트워크 분할로 인해 A와 B가 서로를 볼 수 없게 됩니다. 네트워크가 복구되었을 때 B가 새로운 마스터로 선택되었다면 A에 있던 데이터는 그대로 남아있더라도 클러스터에서 무시됩니다.<br>즉, 장애가 발생하는 동안 A와 B가 독립적으로 업데이트 되었을 가능성이 있기 때문에 일관성을 유지하기 위해 승격된 마스터의 데이터만 보존합니다. <br>case 2.<br>
샤드 내 마스터와 레플리카 간의 레플리케이션은 비동기적으로 이루어집니다. 따라서 마스터에 데이터를 저장한 후 클라이언트에 응답을 반환하여 레플리카에 데이터가 기록되는 일련의 과정 중 마스터에 장애가 발생하면, 레플리카에 기록되지 않은 데이터는 손실될 수 있습니다. <br><br>마스터에 장애가 발생했을 때 레플리카는 자동적으로 새로운 마스터로 페일오버를 실행합니다. <br>선출 프로세스 시작 조건<br>
1 - 레플리카 마스터가 FAIL 상태여야합니다.<br>
2 - 마스터가 하나 이상인 슬롯을 관리합니다.<br>
3 - 레플리카가 일정 시간 이상 마스터와 연결이 끊긴 상태여야합니다. <br>선출 프로세스<br>
1 - 마스터가 FAIL 상태임을 감지한 레플리카는 일정시간 동안(DEALY) 대기합니다.<br>
2 - 클러스터 내 각 마스터에게 FAILOVER_AUTH-REQUEST를 브로드캐스팅합니다<br>
3 - 각 마스터는 해당 패킷을 받으면 FAILOVER_AUTH_ACK로 응답합니다. (=투표)<br>
4 - 레플리카는 currentEpoch보다 큰 에포크 응답을 반영합니다.<br>
5 - 과반수의 마스터로부터 투표를 받으면 해당 레플리카가 승격 대상이 되어 페일오버가 진행됩니다.<br>
5'- 과반수에 도달하지 못할 경우 cluster-node-timeoutx2의 시간 동안 대기한 후, cluster-node-time-outx4 시간 후 재투표를 진행합니다.<br>
6 - 마스터가 된 노드는 다른 마스터보다 더 크게 configEpoch를 증가시킵니다. <br>Epoch<br>
분산 시스템에서 중요한 변화가 일어날 때마다 증가하는 버전 번호입니다. <br>]]></description><link>db/cache/redis-cluster.html</link><guid isPermaLink="false">DB/Cache/Redis Cluster.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 13 Jun 2024 06:30:51 GMT</pubDate><enclosure url="https://i.imgur.com/2ELVfy9.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/2ELVfy9.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Redis Replication]]></title><description><![CDATA[ 
 <br><br><br><img src="https://i.imgur.com/IAmMhPR.png" referrerpolicy="no-referrer"><br>일반적으로 쓰기 작업이 있을 때마다 업데이트 된 데이터를 다른 레디스로 보내 복제합니다. 서버를 추가하하여 읽기 쿼리의 부하를 관리할 수 있으며 복제한 데이터로 페일오버를 실행할 수 있습니다. <br><br>비동기 처리를 통한 구현<br>
이벤트 루프의 비동기 논 블로킹 방식으로 구현되어 있습니다. 비동기 동작으로 인해 지연이 발생하는 경우 마스터와 레플리카 내의 데이터 차이가 발생할 수 있습니다. <br>기본적으로 읽기 전용<br>
기본적으로 레플리카에는 쓰기 작업이 불가능합니다. replica-only 지시자를 통해 변경할 수 있습니다. 레플리카에 쓰기 작업이 가능한 상태에서는 데이터의 일관성이 깨질 위험이 있으므로, 특별한 이유가 있을 경우에만 쓰기 작업을 사용해야합니다. <br>실행 시간이 많이 소요되는 작업일 경우에만 레플리카에 쓰기 작업을 활성화해 임시 데이터를 저장하고 여러번 참조하는 방식으로 레플리카에서 쓰기 방식을 사용할 수 있습니다. <br>마이그레이션으로 활용하기<br>
새로운 레디스 서버로 마이그레이션할 때, 서비스 중단 시간을 최소화하기 위해 레플리케이션 기능을 활용할 수 있습니다. 기존 레디스 서버에서 마이그레이션할 레디스 서버로 레플리케이션을 생성한 후 마이그레이션한 서버를 독립시키는 방식으로 수행합니다. <br><br><br><img src="https://i.imgur.com/euFLomG.png" referrerpolicy="no-referrer"><br><a data-tooltip-position="top" aria-label="Replication 구성 단계.canvas" data-href="Replication 구성 단계.canvas" href="db/cache/replication-구성-단계.html" class="internal-link" target="_self" rel="noopener nofollow">Replication 구성 단계</a><br><br>요청 처리에 미치는 영향이 크지만 모든 상황에서 실행 가능합니다. 프로세스가 포크 처리되어 마스터의 메모리 데이터를 덤프하고 디스크에 RDB를 저장합니다. 또한 덤프한 모든 데이터를 마스터에서 레플리카로 옮기기 때문에 네트워크 I/O도 발생합니다. <br>전체 동기화와 데이터 일관성<br>
마스터가 RDB파일을 전송할 때, 레플리카에 RDB 파일이 있다면 일관성을 위해 레플리카에 있는 파일은 삭제합니다.<br>replica-serve-stale-data<br>
레플리케이션을 시작한 후 RDB 파일을 수신하는 동안, 레플리카는 클라이언트로부터 요청 받을 수 있습니다. 이 때 동기화 이전의 데이터가 반환될 수 있습니다. replcia-serve-stale-data의 값을 no로 변경하여 요청에 응답하는 대신 SYNC with master in progress라는 오류 메시지에 답하게 할 수 있습니다. <br><br>요청 처리에 미치는 영향이 작지만, 조건부로 실행 가능합니다. ]]></description><link>db/cache/redis-replication.html</link><guid isPermaLink="false">DB/Cache/Redis Replication.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 13 Jun 2024 06:26:01 GMT</pubDate><enclosure url="https://i.imgur.com/IAmMhPR.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/IAmMhPR.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Replication 구성 단계]]></title><description><![CDATA[ 
 <br>마스터<br>레플리카<br>4.요청받은 오프셋이 레플리케이션 백로그에 있는가?<br>5.전체 동기화 실행 <br>레플레케이션 중단 중 마스터가 받은 쓰기 요청의 크기가 버퍼 크기를 초과하는 경우 <br>5.부분 동기화 실행 1. 마스터 연결요청 
해당 시점까지 처리한 
레플리케이션 ID와 오프셋 전송2. 요청받은 레플리케이션 Id와 
소유중인 ID가 일치하는지 확인한다.
 
3. 오프셋이 레플리케이션 
백로그에 있는지 확인NoYesYesNo]]></description><link>db/cache/replication-구성-단계.html</link><guid isPermaLink="false">DB/Cache/Replication 구성 단계.canvas</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 13 Jun 2024 06:18:12 GMT</pubDate></item><item><title><![CDATA[B-Tree 인덱스에서 데이터를 읽는 방법]]></title><description><![CDATA[ 
 <br><br><br><br>B-Tree는 최상위의 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있습니다. 트리 구조 가장 하위에 있는 노드를 리프 노드, 중간에 있는 노드를 브랜치 노드라합니다.<br>
<img src="https://i.imgur.com/0NUG6Dq.png" referrerpolicy="no-referrer"><br>DB에서 인덱스와 실제 데이터는 따로 관리됩니다. 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야합니다. 때문에 인덱스의 리프노드는 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있습니다. <br><br>
인덱스의 접근방법 가운데 가장 대표적이고 빠른 접근 방법입니다. 
<br>검색해야할 인덱스의 범위가 결정되었을 때 사용합니다. <br>다음 쿼리로 예를 들어보겠습니다. <br>SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
<br><img src="https://i.imgur.com/QWTZI3g.png" referrerpolicy="no-referrer"><br>검색하려는 값의 수나 검색 결과 레코드 수의 상관 없이 레인지 스캔이라고 표현합니다. 그림에서 알 수 있듯이, 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 리프노드까지 들어가야만 레코드의 시작 지점을 찾을 수 있습니다. 일단 시작 위치만 찾아놓으면 리프 노드의 레코드만 순서대로 읽으면 됩니다. 스캔하다가 리프 노드 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아 다시 스캔합니다. 이후 스캔을 멈춰야할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환합니다. <br>실제 데이터 파일의 레코드를 읽어와야하는 경우<br>
<img src="https://i.imgur.com/HYnSD6u.png" referrerpolicy="no-referrer"><br>리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어옵니다. 이 때 건당 랜덤 I/O가 일어납니다. 그림에서 처럼 3건의 레코드가 검색 조건에 일치했다고 가정하면, 데이터 레코드를 읽기 위해 랜덤 I/O가 최대 3번 필요합니다. 그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 듭니다. 때문에 인덱스를 통해서 선택되는 레코드가 전체의 20~25%를 넘으면 인덱스를 통해서 읽는 것 보다는 테이블의 데이터를 직접 읽는 것이 낫습니다. <br>커버링 인덱스<br>
위와 같이 레코드의 랜덤 I/O를 방지하려면 주요 사용 데이터 자체를 인덱스화할 수 있습니다. 때문에 리프노드에서 가지고 있는 정보만으로 쿼리의 결과를 반환할 수 있습니다. <br>인덱스 레인지 스캔 정리<br>
1: 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. (이 과정을 인덱스 탐색이라고 한다. )<br>
2: 1번에서 찾은 시작위치부터 필요한 만큼 인덱스를 차례로 읽는다. (이 과정을 인덱스 스캔이라고 한다.)<br>
3: 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 랜덤 액세스하고 최종 레코드를 읽어온다. <br>과정마다 실행횟수 보기 <br>SHOW STATUS LIKE 'Handler_%';
<br>]]></description><link>db/rdb/b-tree-인덱스에서-데이터를-읽는-방법.html</link><guid isPermaLink="false">DB/RDB/B-Tree 인덱스에서 데이터를 읽는 방법.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 15 Jun 2024 08:19:48 GMT</pubDate><enclosure url="https://i.imgur.com/0NUG6Dq.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/0NUG6Dq.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Index 잘쓰는 방법]]></title><description><![CDATA[ 
 <br><br><br><br>인덱스를 지정하는 기준 : 카디널리티와 선택률<br>
인덱스는 테이블의 특정 필드를 지정합니다. 이 때 어떤 필드를 지정할 것인지의 기준은 필드의 카디널리티와 선택률입니다. <br>카디널리티란<br>
카디널리티란 값의 균형을 나타내는 개념입니다. 고유성이라고 생각하면 편합니다. 카디 널리티가 가장 높은 필드는 PK 필드입니다. 반대로 모든 레코드에 같은 값이 들어가 있다면 카디널리티가 낮은 필드입니다. <br>선택률이란<br>
선택률은 특정 필드값을 지정했을 때 테이블 전체 레코드 중 선택되는 레코드의 비율입니다. 예를 들어서 100개의 레코드를 가진 테이블에서 pk=1을 조건으로 지정한다면 단 한 개의 레코드가 선택됩니다. 때문에 선택률은 1/100=0.01, 1%입니다.<br><br>인덱스를 작성하는 필드 집합의 조건은 두 가지 지표로 판단합니다. <br>첫째, 카디널리티가 높을 것<br>
값이 평균치에서 많이 흩어져 있고, 고유값이 많을 수록 좋은 인덱스 후보입니다. <br>둘째, 선택률이 낮을 것<br>
한 번의 선택으로 레코드가 가능한한 적게 선택되는 것이 좋습니다. 최근 DMBS환경에서는 5~10%이하가 좋은 선택기준입니다. 5% 미만이라면 해당 필드 집합은 인덱스를 도입할 가치가 있습니다. 선택률이 10%보다 높다면 테이블 풀 스캔이 더 빠를 수도 있습니다. <a data-footref="note1" href="about:blank#fn-1-2fb2234bf805a1df" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>왜 선택률에 따라 테이블 풀 스캔이 빨라질 수 있을까?<br>
정확하게는 선택되는 데이터의 개수에 따라 달라집니다. 먼저 풀 테이블 스캔과 인덱스 스캔의 작동 원리부터 알아보겠습니다. <br>인덱스 스캔은 각 레코드를 찾기 위해 인덱스 페이지를 읽고 그 다음 테이블 페이지를 읽습니다. 하지만 테이블 풀 스캔의 경우 디스크 I/O 작업이 순차적으로 이루어지기 때문에 많은 양의 데이터를 읽을 때, 더 효율적일 수 있습니다. 또한 한번에 큰 블록을 읽기 때문에 여러번 인덱스 테이블을 참조하는 것보다 빠를 수 있습니다. <br>즉, 찾아야하는 데이터의 수가 많아질수록 인덱스를 사용해 각각의 레코드를 찾는 것 보다 대다수의 레코드를 한번에 읽는 것이 빠를 수 있습니다.<br><br>셋째, 클러스터링 팩터가 낮을 것<br>
클러스터링 팩터는 인덱스된 컬럼의 순서가 테이블의 물리적 데이터 저장 순서와 얼마나 일치하는지를 나타내는 값입니다. 클러스터링 팩터가 높을수록 데이터가 물리적으로 분산되어 있고, 낮을수록 물리적으로 뭉쳐있습니다. <br>클러스터링 팩터는 다음과 같이 계산합니다. <br>1. 인덱스 엔트리를 순차적으로 스캔합니다.
2. 각 인덱스 엔트리가 가리키는 테이블의 데이터 블록을 확인합니다.
3. 인덱스 엔트리가 순차적으로 가리키는 데이터 블록이 이전 엔트리의 데이터 블록과 다를 때마다,
   클러스터링 팩터 값을 증가시킵니다.
<br>즉, 클러스터링 팩터가 낮을수록 인덱스된 컬럼의 순서가 테이블의 물리적 저장 순서와 거의 일치합니다. 이는 인덱스를 사용할 때 디스크 I/O가 최소화되어 성능이 최적화됩니다.<br>클러스터링 팩터는 다음과 같이 확인합니다. <br><br>클러스터링 팩터를 최적화하는 방법<br>
<br>테이블 재구성: 테이블을 클러스터드 인덱스를 사용하여 재구성하면 클러스터링 팩터를 낮출 수 있습니다. 이는 테이블 데이터를 인덱스 키 순서대로 재배열합니다.
<br>인덱스 재구성: 인덱스를 주기적으로 재구성하여 인덱스와 테이블 데이터 간의 순서를 맞출 수 있습니다.
<br>적절한 인덱스 선택: 테이블의 액세스 패턴을 분석하여 적절한 인덱스를 선택하면 클러스터링 팩터를 최적화할 수 있습니다.
<br><br>인덱스 설계는 테이블 정의와 SQL만 봐서 할 수 있는 작업이 아닙니다. 특정 SQL에 적절한 인덱스를 생성하려면 검색 조건과 결합 조건을 바탕으로 데이터를 효율적으로 압축할 수 있는 조건을 찾아야합니다. 이를 위해서는 SQL 구문과 검색 키 필드의 카디널리티를 알아야합니다. <br>하지만 압축 조건을 찾지 못한다면 어떻게 해야할까요? <br><br>인덱스가 제대로 작동하려면 레코드를 크게 압축할 수 있는 검색조건이 필수입니다. 필드가 상태를 표시할 경우 카디널리티가 작아 인덱스로 만들기 적합하지 않을 수 있습니다.<br>SELECT order_id, recieve_date FROM Orders WHERE process_flg='5'; 
<br>현재 테이블에서 process_flg의 분포는 다음과 같다고 가정합니다. <br><br>5로 선택하여 검색할 경우 선택률이 83%로 굉장히 높은 수치입니다. 이 상태에서 process_flg 필드에 인덱스를 생성하면 당연히 인덱스를 생성하는데 시간이 매우 오래걸립니다. 또한, 인덱스를 생성하여 사용한다 치더라도 풀 스캔을 할 때보다 느려질 가능성이 큽니다. <br><br>SELECT order_id
FROM Orders 
WHERE receive_date 
BETWEEN :start_date AND :end_date 

<br>검색 범위를 하루로 설정할지, 1년으로 설정할지에 따라 선택률이 매우 크게 달라집니다. 1년 내내 주문량이 균등할 경우 1일로 지정할 때의 365배의 레코드가 선택될 확률이 매우큽니다. 다른 쿼리도 하나 더 보겠습니다. <br>SELECT count(*)
FROM Orders
WHERE shop_id=:sid; 
<br>이 쿼리는 점포의 주문량에 따라 선택률이 급하게 변합니다. 소규모 점포에서 10만건이 선택되고 대규모 점포에서는 1000만건이 선택된다고 가정하겠습니다. 소규모 점포에서의 선택률은 0.01%, 대규모 점포에서의 선택률은 무려 10%입니다. <br>힌트를 사용해볼까?<br>
SELECT /*+ INDEX(Orders shop_id_index) */ count(*)
FROM Orders
WHERE shop_id = :sid;

SELECT /*+ FULL(Orders) */ count(*)
FROM Orders
WHERE shop_id = :sid;


<br>전자에 대해서는 인덱스를 사용하는 것이, 후자에 대해서는 인덱스를 사용하지 않는 것이 좋지만 이처럼 선택률에 따라 실행계획을 다르게 하는 것은 힘듭니다. 힌트를 사용해서 소규모 점포 쿼리에는 인덱스를 사용하게끔, 대규모 점포 쿼리에는 테이블 풀 스캔을 하도록 힌트를 줄 수 있지만 한계가 명확한 방법입니다. <br>또한 결합에 있어서도 Nested Loops 내부 테이블 결합 필드에 조건으로 히트되는 레코드가 많으면 반복되는 횟수가 늘어나므로 성능 문제가 발생합니다. <br><br>압축할 검색 조건이 있지만 인덱스를 쓰지 못하는 쿼리를 작성하는 케이스가 있습니다. <br><br>
SELECT order_id
FROM Orders
WHERE shop_name LIKE '%대공원%'
<br>중간일치 또는 후방 일치에는 인덱스를 사용할 수 없습니다. 설령 검색 조건의 선택률이 좋다고 하더라도 풀 테이블 스캔을 사용할 수 밖에 없습니다. <br><br>인덱스로 지정된 필드로 연산하는 경우에는 인덱스를 사용할 수 없습니다. 인덱스 테이블에 존재하는 값은 index_col1이지 index_col1 '*' 1.1 이 아니기 때문입니다.<br>
SELECT `*`
FROM Practice
WHERE index_col1 `*` 1.1 &gt;100; 
<br>하지만 다음과 같은 방식으로 인덱스 자체의 연산을 회피하는 방식으로 인덱스를 사용하게끔 개선할 수 있습니다. <br>WHERE col_1&gt; 100/1.1 
<br>당연히 인덱스가 지정된 필드에 함수 또는 부정형를 사용하는 경우도 인덱스를 사용할 수 없습니다. 함수 색인하는 방법도 있지만, 쓸데 없는 연산 비용이 발생하기 때문에 기본적으로 사용하지 않는 편이 좋습니다. <br>SELECT `*`
FROM Practice
WHERE LENGTH(index_col1) = 10; 
<br>SELECT `*`
FROM Practice
WHERE index_col1 &lt;&gt; 10; 
<br>
<br>
<br>Richard J, Niemiec, Oracle Database 11g Release 2 Performance Tuning Tips &amp; Techniques, Mcgraw-Hill Osborne Media, 2012<a href="about:blank#fnref-1-2fb2234bf805a1df" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>db/rdb/index-잘-쓰는-방법.html</link><guid isPermaLink="false">DB/RDB/Index 잘 쓰는 방법.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 10 Jun 2024 17:27:08 GMT</pubDate></item><item><title><![CDATA[Index &amp; B-Tree]]></title><description><![CDATA[ 
 <br><br>
RDB 인덱스의 자료구조는 다음과 같이 세 가지로 분류할 수 있습니다. 

<br>B-tree 인덱스 
<br>비트맵 인덱스 
<br>해시 인덱스 

<br><br>DB에서 인덱스라고 말하면 대부분 B-Tree 인덱스를 지칭하는 것입니다. 실제로 CREATE INDEX 구문을 실행하면 기본값으로 B-Tree 인덱스가 생성됩니다. <br>검색 알고리즘으로서는 성능이 뛰어나게 좋진 않다.<br>
B-Tree를 고안했던 사람 중 한 명인 R.Bayer도 만약 데이터가 변화하지 않는다면 다른 인덱스 기술로도 B-Tree와 비슷한 성능을 낼 수 있을 것이다. 라고 말한 적 있습니다. <br>B-Tree의 수정버전<br>
대부분의 DB에서는 트리의 리프 노드에만 키값을 저장하는 B+Tree라는 수정버전을 사용합니다. (Oracle, PostgreSQL, MySQL) B-Tree보다 검색에 있어서 효율적으로 만든 알고리즘입니다.<br>B+Tree가 검색성능이 뛰어난 이유는 몇가지 있습니다. 첫째, B+Tree는 루트와 리프의 거리를 가능한한 일정하게 유지하려합니다. 또한 트리의 깊이도 대개 3~4 정도의수준으로 일정합니다. 데이터 또한 정렬상태를 유지하기 때문에 이분탐색을 적용할 수 있습니다. <br><br>비트 인덱스는 데이터를 비트 플래그로 변환하여 저장하는 형태의 인덱스입니다. 카디널리티가 낮은 필드에 대해 효과를 발휘합니다. 하지만 갱신 시의 오버헤드가 크기 때문에 빈번한 갱신이 일어나지 않는 BI/DWH 용도로 사용합니다. <br>BI/DWH<br>
DWH(Data Warehouse)는 데이터를 수집, 정제, 저장하는 역할을 하며, BI(Business Intelligence)는 DWH에 저장된 데이터를 분석하고 시각화하여 비즈니스 인사이트를 제공합니다.<br><br>키를 분산하여 등가 검색을 고속으로 실행하고자 만들어진 인덱스입니다. 등가 검색외 이점이 별로 없고, 범위 검색이 불가능합니다. 지원하는 DBMS로는 PostgreSQL과 Oracle의 Reverse Index 기능이 있습니다. 효과가 거의 없고 지원하는 DBMS마저 적어서 거의 사용할 일이 없습니다. ]]></description><link>db/rdb/index의-종류.html</link><guid isPermaLink="false">DB/RDB/Index의 종류.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 10 Jun 2024 16:27:58 GMT</pubDate></item><item><title><![CDATA[Select 튜닝]]></title><description><![CDATA[ 
 <br><br><br>Insert나 Update 작업은 대부분의 경우 레코드 단위로 발생하기 때문에 성능상 문제가 되는 경우는 별로 없습니다. 하지만 Select는 주어진 조건에 따라 여러개의 테이블에서 데이터를 조합해서 가져와야합니다. 즉, 여러개의 테이블을 어떻게 읽을 것인가에 대한 주의가 필요합니다. <br><br>기본순서<br>
<img src="https://i.imgur.com/d6oJaQm.png" referrerpolicy="no-referrer"><br><img src="https://i.imgur.com/DUqMraP.png" referrerpolicy="no-referrer"><br>각 쿼리절의 실행순서를 도식화한 그림입니다. CTE(with 절)와 윈도우 함수를 제외하고, 순서가 바뀌어서 실행되는 형태의 쿼리는 거의 없습니다. 또한 ORDER BY나 GROUP BY가 있어도 인덱스를 이용해 처리할 때는 생략되어 실행됩니다. <br>예제 쿼리로 확인해보겠습니다. <br>SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt 
FROM salaries s 
INNER JOIN employees e ON e.emp_no=s.emp_no
WHERE s.emp_no IN (100001, 100002)
GROUP BY s.emp_no 
HAVING AVG(s.salary) &gt; 1000
ORDER BY AVG(s.salary)
LIMIT 10; 

<br>예제 쿼리를 각 절로 나눠봅시다. <br><br>각 절의 실행 계획을 풀어서 보면 다음과 같습니다. <br><br>조인보다 먼저 ORDER BY가 실행되는 경우<br>
<img src="https://i.imgur.com/ZdWQaTg.png" referrerpolicy="no-referrer"><br>예외적으로 ORDER BY가 조인보다 먼저 실행되는 경우입니다. 첫번째 테이블만 읽어서 정렬을 수행한 뒤, 나머지 테이블을 읽습니다. 주로 GROUP BY 절 없이 ORDER BY만 사용된 쿼리에서 사용되는 순서입니다. <br>순서를 다르게 실행하고 싶다면? 인라인 뷰!<br>SELECT emp_no, cnt
FROM (
    SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt, MAX(s.salary) AS max_salary
    FROM salaries s
    INNER JOIN employees e ON e.emp_no = s.emp_no
    WHERE s.emp_no IN (100001, 100002)
    GROUP BY s.emp_no
    HAVING MAX(s.salary) &gt; 1000
    LIMIT 10
) temp_view
ORDER BY max_salary;
<br>위의 실행순서를 벗어나는 쿼리가 필요할 경우 서브 쿼리로 작성된 인라인 뷰를 사용해야합니다. 예시로 LIMIT를 먼저 적용하고 ORDER BY를 실행하고 싶다면 위와 같이 인라인 뷰를 적용해야합니다. <br>하지만 인라인뷰를 사용하면 임시 테이블을 쓰기 때문에 주의해야합니다. <br>CTE가 포함될 경우<br>
WITH 절(CTE, Common Table Expression)은 항상 제일 먼저 실행되어 임시 테이블로 저장됩니다.<br><br><br>
WHERE, GROUP BY, ORDER BY 절에서 어떤 요건을 갖췄을 때 인덱스를 사용할 수 있는지 자세히 알아보겠습니다. 
<br><br><br>인덱스 칼럼의 값을 변형하지 말아야합니다.<br>
인덱스는 칼럼의 값을 아무런 변환 없이 B-Tree에 정렬해서 저장합니다. WHERE, GROUP BY, ORDER BY 모두 원본값을 검색하거나 정렬할 때만 B-Tree에 저장된 인덱스를 이용합니다. 다음 예제와 같이 인덱스로 지정된 칼럼의 값을 변형한 후 다른 값과 비교하면 쿼리는 인덱스를 사용할 수 없습니다. <br>SELECT * FROM salaries WHERE salary*10 &gt; 10000; 
<br>때문에 다음과 같이 변형하여 사용해야합니다. <br>SELECT * FROM salaries WHERE salary &gt; 10000/10; 
<br>복잡한 연산을 수행한다거나, 해시 값을 만들어서 비교해야하는 경우<br>
2가지 해결방법이 존재합니다.<br>
1: 미리 계산된 값을 저장하도록 MYSQL의 가상 칼럼을 추가하고 그 칼럼에 인덱스를 생성하는 방법<br>
2: 함수 기반의 인덱스 사용하기 <br>비교 대상값은 같은 타입이어야합니다.<br>CREATE TABLE tb_test (age VARCHAR(10), INDEX ix_age (age)); 
INSERT INTO tb_test VALUES ('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7'); 

SELECT * FROM tb_test WHERE age=2;
<br>select 쿼리의 실행계획을 확인해봅시다. <br><br>age라는 칼럼에 인덱스가 있어서 type칼럼에 ref나 range가 표시되어야하지만, 실제로는 Index(인덱스 풀 스캔)라고 표시합니다.<br>인덱스 레인지 스캔을 사용하지 못하고 인덱스를 풀 스캔한 이유는 age칼럼의 데이터 타입과  비교되는 값의 데이터 타입이 다르기 때문입니다. 비교되는 값의 타입이 서로 다를 경우 옵티마이저가 내부적으로 문자열을 숫자 타입으로 변환한 후 비교 작업을 처리합니다. <br>실제 인덱스에 저장된 값은 문자열이고 이를 정수로 변환하는 과정에서 인덱스를 사용하지 못하게 됩니다. 이 현상을 예방하기 위해서는 쿼리를 다음과 같이 변경하여 해결할 수 있습니다. <br>SELECT * FROM tb_test WHERE age='2';
<br>저장하고자 하는 값의 타입에 맞춰 칼럼의 타입을 선정해야합니다. <br><br>
크게 작업 범위 결정 조건과 체크 조건의 두 가지 방식으로 구분합니다. 
<br><br>작업 범위 결정 조건은 WHERE 절에서 동등 비교 조건이나 IN으로 안의 조건에 사용된 칼럼들이 실제 인덱스 칼럼 구성과 비교할 때 얼마나 일치하는지에 따라 달라집니다.<br>
<img src="https://i.imgur.com/OMWDUxX.png" referrerpolicy="no-referrer"><br>
위 그림과 같이 WHERE 절에 나열된 순서가 인덱스와 다르더라도 옵티마이저는 인덱스를 사용할 수 있는 조건들을 뽑아서 최적화를 수행할 수 있습니다. 점선 표기가 체크 조건, 실선 표기가 작업 범위 결정 조건입니다.<br>
col_1과 col_2는 동등 비교 조건이며, col_3의 조건이 범위 비교 조건이기 때문에 col_4는 작업 범위 결정 조건으로 사용되지 못하고, 체크 조건으로 사용됩니다. <br>인덱스 순서상, col_4이 직전 칼럼인 col_3가 동등 비교 조건이 아니라, 범위 비교 조건으로 사용되기 때문입니다. ]]></description><link>db/rdb/select-튜닝.html</link><guid isPermaLink="false">DB/RDB/Select 튜닝.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 15 Jun 2024 06:39:01 GMT</pubDate><enclosure url="https://i.imgur.com/d6oJaQm.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/d6oJaQm.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[0. Java 정리]]></title><description><![CDATA[ 
 <br><a data-href="Java의 불변성" href="java/java의-불변성.html" class="internal-link" target="_self" rel="noopener nofollow">Java의 불변성</a><br><br><br><br><br><br>다음 세가지 방법을 이용해 어느 정도의 불변성을 제공하고 있습니다.<br>
<br>변경 불가능한 컬렉션 
<br>불변 컬렉션 팩토리 메서드 (9+)
<br>불변 복제 (10+)
<br>
<br>new 키워드를 사용하여 인스턴스화 하는 것이 아닌 정적 편의 메서드를 갖습니다. 
<br>얕은 불면성만을 가지고 있어, 요소의 추가, 삭제가 불가능하고 요소 자체의 불변성을 보장하지 않습니다. 

<br>얕은 불변성을 가진 자료구조는 최상위 계층에서만 불변성을 유지합니다. 
<br>요소에 대한 참조를 보유한 모든 호출자는 다른 곳에서도 요소를 변경할 수 있습니다.


<br><br>
변경 불가능한 뷰는 주로 반환값으로 사용될 컬렉션에 대해 원치않는 변경을 막기위해 사용합니다.<br>
<img src="https://i.imgur.com/iF7NnD4.png" referrerpolicy="no-referrer">
<br><img src="https://i.imgur.com/a2GBHLG.png" referrerpolicy="no-referrer"><br>
<br>원본 인스턴스와 반환된 인스턴스의 차이점은 반환된 인스턴스를 수정할 때 UnsupportedOperationException이 발생합니다. 
<br>뷰를 통해서 접근하는 것이 아닌 기존 컬렉션에 직접 접근할 경우 수정이 가능해집니다. 
<br><br>
기존 컬렉션을 기반으로 하지 않으나, 원하는 요소들을 정적 편의 메서드를 이용해서 전달해야합니다. 
<br><img alt="Pasted image 20240603133256.png" src="lib/media/pasted-image-20240603133256.png"><br>
<br>0개 이상의 요소를 받아들일 수 있으며 제공된 요소 개수에 따라 최적의 내부 컬렉션 타입을 사용합니다 
<br><br>
다음 세가지 유형의 static 메서드 copyOf를 호출하여 깊은 수준의 불변성을 제공합니다. 
<br><img src="https://i.imgur.com/pzkh19r.png" referrerpolicy="no-referrer"><br>
Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)
List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)
SMap&lt;K,V&gt; copyOf(Collection&lt;? extends K, ? extends V&gt; coll)

<br>
<br>단순히 뷰를 제공하는 것뿐만 아니라 copyOf 메서드는 새로운 컨테이너를 생성해 요소들의 참조를 독립적으로 유지합니다. 
<br>복사된 컬렉션은 원본 리스트에 요소를 추가하거나 제거하는 것을 방지합니다. 
<br>실제 요소 자체는 공유되며 변경 가능합니다. 
Java의 불변성<br><br><br><br><br><br><br><img src="https://i.imgur.com/D2Qy18x.png" referrerpolicy="no-referrer"><br><img src="https://i.imgur.com/ZMaR9hl.png" referrerpolicy="no-referrer"><br>
List&lt;String&gt; immutableList = List.of("a", "b", "c");

Set&lt;String&gt; immutableSet = Set.of("a", "b", "c");

Map&lt;String, Integer&gt; immutableMap = Map.of("a", 1, "b", 2, "c", 3);

<br><img src="https://i.imgur.com/FPdIuPq.png" referrerpolicy="no-referrer"><br>
Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)
List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)
Map&lt;K,V&gt; copyOf(Collection&lt;? extends K, ? extends V&gt; coll)

<br><br><br><br><br><br><a data-href="Record" href="java/record.html" class="internal-link" target="_self" rel="noopener nofollow">Record</a><br><br><br><a data-href="Enum" href="java/enum.html" class="internal-link" target="_self" rel="noopener nofollow">Enum</a><br><br><br><br><br><br><br><br><br>]]></description><link>java/0.-java-정리.html</link><guid isPermaLink="false">Java/0. Java 정리.canvas</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 03 Jun 2024 04:54:14 GMT</pubDate><enclosure url="https://i.imgur.com/iF7NnD4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/iF7NnD4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[객체 헤더]]></title><description><![CDATA[ 
 <br>Java에서 객체 헤더(object header)는 각 객체의 메타데이터를 저장하는 부분으로, JVM이 객체를 관리하는 데 필요한 정보를 포함합니다. 객체 헤더는 JVM 구현마다 다를 수 있지만, 일반적으로 다음과 같은 정보를 포함합니다:<br>
<br>
Mark Word:

<br>Locking Information: 객체의 락 상태를 저장합니다. 이는 객체가 동기화 블록에 의해 잠겨 있는지 여부를 나타냅니다.
<br>Hash Code: 객체의 해시 코드가 캐시될 수 있습니다.
<br>Garbage Collection Information: GC 상태를 나타낼 수 있습니다.
<br>Age: 객체의 "나이"를 추적하여 GC가 오래된 객체를 더 자주 수집할 수 있도록 합니다.


<br>
Klass Pointer:

<br>Class Metadata: 객체가 어떤 클래스의 인스턴스인지를 가리키는 포인터입니다. 이는 객체가 속한 클래스의 메타데이터를 참조합니다.


<br><br>Java 64비트 HotSpot VM의 경우, 객체 헤더는 일반적으로 다음과 같이 구성됩니다:<br>
<br>Mark Word: 64비트
<br>Klass Pointer: 64비트 (압축된 포인터 사용 시 32비트)
<br>이러한 헤더는 JVM에서 객체를 관리하고 동기화, GC 등을 수행하는 데 필수적입니다.<br><br>다음은 객체 헤더의 역할을 간략히 보여주는 예제입니다:<br>
public class Main {
    public static void main(String[] args) {
        Object obj = new Object();

        // System.identityHashCode는 객체의 헤더에 저장된 해시 코드를 반환
        int hashCode = System.identityHashCode(obj);
        System.out.println("HashCode: " + hashCode);

        // 기본 동기화 블록, 객체의 모니터 락을 획득
        synchronized (obj) {
            System.out.println("Object is locked");
        }
    }
}


<br>이 예제에서:<br>
<br>System.identityHashCode(obj)는 객체의 해시 코드를 반환하는데, 이는 객체 헤더의 일부인 Mark Word에 저장될 수 있습니다.
<br>synchronized (obj)는 객체의 모니터 락을 획득하여, 객체 헤더에 있는 락 정보를 사용합니다.
<br><br>객체 헤더는 Java 객체의 중요한 부분으로, JVM이 객체를 효율적으로 관리하고 동기화, 해시 코드 계산, GC 등의 작업을 수행할 수 있도록 돕습니다. 이를 통해 JVM은 객체 지향 프로그램의 효율성을 극대화할 수 있습니다]]></description><link>java/객체-헤더.html</link><guid isPermaLink="false">Java/객체 헤더.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 10 Jun 2024 10:41:41 GMT</pubDate></item><item><title><![CDATA[Enum]]></title><description><![CDATA[ 
 <br><a data-href="Enum" href="java/enum.html" class="internal-link" target="_self" rel="noopener nofollow">Enum</a>]]></description><link>java/enum.html</link><guid isPermaLink="false">Java/Enum.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 03 Jun 2024 04:39:26 GMT</pubDate></item><item><title><![CDATA[객체 지향 프로그래밍의 가변성과 자료구조]]></title><description><![CDATA[ 
 <br><a data-href="Java의 불변성" href="java/java의-불변성.html" class="internal-link" target="_self" rel="noopener nofollow">Java의 불변성</a><br><br><br><br><br><br>다음 세가지 방법을 이용해 어느 정도의 불변성을 제공하고 있습니다.<br>
<br>변경 불가능한 컬렉션 
<br>불변 컬렉션 팩토리 메서드 (9+)
<br>불변 복제 (10+)
<br>
<br>new 키워드를 사용하여 인스턴스화 하는 것이 아닌 정적 편의 메서드를 갖습니다. 
<br>얕은 불면성만을 가지고 있어, 요소의 추가, 삭제가 불가능하고 요소 자체의 불변성을 보장하지 않습니다. 

<br>얕은 불변성을 가진 자료구조는 최상위 계층에서만 불변성을 유지합니다. 
<br>요소에 대한 참조를 보유한 모든 호출자는 다른 곳에서도 요소를 변경할 수 있습니다.


<br><br>
변경 불가능한 뷰는 주로 반환값으로 사용될 컬렉션에 대해 원치않는 변경을 막기위해 사용합니다.<br>
<img src="https://i.imgur.com/iF7NnD4.png" referrerpolicy="no-referrer">
<br><img src="https://i.imgur.com/a2GBHLG.png" referrerpolicy="no-referrer"><br>
<br>원본 인스턴스와 반환된 인스턴스의 차이점은 반환된 인스턴스를 수정할 때 UnsupportedOperationException이 발생합니다. 
<br>뷰를 통해서 접근하는 것이 아닌 기존 컬렉션에 직접 접근할 경우 수정이 가능해집니다. 
<br><br>
기존 컬렉션을 기반으로 하지 않으나, 원하는 요소들을 정적 편의 메서드를 이용해서 전달해야합니다. 
<br><img alt="Pasted image 20240603133256.png" src="lib/media/pasted-image-20240603133256.png"><br>
<br>0개 이상의 요소를 받아들일 수 있으며 제공된 요소 개수에 따라 최적의 내부 컬렉션 타입을 사용합니다 
<br><br>
다음 세가지 유형의 static 메서드 copyOf를 호출하여 깊은 수준의 불변성을 제공합니다. 
<br><img src="https://i.imgur.com/pzkh19r.png" referrerpolicy="no-referrer"><br>
Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)
List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)
SMap&lt;K,V&gt; copyOf(Collection&lt;? extends K, ? extends V&gt; coll)

<br>
<br>단순히 뷰를 제공하는 것뿐만 아니라 copyOf 메서드는 새로운 컨테이너를 생성해 요소들의 참조를 독립적으로 유지합니다. 
<br>복사된 컬렉션은 원본 리스트에 요소를 추가하거나 제거하는 것을 방지합니다. 
<br>실제 요소 자체는 공유되며 변경 가능합니다. 
]]></description><link>java/java의-불변성.html</link><guid isPermaLink="false">Java/Java의 불변성.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 03 Jun 2024 04:47:57 GMT</pubDate><enclosure url="https://i.imgur.com/iF7NnD4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/iF7NnD4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Record]]></title><description><![CDATA[ 
 <br><br>
불변 데이터 객체를 정의하는 것을 용이하게 하는 새로운 클래스타입입니다. 14에서 미리보기 기능으로, 16에서 정식 출시되었습니다. 레코드를 사용하면 일반적으로 필요한 보일러 플레이트코드(생성자, getter, equals, hashCdoe, toString등)을 자동으로 생성할 수 있습니다. 
<br><br><br>
<br>불변성: 레코드의 필드는 final로 선언되며, 객체 생성 후에는 변경할 수 없습니다.
<br>자동 생성 메소드: 레코드는 생성자, getter 메소드, equals(), hashCode(), toString() 메소드를 자동으로 생성합니다.
<br>간결한 문법: 레코드를 사용하면 보일러플레이트 코드를 줄일 수 있어 코드를 간결하게 작성할 수 있습니다.
<br><br>
public record Point(int x, int y) { }

<br>레코드가 제공하는 기능을 설명하기 위해 기반이 되는 튜플 자료구조와 전통전인 POJO를 불변 객체로 만드는 과정을 살펴보겠습니다. 이후 레코드를 사용하여 동일한 기능을 구현해보겠습니다. <br><br><br><br>
여러 값 또는 객체를 모은 자료구조입니다. 
<br><br>
요소들의 순서에만 의존하기 때문에 인덱스를 통해서만 접근이 가능합니다. 
<br>
apple = ("apple", "grren")


print apple[0] apple[1]


<br><br>
데이터에 접근하기 위한 방법으로 인덱스를 사용하지 않고 컴포넌트 명을 사용합니다. 
<br>
typealias Fruit = (name:String, color:String)

let fruits: [Fruit] = [
	(name: "apple", color:"green"),
	(name: "banana", color:"yellow)
]

print fruit[0].name fruit[0].color 

<br><br>
user 클래스를 POJO로 만들고 불변 POJO로 개선하는 예제입니다. 
<br><br>
public final class User{
	private String username;
	private boolean active;
	private LocalDateTime lastLogin; 

	public User(){}

	public User(String username, boolean active, LocalDateTime lastLogin){
		this.username = username
		this.active = active;
		this.lastLogin = lastLogin; 
	}

	public String getUsername(){
		return this.username; 
	}

	public void setUsername(String username){
		this.username = username; 
	}

	//기타 getter, setter, hashCode, toString, equals 등 

}

<br>가장 불편한 점은 기본 작업을 수행하려면 형식적인 코드 (getter, setter, toString, 생성자 등)가 과도하게 많이 필요합니다. 실제로 3개의 데이터 필드를 갖는 클래스를 작성할 때도 빈 라인과 중괄호를 포함하여 70 줄 이상의 공간을 차지합니다. <br><br>
<br>빈 생성자를 삭제합니다.<br>
: 필드는 반드시 객체가 생성될 때 전부 선언되어야합니다. 
<br>setter 메서드를 삭제합니다. 
<br>-&gt; 여전히 보일러 플레이트의 양이 많습니다.<br><br>
보일러플레이트 코드들이 필요하지 않으며, 필드의 정의만으로도 불변 POJO와 동일한 기능을 가질 수 있습니다. 
<br>
public record User(String username, boolean active, LocalDateTime lastLogin){


}

<br><br>
javap 명령어를 통해 .class 파일을 디스어셈블하여 자바 코드를 바이트 코드로 확인해봅시다. 
<br><img src="https://i.imgur.com/jI6KVJ2.png" referrerpolicy="no-referrer"><br>위 이미지를 통해 보면알 수 있듯이, 접근자 메서드의 차이만 있을 뿐, 두 클래스는 기능적으로 동일합니다. <br><br>
레코드는 명목상 튜플과 마찬가지로 순서대로 정렬된 값의 시퀀스를 집계하여 인덱스 대신 이름을 통해 접근할 수 있습니다. 
<br><br>
속성을 정의하는 헤더와 추가 생성자와 메서드를 지원하기 위한 바디. 크게 두가지로 나뉩니다. 
<br><br>
헤더는 클래스나 인터페이스의 헤더와 유사합니다. 
<br>
[visibility] record [레코드명] &lt;제네릭타입&gt;([data components]){


}


<br><br><br><br>
public record User(String username){

}


var user = new User("ben");

var username = user.username(); 

<br>
<br>모든 레코드 컴포넌트들은 private 필드로 저장됩니다. 
<br>내부에서는 직접적으로 필드에 접근할 수 있으나, 외부에서는 public 접근 메서드를 통해서만 가능합니다. 
<br>이 메서드의 이름은 getter가 아닌 일반 컴포넌트의 이름과 일치합니다. 
<br><br>
레코드는 불변한 데이터를 보관하도록 설계되었습니다.<br>
-&gt; 그 데이터에 접근하면서 어떤 처리나 판단하는 것은 코드 스멜입니다.<br>
-&gt; 레코드가 생성될 때 그 데이터는 이미 정의되어 있어야합니다. 
<br><br>
레코드의 각 컴포넌트에 따라 자동으로 생성되는 생성자입니다. 
<br>
<br>레코드의 컴포넌트들은 그대로 해당 필드에 매칭되어 할당됩니다. 
<br>표준 생성자는 입력의 유효값 검사, 데이터 조정을 위해 오버라이딩할 수 있습니다. 
<br><br>
컴팩트 생성자에서 유효성 검사를 수행하면 좋습니다. 
<br>
public record User(String username, boolean active, LocalDateTime lastLogin){


	public User{
		Objects.requireNonNull(username);
		Objects.requireNonNull(lastLogin);
		username = username.toLowerCase(); 
	}

}
<br>
<br>생성자에서는 괄호를 포함한 모든 인수를 생략할 수 있습니다. 
<br>컴팩트 생성자에서는 직접 필드에 값을 할당할 수는 없지만, 할당되기 전 데이터를 사용자 정의하거나, 정규화할 수 있습니다. 
<br>
<br><br>
hashCode와 equals, toString() 메서드의 표준 구현을 제공합니다. 
<br>
<br>레코드 타입의 두 인스턴스는 컴포넌트의 각 데이터가 동일하면 동일하다고 간주됩니다. 
<br><br>
레코드는 일반적인 규칙을 따르는 제네릭을 지원합니다. 
<br>
public record Container&lt;T&gt;(T content, String identifier){


}

Container&lt;String&gt; stringContainer = new Container&lt;&gt;("hello","String container");

String content = stringContainer.content(); 


<br>
<br>제네릭 레코드를 과도하게 사용하는 것은 권장하지 않습니다. 
<br>도메인 모델을 더 정확하게 나타내는 구체적인 레코드를 사용하면 표현력이 더 높아지고, 오용을 막을 수 있습니다. 
<br><br>
어노테이션을 붙일 경우 예상과 다른 동작을 할 수 있습니다. 
<br>
<br>어노테이션을 지원하기 위해서, 필드, 파라미터, 메서드가 있는 어노테이션은 컴포넌트에 적용되는 경우 해당 위치로 전파됩니다. 
<br>기존 대상 외에도, 레코드에서 더 세밀한 어노테이션을 제어하기 위해 ElementType.RECORD_COMPONENT가 새롭게 도입되었습니다. 
<br><br>
<br>레코드 기반 타입의 경우 java.lang.reflect.
]]></description><link>java/record.html</link><guid isPermaLink="false">Java/Record.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 03 Jun 2024 04:04:49 GMT</pubDate><enclosure url="https://i.imgur.com/jI6KVJ2.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/jI6KVJ2.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[마이크로서비스]]></title><description><![CDATA[ 
 <br><br><br><img src="https://i.imgur.com/bL3ygE3.png" referrerpolicy="no-referrer"><br>클라이언트, 서버, DB로 구성된 전통적인 3-tier구조에서 서버가 단일 프로세스에서 실행되는 경우를 의미합니다. 애플리케이션이 한 덩어리로 구성되어있어 단일 프로세스를 실행합니다. 시스템을 일부만 수정한다 하더라도, 시스템 전체가 배포되어야합니다. 또한 하나의 기능에서 장애가 발생하면 모든 기능을 사용할 수 없습니다. <br><img src="https://i.imgur.com/tC9GW65.png" referrerpolicy="no-referrer"><br>또한 스케일 아웃시, 시스템 전체를 스케일 아웃시켜야합니다. a와 b 기능이 있을 때, a 기능만 담당하는 프로세스만 스케일 아웃이 불가능합니다. 현대 클라우드 개념은 온디맨드 즉, 쓴 만큼 돈을 지불합니다. 전체 시스템을 스케일 아웃하는 것은 비용상 문제가 발생합니다. <br><br><img src="https://i.imgur.com/2oudfi0.png" referrerpolicy="no-referrer"><br>마이크로 서비스는 애플리케이션의 각 기능을 잘라, 여러 개의 서비스 조각으로 구성합니다. 서비스는 각기 독립적인 기능을 제공하며 각 서비스의 저장소는 다른 서비스와 완벽하게 격리됩니다. 따라서 독립적으로 수정 가능하며, 별도 배포와 확장이 가능합니다. 또한 하나의 기능에서 장애가 발생하더라도 다른 서비스에 장애가 발생하지 않습니다. 또한 스케일 아웃시, 특정 트래픽이 몰리는 서비스에만 적용이 가능합니다. <br><img src="https://i.imgur.com/Jz1TVLh.png" referrerpolicy="no-referrer"><br>DB는 각 서비스마다 격리되어 있으며, 타 서비스가 다른 서비스의 DB에 직접 접근하는 것은 허용되지 않습니다. 해당 DB의 자원이 필요한 경우, 반드시 해당 서비스의 API를 이용하여 접근해야합니다. 객체지향에서 배웠던대로 DB는 캡슐화되어있으며 API는 인터페이스라고 이해하면 편합니다. <br>]]></description><link>msa/ddd/마이크로-서비스.html</link><guid isPermaLink="false">MSA/DDD/마이크로 서비스.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 23 Jun 2024 13:06:26 GMT</pubDate><enclosure url="https://i.imgur.com/bL3ygE3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/bL3ygE3.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Cloudy의 RAG 도입기]]></title><description><![CDATA[ 
 ]]></description><link>prj/cloudy/cloudy의-rag-도입기.html</link><guid isPermaLink="false">Prj/Cloudy/Cloudy의 RAG 도입기.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 06 Jun 2024 14:14:16 GMT</pubDate></item><item><title><![CDATA[채킹 내역 저장을 위한 키 설계]]></title><description><![CDATA[ 
 <br><br><br>DynamoDB의 기술적 구현방식을 다루기보단, DynamoDB를에 대해서 얇고 넓게 소개하고, Cloudy의 채팅 내역 저장 시스템에 어떻게 적용했는지 사례를 공유합니다. 기술적 내용에 대해 자세히 알고 싶다면 하단 참고 자료에 관련 링크들을 참조해주세요<br>아래와 같은 키워드가 등장합니다. 본문에서 개념에 대해 설명하며 진행할 예정이나, 관련 배경지식이 있다면 더 쉽게 이해할 수 있습니다. <br>
<br>Dynamo DB
<br>HotPartition
<br>Scale out  / Scale Up 
<br><br>Dynamo Db에서는 Partiion Key와 Sort Key를 합쳐 Primary Key로 사용하는 매우 독특한 특징이 있습니다. 올바르게 Dynamo DB를 사용하기 위해서 DynamoDB의 특징과 성질을 알아보겠습니다. <br>Partition Key<br>
pk는 많은 파티션 중 내가 찾고자하는 데이터가 어느 파티션에 있는지 알려주는 키입니다. 항상 equal 연산자만 사용할 수 있습니다. <br>Sort Key<br>
sk를 이용해서 1:n 관계의 모델링을 적용할 수 있습니다. 오름차순, 내림차순 대로 데이터를 정렬하여 조회할 수 있습니다. begins with , 등호 연산자 및 범위 연산자를 사용할 수 있습니다.<br>pk와 sk를 합쳐 Primary Key가 됩니다. 오직 Primary key로만 데이터 검색이 가능하기 때문에 pk와 sk 조합을 잘 설계해야합니다.<br>
<img src="https://i.imgur.com/o7S8mKQ.png" referrerpolicy="no-referrer"><br><br><br><img src="https://i.imgur.com/d4RQeDY.png" referrerpolicy="no-referrer"><br>데이터끼리 관계를 맺는 RDBMS는 수평적 확장이 매우 힘듭니다. 때문에 주로 스케일 업을 이용하여 해결합니다. 하지만 태생이 대규모 데이터를 처리하기 위해 나온 NoSQL의 경우 무한히 스케일 아웃을 진행할 수 있습니다.<br>
즉, NoSQL을 활용하는 데이터는 수평으로 확장 가능한 데이터가 되게끔 설계해야합니다. 또한 어느 한쪽의 인스턴스로만 트래픽이 쏠리지 않도록 키를 잘 설계해야합니다.<br><br>논리적 단위인 테이블은 한 개여도, 내부에서는 파티션이라는 단위로 쪼개져 저장됩니다. <br><br>하나의 파티션은 다음과 같은 제약사항을 가집니다. 데이터가 계속해서 늘어나더라도 파티션의 개수 증가하는 개념이지, 한 파티션 내의 제약사항은 절대로 변하지 않습니다. <br>
<br>1k WCU
<br>3K RCU 
<br>10GB<br>
-&gt; 여러개의 파티션이 골고루 사용되도록 파티션을 식별하는 키 디자인을 잘하는 것이 중요합니다.
<br><br><img src="https://i.imgur.com/7wXEKR7.png" referrerpolicy="no-referrer"><br><img src="https://i.imgur.com/qL0u4w9.png" referrerpolicy="no-referrer"><br>Dynamo DB는 Id를 해쉬값으로 변경하여 저장되는 파티션을 결정합니다. Application 구현시 Key값을 해쉬로 변경하는 로직은 짜지 않아도 괜찮습니다. <br><br>Amazon DynamoDB에서 파티션은 데이터의 양과 테이블에 대한 읽기/쓰기 요청의 양에 따라 자동으로 관리됩니다. 파티션이 늘어나는 주요 시점은 다음과 같습니다:<br>1.데이터의 양이 증가할 때:<br>
- DynamoDB 테이블에 저장된 데이터의 양이 파티션당 최대 저장 용량(10GB)을 초과할 때 새로운 파티션이 자동으로 추가됩니다. 즉, 테이블에 있는 데이터의 총량이 증가하여 각 파티션의 용량이 초과될 경우 DynamoDB는 추가 파티션을 생성하여 데이터를 분산 저장합니다.<br>2.프로비저닝된 읽기/쓰기 용량이 증가할 때:<br>
- 테이블의 프로비저닝된 읽기 및 쓰기 용량 단위가 증가하면 DynamoDB는 이를 수용하기 위해 파티션 수를 늘릴 수 있습니다. 파티션당 최대 처리량(읽기/쓰기 용량)이 제한되어 있기 때문에, 필요한 처리량을 제공하기 위해 더 많은 파티션을 생성합니다.<br>3.온디맨드 모드에서의 스케일링:<br>
- DynamoDB 테이블이 온디맨드 모드로 설정되어 있으면, 읽기 및 쓰기 요청의 트래픽 패턴을 자동으로 감지하여 파티션을 조정합니다. 트래픽이 급증하거나 감소할 때 테이블의 파티션 수는 자동으로 늘어나거나 줄어들 수 있습니다.<br><br><img src="https://i.imgur.com/78MRveb.png" referrerpolicy="no-referrer"><br>Dynamo DB는 항상 데이터를 복제하여 저장합니다. 3개의 가용영역에 복제되며 서비스는 3개의 가용영역에서 실행됩니다. <br><br><br>DynamoDB는 RCU와 WCU라는 컴퓨팅 단위를 사용합니다. 일반적인 RDB와는 다르게 WCU와 RCU는 독립적으로 동작합니다. <br><br><br>테이블의 전체 크기를 의미합니다. 테이블에 넣을 수 있는 아이템의 개수로 따지는 것이 아닌 최대 크기로 따집니다. 400KB까지 사용 가능합니다. 하지만 400KB를 전부 사용하는 것은 권장하지 않습니다. DynamoDB는 하나의 아이템에서 한 글자만 바뀌어도 다시 쓰는 특성을 갖습니다. 이러한 이유로 아이템의 사이즈는 작게, 아이템의 개수가 많게끔 저장되는 데이터를 모델링하는 것이 이상적입니다. <br>-&gt; DynamoDB의 컨셉은 무한하게 많은 데이터 중 PK+SK의 조합으로 특정한 데이터를 가능한한 빠르게 반환하는 것임을 잊지말아야합니다. <br><br>기본적으로 Dynamo DB에서는 데이터를 읽기 위한 REST API를 제공합니다. <br><br>
<br>Partition Key의 정확한 값을 지정해야합니다. 
<br>0개 또는 1개의 아이템만 반환합니다. 
<br>아이템 크기에 따라 RCU를 사용합니다. 

<br>아이템 크기가 10kb인 경우 2RCU를 사용합니다. 


<br><br>
<br>Partition Key의 정확한 값을 지정해야합니다. 
<br>선택적으로 attributes에 필터링 조건을 추가할 수 있습니다. 
<br>조건에 맞는 아이템을 여러개 반환합니다. 
<br>조건과 일치하는 아이템 크기에 따라 RCU를 소비하여 단일 결과를 반환합니다. 
<br>LastEvaluatedKey <br>
<br>Query는 단일 호출로 최대 1MB만 반환할 수 있습니다.
<br>응답 메시지가 1MB 이상일 경우 LastEvaluatedKey를 활용해 pagination이 가능합니다.
<br><br>
<br>rdbms에서의 Full Table Scan 과 동일합니다.
<br>Dynamo DB에서는 페이지네이션과 비슷하게 동작합니다. <br>
<br>rdbms에서는 테이블 끝까지 조회하지만, DynamoDB에서는 1MB 단위로 스캔이 가능합니다. 
<br>return 갑 중 token을 활용해 다음 1MB 데이터를 스캔할 수 있습니다. 
<br>사용예시<br>
<br>OLTP의 운영환경에서는 사실상 사용할 일이 없습니다. (어쨌거나 저쨌거나 결국 full table scan입니다.)
<br>온라인 마이그레이션을 할때의 옵션 중 하나입니다. 
<br><br>
<br>ACID를 지원하기 위한 API입니다. 
<br>단일 리전 내에서 여러개의 테이블이나 아이템을 트랜잭션으로 묶어 읽거나 쓸 수 있습니다. 
<br>WCU와 RCU가 2배가 소모되기 때문에, 필요한 곳에만 최소화하여 사용해야합니다. 
<br><br>Amazon DynamoDB에서 LSI(Local Secondary Index)와 GSI(Global Secondary Index)는 테이블의 쿼리 성능을 향상시키기 위해 사용되는 인덱스입니다. 두 인덱스 모두 테이블의 속성을 기준으로 데이터를 효율적으로 검색할 수 있게 해주지만, 사용 방법과 동작 방식에서 몇 가지 중요한 차이점이 있습니다.<br><br><img src="https://i.imgur.com/I7V2d7g.png" referrerpolicy="no-referrer"><br>
<br>테이블의 Primary Key 외의 다른 검색 조건이 필요한 경우 사용합니다.
<br>추가나 삭제가 자유로워 스키마 변경시 유연하게 대처할 수 있습니다. 
<br>원하는 Attribute를 GSI의 PK, SK로 설정합니다. 
<br><br><img src="https://i.imgur.com/YzEEnCb.png" referrerpolicy="no-referrer"><br>
<br>테이블 안에서 동일한 PK를 사용하며, 다른 SK를 사용하고 싶을 때 LSI를 사용합니다.
<br>일반적으로 사용을 권장하지 않습니다.<br>
<br>GSI와 달리 테이블 생성 시점에만 설정이 가능합니다. 
<br>사용 도중 삭제 또한 불가능합니다.
<br><br><br><img src="https://i.imgur.com/XvYMacu.png" referrerpolicy="no-referrer"><br>rdbms에서 처럼 엔티티별로 테이블을 만들지 말자<br>
오른쪽 예시처럼 최대한 빠르게 데이터를 조회하게 끔 해야한다. <br>
<br>application의 usecase가 dynamo db가 잘하는 것과 맞는지 판단해야합니다. 
<br>Dynamodb가 가장 잘하는 것은 무한대의 가까운 item에서 특정개수의 아이템을 Primary Key(PK+SK)로 빠르게 조회하는 것 이다. 대량의 벌크성 쿼리, range 쿼리, 집계 쿼리는 잘 수행하지 못합니다.<br>
<br>액세스 패턴을 식별해야합니다.<br>
읽기/쓰기 워크로드, 쿼리 차원, 집계
<br>사이즈가 작은 여러개의 테이블보다는 사이즈가 큰 하나의 테이블을 사용하는 것이 낫다.<br>
DynamoDB는 테이블 단위 완전 관리형 서비스이다.<br>
Dynamo DB는 풀서버리스 형태의 테이블 단위 완전관리형 서비스입니다. 여러 개의 테이블을 만들게 되면 각 테이블에 대한 설정, 모니터링, 최적화 등의 관리 작업이 필요하게 됩니다. 예를 들어 각 테이블의 스키마 설정 및 변경, 인덱스 관리, 성능 모니터링 및 튜닝, 읽기/쓰기 용량 설정 등을 각각의 테이블 별로 따로 해줘야합니다.<br>
이는 완전관리형 서비스의 설계 철학, 즉 "사용자가 최소한의 관리만으로 데이터베이스를 운영할 수 있도록 한다"는 목표에 어긋나게 됩니다.<br>테이블을 하나로 사용해야지, 여러개의 파티션을 사용하는 DynamoDB의 특성을 제대로 활용할 수 있습니다. 또한 핫 파티션이 발생할 확률이 줄어듭니다. <br>OLTP vs OLAP<br>
OLTP가 적합합니다. OLAP인 경우 DynamoDB 외부로 파이프라인을 만들어 분석을 수행해야합니다. <br>디자인 패턴 <br>비정규화 ]]></description><link>prj/cloudy/dynamo-db-채팅-내역-저장을-위한-키-설계.html</link><guid isPermaLink="false">Prj/Cloudy/Dynamo DB - 채팅 내역 저장을 위한 키 설계.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 08 Jun 2024 03:33:24 GMT</pubDate><enclosure url="https://i.imgur.com/o7S8mKQ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/o7S8mKQ.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Flux를 활용한 SSE 구현기]]></title><description><![CDATA[ 
 <br><br><br>다양한 EventSreaming 구현방식에 대해 알아봅니다. 또한 Cloudy의 채팅 에 왜 SSE를 선택했고 어떻게 개발했는지 사례를 공유합니다. 기술적 내용에 대해 자세히 알고 싶다면 하단 참고 자료에 관련 링크들을 참조해주세요<br>아래와 같은 키워드가 등장합니다. 본문에서 개념에 대해 설명하며 진행할 예정이나, 관련 배경지식이 있다면 더 쉽게 이해할 수 있습니다. <br>
<br>Event Streaming
<br>SSE
<br>Webflux의 Flux 
<br>Nginx 
<br><br>Cloudy 챗봇들은 질문이 들어오면 다음과 같이 작동합니다. <br>1. AOP가 적용되어 있어 불건전 질문을 자동으로 필터링합니다. 
2. 질문에 대해서 관련 AWS 서비스, it 키워드로 추출합니다. 
3. 추출해낸 키워드를 바탕으로 Vector DB[pinecone]에서 관련 데이터를 찾습니다. 
4. 찾아낸 데이터를 바탕으로 최종 답변을 생성해냅니다. 
<br>REST API로 처리할 경우, 1~4 과정(평균 6~8초) 동안 사용자는 로딩 스피너만 바라보는 상황이 발생합니다.  특히 ChatGPT API를 활용해서 답변을 생성해 내는 시간이 가장 오래 걸립니다. Chat GPT Streaming API와 SSE를 조합해 답변을 생성 중 일지라도, 데이터를 실시간으로 받아볼 수 있게끔 개선하였습니다. <br><img alt="chatbotOudy.gif" src="lib/media/chatbotoudy.gif"><br><br>
먼저 SSE 뿐만 아니라, Polling 등 여러 관련된 방식을 포함하는 Event Streaming을 구현할 수 있는 여러 방법에 대해 알아봅시다.
<br><br><img src="https://i.imgur.com/VS9erwz.png" referrerpolicy="no-referrer"><br>
<br>주기적으로 클라이언트가 서버에 요청을 보냅니다. 
<br>서버는 데이터나 이벤트가 없으면 빈 값을, 있으면 값을 보내줍니다. 
<br><br>
<br>클라이언트에서 대기하는 시간이 길다면 실시간성이 떨어지고, 대기하는 시간이 짧다면 서버에 부담이 간다. 
<br><br><img src="https://i.imgur.com/jMlQ8Wo.png" referrerpolicy="no-referrer"><br>
<br>주기적으로 클라이언트가 서버에 요청을 보냅니ㅣ다. 
<br>서버는 바로 응답하는 것이 아닌, 데이터가 발생하거나, 타임아웃이 발생하면 클라이언트에 응답을 전달합니다. 
<br>클라이언트는 응답을 받은 후 대기를 하지 않고 바로 long poll 요청을 전달합니다. 
<br>쉽게 구현할 수 있습니다. 
<br>이벤트, 데이터가 생길 때 마다 응답을 돌려주기 때문에 실시간성이 높습니다. 
<br><br>
<br>요청과 응답 모두 독립적이기 때문에 header를 모두 포함합니다.<br>
--&gt; 원래는 하나의 http 응답입니다. 공통되는 요소를 반복해서 보내야하기 때문에 오버헤드가 발생합니다.
<br>클라이언트와 서버 모두 TCP/IP 연결을 연상태로 대기합니다.<br>
-&gt; 한정된 커넥션 풀과 관련된 리소스를 신경써야합니다.
<br>클라이언트에게 제공할 이벤트가 큐에 쌓이면 각각의 이벤트를 단건으로 여러개의 long poll 요청에 나눠서 전달해야합니다. 
<br>브라우저, gateway 등 다른 구성요소의 timeout을 고려하여 대기 시간을 설정해야합니다. 
<br><br>
클라이언트와 서버가 연결된 상태에서 지속적으로 데이터를 얻는 방식입니다.<br>
주로 비디오 스트리밍, 음악 스트리밍 등 대용량의 연속적인 데이터 전송에 사용됩니다. 
<br>
Long Polling과 다르게, 하나의 http 응답을 여러개의 http응답으로 나눠서 보내는 것이 아닌, http 응답을 잘게 짤라서(=chnuk 단위)보냅니다.
<br><br>
<br>
HTTP/1.1또는 HTTP/2를 사용할 수 있습니다 

<br>
HTTP/2의 경우 멀티플렉싱을 이용할 수 있습니다. 

<br>
클라이언트가 서버에 요청을 보냅니다. 

<br>
서버가 전달할 이벤트, 데이터 등이 있다면 응답의 일부분을 전달합니다. 

<br>
요청이나 연결을 닫지 않고 이벤트, 데이터를 전달할 때까지 대기합니다. 

<br><br>
동적으로 content를 생성하는 경우 정확한 Content-Length 를 미리 제공할 수 없기 때문에 아래의 방식으로 HTTP Streaming을 구현합니다. 
<br><br>
<br>Transfer-Encoding:chunked 를 헤더에 추가합니다. 
<br>텅 빈 chunk를 전달하기 전까지 값을 읽습니다. 
<br>Http/1.1 이상에서만 사용할 수 있습니다. 
<br><br>
<br>Connection: close 를 헤더에 추가합니다. 
<br>서버가 연결을 종료할때까지 들어오는 값을 읽습니다. 
<br><br>
이벤트 스트리밍을 단방향으로 언제든지 가능하게 합니다.<br>
텍스트 기반의 실시간 업데이트에 적합합니다. 
<br>
<br>이벤트 : 정의한 포멧에 따라 UTF-8f로 인코딩된 텍스트 데이터의 스트림 
<br><br><img src="https://i.imgur.com/LZEifhF.png" referrerpolicy="no-referrer"><br>
<br>클라이언트가 서버에 EventSource 객체를 사용해 연결을 엽니다. 
<br>서버는 text/event-stream MIME 타입을 사용해 이벤트를 전송합니다. 
<br>연결은 클라이언트가 끊을 때까지 지속합니다. 
<br><br>
<br>HTTP/1.1 을 사용합니다. 
<br><br><br>
관련된 기술로서 가장 먼저 생각나는 것은 웹소켓입니다. Websocket이 아닌, SSE를 선택한 이유는 크게 두가지였습니다. 
<br><br><br><img src="https://i.imgur.com/bV6f0SG.png" referrerpolicy="no-referrer"><br><br><img src="https://i.imgur.com/sFJBUBH.png" referrerpolicy="no-referrer"><br>특징을 정리해봅시다. SSE는 서버에서 데이터가 생성될 때마다 stream하는 단방향통신이고, websocket은 핸드 셰이크를 통해 커넥션을 수립하기 때문에 , 클라이언트와 서버 둘다 양방향 통신이 가능합니다. <br>Cloudy에서 제공하는 챗봇을 사용할 때 유저 플로우를 살펴봅시다. <br>1. 유저가 질문을 입력한다. 
2. 답변이 나올 때까지 기다린다. 
3. 답변을 받고나서 질문을 입력한다. 
<br>기존 채팅의 유저 플로우를 살펴봅시다. <br>1. 유저가 질문을 입력한다. 
2. 답변이 나올때까지 기다린다. or 답변이 오기전 다른 대화 주제로 틀어버릴 수 있다. 

<br>2번 과정을 비교해보겠습니다. 일반 사용자끼리의 채팅처럼 일상적인 대화의 경우, 상대방의 대화를 듣기 전 대화 주제가 변할 수 있습니다. 즉, 응답을 받고 있는 중에도 채팅을 보낼 수 있어야합니다. 하지만 Cloudy 처럼 QNA와 관련된 챗봇의 특성상 사용자가 질문을 하자마자 주제가 바뀔 우려는 거의 없습니다. 왜냐하면 사용자는 질문에 대해 답변을 받고 그 답변을 바탕으로 다른 질문을 생성해내기 때문입니다.<br>
즉, cloudy의 서비스 특성상, 사용자 입장에서는 답변이 생성되고 있는 중에, 다른 질문을 보내는 것보다는 완성된 답변을 읽고 답변의 내용을 바탕으로 다른 질문을 보낼 확률이 더 큽니다. 사실상 단방향 통신인 셈입니다. 때문에 서비스의 특성상 one-way communication을 지원하는 SSE로 챗봇을 구현하더라도 크게 상관 없겠다는 판단이 들었습니다. <br><br>웹소켓을 구현할 경우 고려하고 관리해야하는 범위가 늘어납니다. <br>
<br>웹소켓 핸드 셰이크를 위한 config 클래스 
<br>stomp 환경에서 작동할 수 있는 메시징 브로커 그 자체

<br>메시징 브로커와 관련된 Config 클래스들 


<br>채팅 publish와 로그 저장, 채팅 로그 조회 관련된 클래스 
<br>하지만 SSE를 활용하여 구현할 경우 Websocket보다는 고려하고 관리해야하는 범위가 좁습니다. <br>
<br>핸드 셰이크가 필요없이 단일한 REST API 하나를 이용해서 응답을 주고 받습니다. 
<br>메시징 브로커를 쓰지 않습니다.
<br>채팅 publish를 할 필요가 없으며 로그 저장 및 채팅 로그 조회 관련 클래스만 구현하면 됩니다, 
<br><br><img src="https://i.imgur.com/phuHdqN.png" referrerpolicy="no-referrer"><br>
<br>Chunked Transfer-Encoding 기반입니다. 
<br>chunk 단위로 여러 줄로 구성된 문자열을 전달합니다. 
<br>new line으로 이벤트를 구분합니다. 
<br>각각의 문자열은 일반적으로 &lt;field&gt;:&lt;value&gt; 형태로 구성됩니다. 
<br><br><br><br><br>
<br>클라이언트가 서버에 EventSource 객체를 사용해 연결을 엽니다. 
<br>서버는 text/event-stream MIME 타입을 사용해 이벤트를 전송합니다. 

<br>서버는 유저 질의를 OpenAI의 Streaming ChatModel을 사용하여 실시간으로 데이터를 받아들이고 이를 Reacive Stream 의 Fluxfh 반환합니다. 


<br>연결은 클라이언트가 끊을 때까지 지속합니다. 
<br><br>
응답을 Flux로 반환하기 때문에, Flux와 FluxSink에 대해서 알아보고 가겠습니다. 
<br><br>
0~N개의 데이터 항목을 비동기적으로 스트리밍하는 Publisher를 나타냅니다.<br>
데이터 스트림을 처리하고 변환하는 다양한 연산자를 제공합니다. 
<br><br>
Flux.create와 함께 사용하며, Flux의 데이터를 push 방식으로 제공할 수 있게끔합니다. 또한 Flux 스트림 내에서 데이터를 동적으로 생성하고 내보낼 수 있습니다. 
<br>
<br>next, complete, error 메서드를 오버라이딩하여 데이터를 전송하거나 스트림의 완료, 에러 시 처리를 커스텀할 수 있습니다. 
<br><br>
두 객체를 활용해 스트림을 동적으로 생성하고 데이터를 push할 수 있습니다.<br>
Flux.create 메서드는 FluxSink를 인자로 받아 데이터를 스트림에 공급할 수 있는 Flux를 생성합니다. 
<br><br>
클라이언트로 부터 유저 질의를 받아 실시간으로 생성되는 챗봇의 응답을 스트리밍하는 컨트롤러 입니다. 
<br>  

@PostMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;String&gt; generateChat(@RequestBody ChatReq question,   
								 @AuthenticationPrincipal Member member) {

	
	return chatBotService.question(question, member.getId());

}

<br>produces = MediaType.TEXT_EVENT_STREAM_VALUE<br>
이 API의 반환 값이 text/event-stream MIME 타입임을 명시합니다. <br>Flux<br>
스트리밍 방식으로 여러개의 문자를 전송하기 위해서 Project Reactor의 Flux 타입을 사용합니다. <br><br>
Open AI의 Streaming Chat Model을 사용하여 실시간으로 데이터를 받아들이고, 이를 Reactive Streams의 Flux로 변환하여 반환합니다.
<br>

  

@Override
public Flux&lt;String&gt; generateStreamingChat(String template, 
										  Map&lt;String, Object&gt; variables, 
										  String userId, Chatbot chatbot) {

  

	Prompt prompt = getPrompt(template, variables);
	
	
	if (openAiStreamingChatModel == null) {
	openAiStreamingChatModel = OpenAiStreamingChatModel.builder()
								.apiKey(openAiKey)
								.modelName(GPT_3_5_TURBO)
								.build();
	}

  
  
  

	return Flux.create(emitter -&gt;
			openAiStreamingChatModel.generate(prompt.text(), 
			new StreamingResponseHandler&lt;&gt;() {
			
			  
			
			@Override
			public void onNext(String token) {
				emitter.next(token);
			}
			
			  
			
			@Override
			public void onComplete(Response&lt;AiMessage&gt; response) {
				chatQueryService.saveChat(userId, 
										 . chatbot, 
										   . response.content().text(), 
											false
										);
			
				emitter.complete();
			}
			
			  
			  
			
			@Override
			public void onError(Throwable error) {	
				log.error("[OpenAiChatService generateStreamingChat] 에러 발생 ::{}", error);
				emitter.next("에러가 발생했습니다. 관리자에게 문의하세요.");
				emitter.complete();
	
			}));

}
<br>Flux.create<br>
Flux 스트림을 생성합니다. emitter는 FluxSink 객체로, 데이터 스트림을 내보낼 수 있습니다. Flux.create는 데이터를 생성하고 Flux.sink를 통해 비즈니스 로직을 제공받아 가공된 Flux를 생성합니다. <br>emitter<br>
FluxSink 인터페이스의 인스턴스입니다. 데이터를 Flux 스트림으로 내보냅니다. next, complete, error 등의 메서드를 오버라이딩하여 스트림을 제어할 수 있습니다. <br>StreamingResponseHandler<br>
Open AI의 스트리밍 응답을 처리하기 위해 해당 StreamingResponseHandler를 사용합니다. 이 핸들러를 사용하기 위해서는 onNext, onComplete, onError 3가지 메서드를 구현해야합니다. <br>onNext 메서드 <br>
실시간으로 생성되는 데이터를 수신했을 때 onNext 메서드를 호출합니다.<br>
emitter.next(token) 을 호출해 받은 데이터를 Flux 스트림으로 전달합니다. 
<br>@Override
public void onNext(String token) {
	emitter.next(token);
}

<br>onComplete 메서드 <br>
스트리밍이 완료되었을 때 호출합니다. 
<br>@Override
public void onComplete(Response&lt;AiMessage&gt; response) {
    chatQueryService.saveChat(userId, 
							  chatbot, 
                              response.content().text(), 
                              false
                             );

    emitter.complete();
}

<br>
<br>다음 접속시에 채팅 내역을 제공해야하기 때문에 Dynamo DB를 활용해 채팅 내용을 저장합니다. 
<br>emitter.complete()  를 호출하여 Flux 스트림을 활용합니다. 
<br>onError 메서드 <br>
스트리밍 중 에러가 발생했을 때 호출합니다. 
<br>
@Override
public void onError(Throwable error) {	
	log.error("[OpenAiChatService generateStreamingChat] 에러 발생 ::{}", error);
	emitter.next("에러가 발생했습니다. 관리자에게 문의하세요.");
	emitter.complete();
}));

<br>원래는 emitter.error() 를 활용해 Publisher에서 에러를 발생시켜야합니다. 하지만, 특정 에러 응답을 반환하기 보다는, 서버에서 에러 로깅 후 클라이언트 대화창에서 바로 에러메시지를 출력하기로 구현 스펙을 결정했기 때문에 다음과 같은 비즈니스 로직으로 구현하였습니다. <br>
<br>에러를 로깅한다. 
<br>대화 로그에 에러 발생 메시지를 포함시킨다. 
<br>스트리밍을 종료한다. 
<br><br><br>Nginx의 디폴트 값<br>
Nginx는 기본적으로 업스트림 요청을 보낼 때, HTTP/1.0버전을 사용합니다. 하지만 SSE는 HTTP/1.1버전 부터 사용할 수 있습니다.<br>
또한 Connection:close 헤더를 사용합니다. SSE는 지속 연결이 되어 있어야하는데, Nginx에서 바로 지속연결을 닫아버리기 때문에 문제가 발생합니다. <br>변경된 설정값<br>proxy_set_header Connection '';
proxy_http_version 1.1;
<br><br>Proxy Buffering이란<br>
클라이언트와 서버 중간에 위치한 Nginx는 트래픽 최적화를 위해, 요청 및 응답을 일시적으로 저장하고 처리합니다. <br>SSE와 Proxy Buffering의 관계<br>
SSE의 특성상 실시간으로 데이터를 스트리밍합니다. 이 스트리밍된 데이터는 바로바로 유저에게 전달되어야합니다. Proxy Buffering이 켜져있을 경우 Nginx가 서버의 응답을 일부 버퍼에 저장하고 버퍼가 차거나 응답 데이터를 모두 전송했을 경우 한번에 클라이언트로 전송합니다. 즉 원래 기능 명세대로, 한글자씩 반환하는 것이 아닌 몇 줄에 한번씩 클라이언트는 답변을 확인할 수 있어 실시간성이 떨어지게 됩니다. <br>X-Accel 활용하기<br>@PostMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE) 
public Flux&lt;String&gt; generateChat(@RequestBody ChatReq question, 
								 @AuthenticationPrincipal Member member, 
								 ServerHttpResponse response) { 
	log.info("{}", question); 
	headers = response.getHeaders(); 
	headers.add("X-Accel-Buffering", "no"); 
	return chatBotService.question(question, member.getId()); }
}
<br>응답 헤더에 X-accel로 시작하는 헤더가 있으면 Nginx는 버퍼링을 수행하지 않습니다. &nbsp;SSE 응답을 반환하는 API의 헤더에&nbsp;X-Accel-Buffering: no를 붙여줘 SSE 응답만 버퍼링을 하지 않도록 설정하였습니다. ]]></description><link>prj/cloudy/flux를-활용한-sse-구현기.html</link><guid isPermaLink="false">Prj/Cloudy/Flux를 활용한 SSE 구현기.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Tue, 26 Nov 2024 01:55:42 GMT</pubDate><enclosure url="lib/media/chatbotoudy.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/chatbotoudy.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[RDB 단점]]></title><description><![CDATA[ 
 <br><br>경직된 스키마<br>
예를들어, 기존 데이터가 5천만이고 해당 테이블에 event_id 칼럼을 추가하는 경우 대규모 쓰기 작업이 일어납니다. 데이터 양이 많은 테이블에 대해서 칼럼을 추가하거나 스키마를 변경하는 경우 위험 부담이 큽니다. RDB는 스키마가 결정된 이후 새로운 요구사항을 반영하여 스키마를 변경하기가 힘듭니다.<br>과도한 join<br>
RDB의 컨셉 상, 테이블 내 중복된 데이터가 많을 경우, 정규화를 합니다. 정규화가 많이 일어날 경우 join 대상이 늘어납니다. 통합된 데이터를 읽어와야하는 쿼리가 많을 경우 복잡한 join으로 인해 유지보수성이 낮아지고 read 성능이 하락할 수 있습니다. <br>scale out이 유연하지 않다.<br>
데이터가 지속적으로 축적되는 상황에서 성능을 개선하기 위해서는 scale up과 replication 말고는 방법이 없습니다. DB 서버의 성능을 올리는 scale up 방식은 비용이 많이 들고 한계가 있습니다. 또한 읽기 전용으로 여러개의 DB replica를 구성하는 방식은 쓰기 작업이 많이 일어나는 비즈니스 로직일 경우 효과가 적습니다.<br>
물론 multi maser, sharding과 같은 방법도 있지만, RDB는 scale out에 유연하지 않습니다.<br>transaction ACID<br>
일반적으로 transaction ACID는 장점을 가지고 있지만 그 trade-off 또한 명확합니다. ACID를 보장하려다보니 DB 서버의 성능에 영향을 미칩니다. 일반적으로 ACID를 엄밀하게 보장하려고 할수록 DB 서버의 전체 처리량이 낮아질 수 있습니다. <br><br><br>2000년대 초중반으로 넘어오면서, 인터넷을 사용자가 폭발적으로 늘어나기 시작합니다. 사용자가 폭발적으로 늘어나면서 high-throughput과 low-latency를 요구하는 DB의 수요가 높아졌습니다. 또한 예상할 수 없는 비정형 데이터가 증가하면서 스키마가 유연한 DB의 수요가 높아졌습니다. <br><br>유연한 스키마<br>
sql에서 테이블(=nosql에서의 컬렉션)을 생성할 경우 해당 테이블의 데이터 구조를 미리 정의해야합니다. <br>create table student(
	id INT PRIMARY KEY,
	name VARCHAR(20),
)

<br>반면 NoSQL에서 컬렉션을 정의할 때 스키마를 정의하지 않아도 됩니다. <br>db.createCollection("student")
<br>컬렉션의 데이터 구조가 결정되는 시점은 데이터를 삽입할 때입니다. <br>db.student.insertOne({name:"hanju"})
<br>같은 컬렉션이라고 같은 구조의 데이터만 넣을 필요 없이, 저장되는 데이터 형식에 맞춰서 저장할 수 있습니다.<br>
(json 형태로 데이터를 저장하기 때문) <br>db.student.insertOne({
	name:"hanju",
	address:{
		country: "Korea",
		state: "Seoul"
	}
	certificate: ["AWS solution Architect", "HAST Lv3"]
	
	})

<br>parameter로 검색하는 과정 역시 json을 활용하기 때문에 유연합니다. <br>db.student.find({name"hanju"})
<br>중복 허용 join 회피<br>
join을 할 필요없이 하나의 doc 조회만으로 관련된 데이터를 전부 조회할 수 있습니다. 하지만 application 레벨에서 중복된 데이터들이 업데이트될 때마다 모두 최신 데이터를 유지하게끔 로직을 잘 작성해야합니다. <br>scale out에 유연하다.<br>
NoSQL은 서버 여러대로 하나의 클러스터를 구성하여 사용할 수 있습니다. 애초에 저장될 때 중복을 허용하는 (=join이 잘 일어나지 않는) 방향으로 하나의 doc안에 모든 정보를 때려넣다보니, 분산하여 저장하더라도 하나의 doc만 어떻게 잘 찾아오면 해결할 수 있기 때문에 여러대의 db로 나누어서 관리해도 좋습니다. <br>RDB의 경우 데이터를 분산하여 저장하게 될 경우 join시에 문제가 발생합니다. 하나의 비즈니스 로직을 처리할 때 여러 개의 테이블 정보가 필요하다고 가정해보겠습니다. 여러 개의 테이블은 여러개의 DB에 분산되어 저장되어 있습니다. 비즈니스 로직을 처리하기 위해서는 여러개의 테이블을 참조해야하고 이는 여러대의 db를 계속 반복해서 조회해야합니다. <br><br>즉 NoSQL은 ACID의 이점과 정규화 이점 일부를 포기하고 high throuput과 low latency, 스키마의 유연성을 추구하는 컨셉의 DB 입니다.]]></description><link>prj/cloudy/rdb와-nosql의-차이.html</link><guid isPermaLink="false">Prj/Cloudy/RDB와 NoSQL의 차이.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Wed, 05 Jun 2024 07:33:11 GMT</pubDate></item><item><title><![CDATA[Websocket]]></title><description><![CDATA[ 
 <br>OSI 7계층에 위치하는 프로토콜입니다. 4계층 TCP에 의존합니다. 하나의 TCP 커넥션이 맺어지면 실시간 양방향 통신을 지원합니다. HTTP와 달리 지속적인 연결을 사용하기 때문에 오버헤드가 적습니다. <br><br><img src="https://i.imgur.com/N1pM1UC.png" referrerpolicy="no-referrer"><br>1: 요청에서 Upgrade: websocket과 Connection: Upgrade 헤더를 추가합니다.<br>
2: 응답으로 101 상태와 함께 Upgrade: websocket, Connection Upgrade 헤더를 제공합니다. ]]></description><link>prj/code-odyssey/websocket.html</link><guid isPermaLink="false">Prj/Code Odyssey/Websocket.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 14 Jul 2024 11:55:29 GMT</pubDate><enclosure url="https://i.imgur.com/N1pM1UC.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/N1pM1UC.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[나도 오픈소스 하나쯤 내놔볼까]]></title><description><![CDATA[ 
 <br><br>
<br>개발자에서 아키텍트 
<br><br>
<br>원래 : 동작하는 프로그램 
<br>요즘 : 깃헙에 올릴 수 있는 내용 전부 

<br>도움말, 즐겨찾기 모음(awesome)<br>
-&gt; 대단한 철학으로 시작하기도 하지만, 배포 방식의 관점이 강함.<br>
-&gt; 지식을 함께 쌓아나감 


<br>Headver - 기술 명세서의 사례 : semver은 네이버와 라인 70여개 프로덕트에서 사용중 
<br><br>
<br>아키텍처가 좋아짐<br>
: 우리 회사에서만 사용하는 인프라 추상화 (기능의 추상화) - 뭐든지 하나쯤 더 추상화하게 됨<br>
: 보안키가 안전해진다. (좀 더 의식하게 됨)
<br>라이선스의 장도<br>
- 사용권리의 법무 체크 부담을 낮춘다.<br>
- 관계가 복잡한 회사에서 다른 법인이 개발한 소프트웨어를 쓰는 경우 
<br>지속가능성<br>
- 팀 내의 코드가 아닌, 회사 모두의 코드 -&gt; 회사 이름의 코드이기 때문에 남이 기여한 것을 수정하기 편함<br>
- 
<br><br>: 사용자의 의견을 수집하는 도구 <br>
<br>모노레포 - 터보레포 
<br><br>
<br>user voice라는 saas를 사용했었음<br>
-&gt; 라인 이직 후 해당 시스템이 없었음.<br>
-&gt; 개인정보에 민감한 회사에 saas를 도입하는 것은 쉽지 않음. + 비용 1000명 800달러<br>
-&gt; 까짓것 그냥 만들자 
<br>동료의 공감 실패 

<br>왜 필요하죠 
<br>vote 따라가느라 우리 서비스를 못만들음  =&gt; upvote 기능을 없앰 
<br>방치하는게 욕먹음 =&gt; 조회 기능 삭제함<br>
--&gt; 동료를 설득하지 못하면 고객도 설득하지 못함 


<br>-&gt; 내가 만들고 싶은 SW에 공감하지 않는 사람은 많다.<br><br>
<br>운영애서 막힘

<br>답변은 어떻게?
<br>피드백 관리는 어디서? 
<br>비용대비 효과가 나오나요??


<br>-&gt; 운영이 따르지 않으면 어려움 <br><br>
<br>오픈소스 릴리즈 -&gt; 회사 내 누군가는 쓰겠지 
<br>중요 설계 방침 

<br>쉬운 설치 (도커, npx, admin) =&gt; 기술 사용자 친화 
<br>데이터 레이어 분리 =&gt; 개인정보 문제 해결 


<br>-&gt; 오픈소스 만들 때 쉬운 설치 경험은 중요하다 <br><br>
<br>드디어 프로덕트 하나에 적용했다 

<br>배달원의 만족도를 KPI 중 하나로 설정(배달 시간, 건당 단가)
<br>KPI에 따라 필요한 전략으로 


<br>디테일한 피드백이 증가함 
<br>-&gt; 실전 경험이 중요하다 <br><br>
<br>다시 바닥부터 새로 만들기 :
<br>데이터 마이그레이션 진행 

<br>프로젝트 단위 추가 
<br>엘라스틱 서치 -&gt; 검색 강화 
<br>웹훅, 다국어 지원 


<br>-&gt; 오픈 소스 하나로 사용자 의견에 민감한 회사가 됨.<br>
-&gt; 프로덕트를 만드는 문화 개선 (사진)<br>-&gt; SW 하나가 의미를 만들기까지 5년이 걸리더라 <br>
<br>결과로 효과를 증명하는 과정이 필요하다 
<br>크래프톤, bosch 
<br>
<br><br>
<br>오픈 소스를 시작할 때 가장 중요한 것 -&gt; 마음가짐 
<br>
<br>
<br>아무도 나의 코드에 관심이 없다. 
<br>따봉은 의미가 없다.<br>
: 외부 반응에 집착하면 SW의 깊이를 잃어버린다.<br>
: 결국 힘있는 오픈소스는 규모가 어떻든 기능이 충실하면서 실제 사용자가 사용해야한다. 
<br><br>
<br>업무 하나만 자동화
<br>비슷한 업무 모두 자동화 1.5%
<br>다른 업무 환경까지 자동화 0.5%
<br><br><br>
<br>좋은 추상화 훈련임 
<br><br>
<br>유틸리티 라이브러리인지
<br>데이터에 의존되는 라이브러리인지
<br>API/CLI 애플리케이션 
<br>최종 사용자가 있는 앱 
<br><br>기술블로그 : LY 기술 블로그 <br>오픈소스 답게 소프트웨어 설계하기<br>
5년간 첫삽만 5번 뜬 오픈소스 궤도에 오르기까지 <br>인프콘 2024 : 성장하지 않아도 괜찮습니다. ]]></description><link>prj/conting/나도-오픈소스-하나쯤-내놔볼까.html</link><guid isPermaLink="false">Prj/Conting/나도 오픈소스 하나쯤 내놔볼까.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 12 Oct 2024 07:59:19 GMT</pubDate></item><item><title><![CDATA[콘팅의 대기열 서버가 장애를 극복하는 방법]]></title><description><![CDATA[ 
 ]]></description><link>prj/conting/콘팅의-대기열-서버가-장애를-극복하는-방법.html</link><guid isPermaLink="false">Prj/Conting/콘팅의 대기열 서버가 장애를 극복하는 방법.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 03 Aug 2024 03:36:11 GMT</pubDate></item><item><title><![CDATA[콘팅의 철저한 검표 시스템]]></title><description><![CDATA[ 
 ]]></description><link>prj/conting/콘팅의-철저한-검표-시스템.html</link><guid isPermaLink="false">Prj/Conting/콘팅의 철저한 검표 시스템.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 06 Jun 2024 14:16:05 GMT</pubDate></item><item><title><![CDATA[콘팅의 AuthCapturePattern 도입기]]></title><description><![CDATA[ 
 ]]></description><link>prj/conting/콘팅의-authcapturepattern-도입기.html</link><guid isPermaLink="false">Prj/Conting/콘팅의 AuthCapturePattern 도입기.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 06 Jun 2024 14:15:35 GMT</pubDate></item><item><title><![CDATA[콘팅이 서비스를 잘게 쪼갠 이유]]></title><description><![CDATA[ 
 <br><br><br><img src="https://i.imgur.com/GT8yXth.png" referrerpolicy="no-referrer"><br><br>티케팅 서비스에서 가장 많은 트래픽이 발생하는 비즈니스 로직은 예매 과정이라 생각합니다. 저희 백엔드 팀의 목표는 예매 과정에서 최대한의 가용성을 보장하도록 시스템을 설계하고자 했습니다.<br>먼저 예매시 유저 플로우를 분석하였습니다.<br>먼저 콘팅의 예매시 유저 플로우를 알아보겠습니다. 다음과 같은 유저 플로우를 가집니다.<br>
<img src="https://i.imgur.com/BCFDYeB.png" referrerpolicy="no-referrer"><br><img src="https://i.imgur.com/FdOfVkH.png" referrerpolicy="no-referrer"><br>짧은 시간동안 여러 페이지를 옮겨 다니면서 다양한 API를 호출합니다. 해당 플플로우에서는 짧은 시간 내에 DB IO, Network IO가 대량으로 일어납니다. 짧은 시간 동안 시스템에서 일어나는 IO의 양이 많을 경우 가장 좋은 해결책은 비동기 방식이라 생각했습니다.<br>&lt;결제/티켓&gt; 도메인을 따로 분리한 이유<br>하지만 결제 시스템을 비동기 방식으로 적용하기에는 리스크가 크다고 생각했습니다. 국내 결제 시스템 특성상 PG 사와의 통신을 통해 결제 로직이 구현되고 관련된 트랜잭션을 고려한다면, 비동기는 적합하지 않습니다.<br>그렇다고 같은 프로젝트 내에서 r2dbc(비동기 방식 ORM)와 jpa(동기 방식 ORM)를 동시에 사용할 경우 각 구현체는 서로 다른 패키지에 포함되어야만하고 설정 클래스에서도 컴포넌트 스캔할 대상을 일일히 지정해야했기 때문에 코드간 결합성이 증가하고 유지보수하기가 어려워집니다.<br>R2DBC와 JPA/JDBC 용 repo를 같은 패키지 내에 배치하면 한쪽 Repo를 못찾거나 지원 예외가 발생합니다. 때문에 아래 코드와 같이 repo패키지를 분리후 각각의 repo 패키지를 설정해야합니다. 위 같은 방식은 repo의 개수가 늘어날 때마다 Config 클래스에 불필요한 보일러 플레이트를 생성합니다. 특히 레이어별로 정리한 폴더구조가 아닌 도메인별로 정리한 폴더 구조일 경우 *의 활용도 불가능합니다. <br>@EnableJpaRepositories("com.c209.payment.domain.order.repository.sync")
@EnableR2dbcRepositories("com.c209.payment.domain.order.repository.async")
<br>로직에 알맞은 비동기 방식, 동기 방식을 구현하고, 코드의 유지보수성을 늘리고 확장성을 고려하여 “좌석”과 “결제/티켓” 도메인을 분할하였습니다.<br>대기열 서비스를 추가한 이유<br>
<img src="https://i.imgur.com/7Dcvgzu.png" referrerpolicy="no-referrer"><br>동기 방식을 채택한 “결제/티켓” 서비스의 핵심은 일정 트래픽이 넘지 않도록 제한해야합니다. 서비스 특성상 특정시간(예매 가능시간)이 되면 스파이크성 트래픽이 발생합니다. 스파이크성 트래픽이 발생할 경우, 동기 방식에서 치명적이라 판단하였습니다. 스파이크성 트래픽이 결제 서비스에 발생하는 것을 방지하기 위해, 대기열 서버를 추가하였습니다. 결제시 유저 플로우는 다음과 같이 바뀝니다.<br><img src="https://i.imgur.com/QLW8HpK.png" referrerpolicy="no-referrer"><br>결제와 티켓 도메인을 분할한 이유<br>서비스 특성상 결제와 티켓 발행 로직은 같은 서비스에 처리하여 트랜잭션을 보장하는 것이 맞습니다. 하지만 콘팅에서는 QR 기반 티켓을 제공합니다. 티켓의 검표과정 또한 처리해야하기 때문에 다음과 같은 특수한 상황에서 문제가 발생합니다.<br>A 가수의 공연 예매일과 B가수의 공연 당일이 겹쳤을 경우 
<br>A가수의 공연을 예매하기 위해서 결제 API가 요청이, B가수의 티켓 검표를 진행하기 위해 티켓 API 요청이 동시에 발생합니다. 위와 같은 상황을 가정했을 때, 티켓 서비스와 결제 서비스를 안정적으로 처리하기 위해 두 서비스를 분리하였습니다.<br><br><br>서비스를 분할할수록 비즈니스 로직에 따라 서비스 간의 데이터 정합성을 맞추는 것이 중요합니다.<br>
<br>kafka를 활용한 비동기 큐로 결제서비스가 pub, 좌석 서비스와 티켓서비스가 Sub으로 구현하였습니다. 결제 발생시 좌석 서비스에서는 결제된 좌석이&nbsp;사용 불가능한 좌석으로 업데이트, 티켓 서비스는&nbsp;구매 유저와 좌석 정보를 바탕으로 티켓을 생성합니다.
<br>최종 결제 수행 전 webhook을 활용해 해당 좌석이&nbsp;여전히 구매 가능한 좌석인지 좌석 서비스에서 조회하는 로직을 추가했습니다.
<br><br>콘팅에서는 카프카를 비동기 메시징 큐로 활용합니다. 카프카는 분산 스트리밍 플랫폼으로, 대량의 데이터를 처리하고 실시간으로 전송하는 데 사용합니다. 모든 데이터는 로그 형식으로 파일 시스템에 기록됩니다. 시간순으로 완전히 정렬된 데이터 흐름(=레코드 시퀀스)를 보장합니다. 로그를 한곳에 모아 처리할 수 있도록 중앙집중화되어 있으며, 대용량 데이터를 수집하고 실시간 스트리밍으로 소비할 수 있습니다. <br>레코드는 프로듀서가 보낸 순서로 기록되어 순서가 보장됩니다. 레코드의 위치(offset)으로 컨슈머가 소비한 메시지의 위치를 표시합니다. 각 컨슈머 그룹마다 레코드의 위치를 가지고 있기 때문에 같은 소스에서 서로 다른 여러 개의 컨슈머들이 개별적으로 소비할 수 있습니다. 한 소스에서 여러 소비자가 손실이나 변형 없이 메시지를 소비할 수 있습니다. <br><img src="https://i.imgur.com/zefHRap.png" referrerpolicy="no-referrer"><br><br><br>결제와 티켓 발급을 처리하는 방식으로 분산 시스템 이벤트 기반 아키텍처를 사용하고 있습니다. 콘팅의 분산시스템이 어떻게 나뉘어 있는지 간략하게 설명하고, 카프카를 팀에서 활용하는 방식을 소개하겠습니다. <br>결제 이벤트를 받아 티켓을 발급하는 로직, 결제 이벤트를 받아 <br><br>DB가 분리되면서 편하게 join이 불가능해집니다. join 쿼리가 발생할 경우 network io가 추가로 발생하게 됩니다. 관련해서 문제가 발생하는 API가 있었습니다. 바로 내가 가지고 있는 입장권 조회입니다.<br>
<img src="https://i.imgur.com/JO9ZjAV.png" referrerpolicy="no-referrer"><br>내가 가진 입장권을 출력하기 위해서는 티켓 서비스에서 user_id로 내가 가진 티켓 정보(공연 id, 좌석 id)를 조회해와야합니다.<br>
<img src="https://i.imgur.com/8ds8OTw.png" referrerpolicy="no-referrer"><br>select seat_id, performance_id from ticket where user_id = :userId
<br>조회해온 seat_id와 performance_id로 카탈로그 서비스 API에서 공연 정보를 조회해야합니다.<br>select {공연 메타데이터 칼럼들} from performance 
where performance_id in {앞선 쿼리에서 조회한 performance_id들}
<br>보시는 바와 같이, 서비스간 결합성이 생기고 불필요한 네트워크 IO와 DB IO가 발생합니다. 이를 해결하기 위해서 모바일 로컬 DB인 Realm을 활용했습니다.<br>스플래시 화면에서 공연 정보를 먼저 조회해와 realm에 저장합니다.<br>
<img src="https://i.imgur.com/clIDFvq.png" referrerpolicy="no-referrer"><br>사용자가 입장권 페이지에 접속할 때는 단순히 티켓 서비스에서 내가 가지고 있는 티켓의 공연 id만 조회해온 후 realm에서 공연 데이터를 찾아 페이지를 렌더링하는 방식으로 구현했습니다.<br><img src="https://i.imgur.com/MXyEUyE.png" referrerpolicy="no-referrer">]]></description><link>prj/conting/콘팅이-서비스를-잘게-쪼갠-이유.html</link><guid isPermaLink="false">Prj/Conting/콘팅이 서비스를 잘게 쪼갠 이유.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 08 Jun 2024 04:21:55 GMT</pubDate><enclosure url="https://i.imgur.com/GT8yXth.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/GT8yXth.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[프로그래머는 겸손한가]]></title><description><![CDATA[ 
 <br><br><br>
<br>goto문의 해로움 
<br>지나치게 도전적인 프로그래밍 작업의 문제를 위기로 선언, 해결방안 제시 
<br><br>
<br>1970년대 

<br>프로그램을 메모리에 저장해뒀다가 실행하는 컴퓨터의 등장 
<br>컴퓨터 보급의 시점 (이전까지는 수제작)


<br>프로그래밍은 사람의 행동이다 
<br><br><br>
<br>컴퓨터 역사를 정리하며 SW에 대한 이해가 얼마나 미숙한지 고발 
<br>하드웨어 중심의 발전 : 1970년대만 하더라도 컴퓨터는 하루에 7시간만 동작함 
<br>히든 피겨스 
<br>성능이 빈약한 컴퓨터의 한계를 극복하는 기교에 만족함 
<br><br>
<br>복잡하게 꼬인 문제를 즐기고 교모한 기교를 좋아함 
<br>어떤 식으로든 계산 절차의 효율성을 최적화 하는 일에 불과하다 
<br><br>
<br>천배 이상 강력한 컴퓨터 등장 
<br>그보다 강해진 사회적 야망이 등장 
<br><br>
<br>서브 루틴 라이브러리 

<br>추상화의 기본 패턴 중 하나가 구현 가능해짐. 


<br>포트

<br>


<br><br>
<br>기본 도구인 프로그래밍 언어가 그 자체로 인간의 지적 통제를 벗어남 
<br><br>
<br>적은 노력으로도 시스템 프로그래밍이 가능 
<br>버그가 거의 없어야함 
<br>SW에서 비용과 품질은 상호보완적인 관계, 어느한쪽을 추구하면 나머지 한쪽도 자연스럽게 달성함 
<br><br>
<br>사회 전반적인 필요성 인정 -&gt; 더 높은 신뢰성의 SW 필요 
<br>충분히 강력한 경제적 필요성 -&gt; 일단 유지보수가 편해야한다. 
<br><br>
<br>프로그램의 종류와 구현마다 지적 관리성이 천차만별이다. 
<br>규칙은 두가지 종류 

<br>기계적으로 쉽게 규제가 가능하다. (타입체크가 가능한 언어)
<br>규제방법이 없어서 스스로 준수하려고 노력해야함 


<br><br><br><br>
<br>테스트는 버그가 없음을 보여주는데는 적절하지 않다.
<br>프로그래머는 정확성을 증명과 함께 프로그램을 함께 자라나게 해야한다. 

<br>증명 요건을 충족하는 프로그램을 구축하는 것을 반복 


<br><br>
<br>유한한 추론으로 무수히 많은 경우를 다룰 수 있는 정신적 도구 
<br>추상화의 목적은 절대적으로 명확한 새로운 의미를 만드는 것 
<br>객체지향의 추상화는 일반화 
<br>여기서 말하는 추상화는 OSI7레벨 같이 상위 레벨에서 새로운 환경을 제공함 
<br><br>
<br>도구, 언어, 표기법 : 생각이나표현을 결정짓는 주요 요인 
<br>똑똑하다고 자랑하는 사람들이 빠지는 트릭 

<br>경쟁적으로 더 적은 코드로 동작하는 코드 
<br>암호 같은 코드 


<br><br>
<br>잘 팩토링된 해결책
<br>계층구조 설계 
<br><br>명령형 -&gt; 절차형 -&gt; 구조적 -&gt; 객체 지향 -&gt;<br>
goto 문 말고 특정 패턴의 조합으로만 모든 논리를 표현할 수 있음을 증명함. <br>
<br>
구조적 동시성 

<br>
구조적 메모리관리 (러스트의 소요 스위프트)

<br>
사회는 프로그래머를 이해하지 못하고 우리 자신도 프로그래머를 이해하지 못한다. 

<br><br>
<br>
60년 만에 세계적인 규모로 서비스를 제공할 수 있는 컴퓨터 기술이 완성됨 

<br>
속도에 밀려 후순위로 다루어지는 SW 품질 

<br>
모니터링과 가관측성을 통한 사후 대응 

<br>
맨먼스머신 

<br>
새로운것을 받아들이지 않는 이유 -&gt; 사람은 바뀌지 않는다. 

<br>세대가 지나야하는 이유는 사용하는 사람이 은퇴하거나 죽어야하기 때문 


]]></description><link>prj/conting/프로그래머는-겸손한가.html</link><guid isPermaLink="false">Prj/Conting/프로그래머는 겸손한가.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 12 Oct 2024 09:01:46 GMT</pubDate></item><item><title><![CDATA[Next Goal.]]></title><description><![CDATA[ 
 <br><br><br>dayshoursminutesseconds프로그래머스 코딩전문역량인증 시험 [PCCP]<br><br>dayshoursminutesseconds정보처리기사 필기 시험 접수]]></description><link>prj/conting/goal.html</link><guid isPermaLink="false">Prj/Conting/Goal.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 04:19:31 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 ]]></description><link>prj/conting/index.html</link><guid isPermaLink="false">Prj/Conting/index.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 02 Jun 2024 02:03:57 GMT</pubDate></item><item><title><![CDATA[OAuth 2.0 Grant Type]]></title><description><![CDATA[ 
 <br><br><br><br>
권한부여란 클라이언트가 사용자를 대신하여 사용자의 승인 하에 인가서버로부터 권한을 부여 받는 것을 의미합니다. 
<br><br><br><img src="https://i.imgur.com/tH8wk0z.png" referrerpolicy="no-referrer"><br><br><br><br><br>흐름<br>
1: 인가서버에게 code를 요청<br>
<img src="https://i.imgur.com/WHI2uf0.png" referrerpolicy="no-referrer"><br>
2: 사용자의 승인 후 인가서버가 클라이언트에게 코드를 발급한다.<br>
<img src="https://i.imgur.com/6XFPToo.png" referrerpolicy="no-referrer"><br>3: 앱은 해당 임시 코드를 인가서버로 전달하고 액세스 토큰으로 교환한다.<br>
<img src="https://i.imgur.com/fh7yw0S.png" referrerpolicy="no-referrer"><br>특징<br>
1: 앱이 액세스 토큰을 요청 시, 해당 요청을 클라이언트 암호로 인증할 수 있습니다.<br>
-&gt; 공격자가 인증 코드를 가로채 스스로 사용할 위험이 줄어듭니다.<br>
2: 액세스 토큰이 클라이언트에 표시되지 않습니다.<br>
-&gt; 토큰이 다른 사람에게 노출될 확률이 줄어듭니다. <br>권한 부여 요청 시 필요한 매개변수 <br><br>액세스 토큰 교환 요청 시 매개변수 <br><br><br>코드 교환을 위한 증명 키로서 CSRF 및 권한부여코드 삽입 공격을 방지하기 위한 Authorization Code Grant Flow의 확장 버전입니다. 권한부여코드 요청 시 Code Verifier와 Code Challenge를 추가하여 만약 Authorization Code Grant Flow에서 Authorization Code가 탈취당했을 때, 액세스 토큰을 발급 받지 못하도록 차단합니다. 모든 유형의 OAuth2 클라이언트, 심지어 웹서버 양측 모두 유용합니다. <br><br>Code Verifier<br>
권한부여코드 요청 전 앱이 원래 생성한 PKCE 요청에 대한 코드 검증기입니다. 48~128 글자수를 가진 무작위 문자열이며, A-Z,a-z,0-9의 아스키 문자로만 구성됩니다. <br>Code Challenge<br>
선택한 Hash 알고리즘으로 Code Verifier를 Hashing한 후 Base64 인코딩을 한 값입니다. <br>Code Challenge Method<br>
plain : Code Verifier가 특정한 알고리즘을 사용하지 않도록 설정합니다.<br>
S256 : Code Verifier 해시 알고리즘을 사용하도록 설정합니다. ]]></description><link>spring/oauth-2.0/oauth-2.0-grant-type.html</link><guid isPermaLink="false">Spring/OAuth 2.0/OAuth 2.0 Grant Type.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Tue, 02 Jul 2024 15:33:34 GMT</pubDate><enclosure url="https://i.imgur.com/tH8wk0z.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/tH8wk0z.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OAuth 2.0이란]]></title><description><![CDATA[ 
 <br><br><br>Open + Authorization의 약자입니다. OAuth 2.0인가 사용자가 속한 사이트의 보호된 자원에 대해 앱의 접근을 허용하도록 승인하는 것을 의미합니다. RFC표준 6749에서 처음 등장하였습니다. <br>인가서버가 애플리케이션에게 권한을 부여합니다. <br><br><br><img src="https://i.imgur.com/ulSOeLn.png" referrerpolicy="no-referrer"><br>
<br>해당하는 계정을 로그인하는 창을 띄운다. 
<br>id와 비밀번호를 입력받아 그대로 공급자(google, naver, kakao)에게 post요청을 보낸다. 
<br><br>
<br>아이디와 패스워드가 노출됩니다. 
<br>공급자의 모든 서비스를 제한없이 사용할 수 있습니다. 
<br>클라이언트 어플리케이션을 신뢰할 수 있는가? 
<br><br><img src="https://i.imgur.com/7CNOey1.png" referrerpolicy="no-referrer"><br><br>인가 서버의 역할을 할 수 있도록 제공하는 오픈소스입니다. 사용자 관리뿐만 아니라 토큰을 발급하고 토큰을 검증하는 기능까지 수행할 수 있도록, 기능을 제공합니다. <br><br><a rel="noopener nofollow" class="external-link" href="https://www.keycloak.org/downloads" target="_blank">https://www.keycloak.org/downloads</a><br>1: keycloack내부 bin 폴더 내부 kc.bat을 실행한다. <br>.\kc.bat start-dev
<br>2: localhost:8080으로 접속한 후 admin 계정을 생성합니다.<br>
<img src="https://i.imgur.com/duTW2yz.png" referrerpolicy="no-referrer"><br>3: 계정을 생성한 후 로그인하여 접속합니다. <br>4: realm을 생성합니다.<br>
<img src="https://i.imgur.com/NbKZfkm.png" referrerpolicy="no-referrer"><br>5: 생성한 realm에서 client를 생성합니다.<br>
<img src="https://i.imgur.com/z3VsBhT.png" referrerpolicy="no-referrer"><br>
<img src="https://i.imgur.com/GlaRc0c.png" referrerpolicy="no-referrer"><br>
<img src="https://i.imgur.com/f83DjPJ.png" referrerpolicy="no-referrer"><br>6: redirect url을 지정합니다.<br>
<img src="https://i.imgur.com/F8e8cWP.png" referrerpolicy="no-referrer"><br>
<img src="https://i.imgur.com/BrnOuVM.png" referrerpolicy="no-referrer"><br>7: user를 생성합니다.<br>
<img src="https://i.imgur.com/deTpGO4.png" referrerpolicy="no-referrer"><br>8: user의 비밀번호를 생성합니다.<br>
<img src="https://i.imgur.com/F07ez4H.png" referrerpolicy="no-referrer"><br><br><img src="https://i.imgur.com/T75j0P6.png" referrerpolicy="no-referrer"><br><br>
<br>보호된 자원에 대한 접근 권한을 부여할 수 있는 주체입니다. 
<br>사용자로서 계정의 일부에 대한 접근 권한을 부여할 수 있습니다. 
<br>사용자를 대신하여 작동하려는 모든 클라이언트는 먼저 사용자의 허가를 받아야합니다. 
<br><br>
<br>우리 어플리케이션이 접근하는 사용자의 자원이 포함된 서버를 의미합니다. 
<br>액세스 토큰을 수락 및 검증할 수 있어야 하며 권한 체계에 따라 요청을 승인할 수 있어야합니다. 
<br><br>
<br>클라이언트가 사용자 계정에 대한 동의 및 접근을 요청할 때 상호 작용하는 서버입니다. 
<br>클라이언트의 권한 부여 요청을 승인하거나 거부하는 서버입니다. 
<br>사용자가 클라이언트의 권한 부여 요청을 승인한 후 access token을 클라이언트에게 부여합니다. 
<br><br>
<br>사용자를 대신하여 권한을 부여받아 사용자의 리소스에 접근하는 앱입니다. 
<br>사용자를 권한 부여 서버로 안내하거나, 사용자의 상호작용없이 권한 부여 서버로부터 직접 권한을 얻을 수 있습니다. 
<br><br>1: postman에 다음 요청을 입력합니다. <br>http://localhost:8080/realms/oauth2/protocol/openid-connect/auth?resource_type=code&amp;client_id=oauth2-client-app&amp;scope=profile email&amp;redirect_url=http://localhost:8081
<br><img src="https://i.imgur.com/OBECnIl.png" referrerpolicy="no-referrer"><br>2: 로그인 페이지로 이동하여 로그인을 진행합니다. <br>3: 로그인을 완료하면 사용할 수 있는 토큰을 url을 통해 전달 받습니다.<br>4: 토큰을 이용해 권한(jwt토큰)을 최종 획득합니다. <br>http://localhost:8080/realms/oauth2/protocol/openid-connect/token?grant_type=authorization_code&amp;client_id&amp;client_secret&amp;redirect_url&amp;code
<br><img src="https://i.imgur.com/osEFQHN.png" referrerpolicy="no-referrer"><br>5: 사용자 정보를 가져와 봅니다. <br><br><img src="https://i.imgur.com/ZdZSyPB.png" referrerpolicy="no-referrer"><br>인증 서버에 유저를 등록할 때 자격증명을 위해 클라이언트 id와 클라이언트 암호를 받습니다. 클라이언트 ID와 암호를 이용해 자격을 증명하는데, 클라이언트 암호는 비밀, 클라이언트 ID는 공개할 수 있습니다. <br><br>일반적으로 사용자가 소스 코드에 액세스할 수 없는 서버에서 실행되는 응용 서버입니다. (=백엔드 애플리케이션) 이러한 유형의 애플리케이션은 대부분 웹 서버에서 실행되기 때문에 일반적으로는 웹앱이라고 합니다.<br><br>크롬 개발자 도구, 디스어셈블러와 같은 디버깅 도구를 사용해 바이너리나 실행 코드에서 민감 정보를 추출할 수 있기 때문에 공개로 간주됩니다. 브라우저에서 실행되는 Java Script 애플리케이션, Android 또는 iOS 모바일 앱, 데스크톱에서 실행되는 기본 앱, IoT/임베디드 애플리케이션 등이 있습니다. <br><br><br>보호된 리소스에 접근하기 위해 사용하는 자격증명입니다. 일반적으로 JWT 형식을 취하지만, 반드시 그럴 필요는 없습니다. 토큰 내부에는 액세스 기간, 범위 및 서버에 필요한 기타 정보가 존재합니다. <br><br><img src="https://i.imgur.com/1Aqq2yL.png" referrerpolicy="no-referrer"><br>
<img src="https://i.imgur.com/rfe9MAQ.png" referrerpolicy="no-referrer"><br>인가 서버는 DB에 토큰의 내용을 저장하고, ID만 클라이언트에게 반환합니다.<br>
토큰을 수신하는 API는 토큰의 유효성을 검증하기 위해 DB를 조회해야합니다. <br><br><img src="https://i.imgur.com/Uw1erwR.png" referrerpolicy="no-referrer"><br>
<img src="https://i.imgur.com/On6ka9X.png" referrerpolicy="no-referrer"><br>JWT 토큰 형식으로 발급되며, 클레임과 만료가 있는 보호된 자료구조입니다. 리소스 서버의 검증 키만 알아도 발급자와 통신할 필요 없이 토큰의 유효성을 검증할 수 있습니다. 특정한 암호화 알고리즘에 의해 개인키로 서명되고 공개키로 검증할 수 있으며, 만료될 때까지 유효합니다. <br><br>액세스 토큰이 만료된 경우 Refresh Token의 유효성을 검사, 통과할 경우 새 AccessToken을 발급합니다. Refresh Token은 액세스 토큰과 달리 서버 토큰 엔드 포인트에만 보내지고 리소스 서버에는 보내지 않습니다. <br><br><br><img src="https://i.imgur.com/7vz9W8t.png" referrerpolicy="no-referrer"><br>권한 부여 코드 흐름에서 사용하며, 이 코드는 액세스 토큰과 교환되는 임시 코드입니다. ]]></description><link>spring/oauth-2.0/oauth-2.0이란.html</link><guid isPermaLink="false">Spring/OAuth 2.0/OAuth 2.0이란.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Mon, 01 Jul 2024 13:49:03 GMT</pubDate><enclosure url="https://i.imgur.com/ulSOeLn.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/ulSOeLn.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[소셜 로그인 구현하기]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="https://console.cloud.google.com/welcome?pli=1&amp;project=login-demo-380814" rel="noopener nofollow" class="external-link" href="https://console.cloud.google.com/welcome?pli=1&amp;project=login-demo-380814" target="_blank">구글 클라우드 콘솔</a>으로 접속하여 설정을 진행합니다. <br>상단의 [새프로젝트]를 클릭하여 프로젝트를 생성합니다.<br>
<img src="https://i.imgur.com/1OFEIAu.png" referrerpolicy="no-referrer"><br>이름을 설정하여 최종 생성을 진행합니다.<br>
<img src="https://i.imgur.com/Ssaj3WL.png" referrerpolicy="no-referrer"><br>[좌상단 햄버거 버튼 클릭] - [API 및 서비스] - [OAuth 동의 화면] 클릭, 외부 옵션을 체크 후 [만들기] 클릭<br>
<img src="https://i.imgur.com/iHm5zgz.png" referrerpolicy="no-referrer"><br>다음 화면에 접속하여 사용자에게 보여줄 로그인 화면을 만듭니다.<br>
<img src="https://i.imgur.com/op6MtOw.png" referrerpolicy="no-referrer"><br>[범위 추가 또는 삭제]를 클릭하여 제공받을 유저 정보의 scope를 설정해야합니다. 이 예제에서는 이메일과 프로필, 오픈아이디를 사용합니다. 체크한 후 밑의 [업데이트]를 클릭하여 반영합니다.<br>
<img src="https://i.imgur.com/LqgCv8i.png" referrerpolicy="no-referrer"><br>이후 테스트 사용자와 요약페이지는 건너뜁니다. <br>[사용자 인증 정보] - [사용자 인증 정보 만들기] - [OAuthClientID]를 클릭합니다.<br>
<img src="https://i.imgur.com/QpucyVE.png" referrerpolicy="no-referrer"><br>애플리케이션 유형을 웹 애플리케이션, redirection url을 설정합니다.<br>
<img src="https://i.imgur.com/hCXCDru.png" referrerpolicy="no-referrer"><br>생성된 클라이언트 ID와 보안 비밀번호를 확인하고 다른 파일에 복사해둡니다. <br><br><a data-tooltip-position="top" aria-label="https://developers.naver.com/main/" rel="noopener nofollow" class="external-link" href="https://developers.naver.com/main/" target="_blank">네이버 개발자 센터</a>으로 이동합니다.<br>[Applicaion] - [애플리케이션 등록]으로 이동합니다.<br><img src="https://i.imgur.com/KIzkTl6.png" referrerpolicy="no-referrer"><br>[사용 API] - [네이버 로그인] 클릭한 후 다음과 같이 설정을 진행합니다.<br>
<img src="https://i.imgur.com/2so4IYr.png" referrerpolicy="no-referrer"><br>
<img src="https://i.imgur.com/HqyrfZv.png" referrerpolicy="no-referrer"><br>클라이언트 ID와 시크릿을 확인합니다.<br>
<img src="https://i.imgur.com/ety1SLT.png" referrerpolicy="no-referrer"><br><br><br><br>public interface ProviderUser {  
  
    public String getId();  
    public String getUsername();  
    public String getPassword();  
    public String getEmail();  
    public String getProvider();  
    public List&lt;? extends GrantedAuthority&gt; getAuthorities();  
    public Map&lt;String, Object&gt; getAttributes();  
  
}
<br>인터페이스로 기본 로직에 대한 골격을 작성합니다. <br><br>@Data  
public abstract class OAuth2ProviderUser implements ProviderUser {  
  
    private Map&lt;String, Object&gt; attributes;  
    private OAuth2User oAuth2User;  
    private ClientRegistration clientRegistration;  
  
    public OAuth2ProviderUser(Map&lt;String, Object&gt; attributes, OAuth2User oAuth2User, ClientRegistration clientRegistration){  
        this.attributes = attributes;  
        this.oAuth2User = oAuth2User;  
        this.clientRegistration = clientRegistration;  
    }  
  
    @Override  
    public String getPassword() {  
        return UUID.randomUUID().toString();  
    }  
  
    @Override  
    public String getEmail() {  
        return (String)attributes.get("email");  
    }  
  
    @Override  
    public String getProvider() {  
        return clientRegistration.getRegistrationId();  
    }  
  
    @Override  
    public List&lt;? extends GrantedAuthority&gt; getAuthorities() {  
        return oAuth2User.getAuthorities().stream().map(authority -&gt; new SimpleGrantedAuthority(authority.getAuthority())).collect(Collectors.toList());  
    }  
}
<br>추상 클래스를 활용해 공통 로직의 구현부를 미리 정의합니다.<br><br>public class GoogleUser extends OAuth2ProviderUser {  
  
    public GoogleUser(OAuth2User oAuth2User, ClientRegistration clientRegistration){  
        super(oAuth2User.getAttributes(), oAuth2User, clientRegistration);  
    }  
  
    @Override  
    public String getId() {  
        return (String)getAttributes().get("sub");  
    }  
  
    @Override  
    public String getUsername() {  
        return (String)getAttributes().get("sub");  
    }  
  
}
<br>각 벤더에 맞게끔 user 정보를 담을 구현체를 정의합니다. google의 경우 user정보로 id와 username을 제공하기 때문에 위와 같이 정의합니다. ]]></description><link>spring/openid/소셜-로그인-구현하기.html</link><guid isPermaLink="false">Spring/OpenID/소셜 로그인 구현하기.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 06 Jul 2024 13:27:34 GMT</pubDate><enclosure url="https://i.imgur.com/1OFEIAu.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/1OFEIAu.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[<strong>Open ID</strong>]]></title><description><![CDATA[ 
 <br><br><br>OAuth 2.0 프로토콜을 확장한 인증 프로토콜입니다. 클라이언트 앱이 사용자의 정보(이메일, 프로필, 이름 등등)에 접근할 수 있도록 권한을 부여 받을 수 있습니다.<br><br><br>정의 : 사용자가 자신이 누구인지 확인하는 과정입니다.<br>
방법 : 로그인, 지문 인식, OTP 등<br>
-&gt; 신원 확인 <br><br>정의 : 인증된 사용자가 특정 자원이나 기능에 접근할 수 있는 권한을 부여받는 과정입니다.<br>
방법 : 관리자 페이지 접근, 프리미엄 회원에게 제공하는 특수 기능<br>
-&gt; 권한 확인 <br><br>인증은 사용자가 누구인지 확인하는 과정이고, 인가는 확인된 사용자 정보를 바탕으로 사용자가 무엇을 할 수 있는지 확인하는 과정입니다. 즉, 인증이 완료되어야만 인가가 가능해집니다. <br><br><img src="https://i.imgur.com/2TROtDc.png" referrerpolicy="no-referrer"><br><br>OAuth 2.0이란?<br>
리소스 소유자(실제 유저)로 부터 권한을 위임받은 클라이언트 애플리케이션이 리소스 서버에서 보호된 리소스에 접근할 수 있도록 허용하는 인가 프레임워크입니다. 즉 앱이 사용자의 자원에 접근할 수 있도록 권한을 부여하는 것입니다. <br>작동 방식은 다음과 같습니다.<br>
1: 클라이언트(내 웹)가 리소스 소유자(실제 사용자)의 승인을 받아 인가 서버(=구글 OAuth)로부터 액세스 토큰을 발급 받습니다.<br>
2: 클라이언트는 이 액세스 토큰을 사용하여 리소스 서버(=구글 드라이브)에 보호된 리소스에 접근합니다. <br><br>ODIC란?<br>
OAuth 2.0을 기반으로한 인증 프로토콜입니다. OAuth 2.0의 인가 기능 외에도 사용자 인증을 처리합니다. 사용자의 신원을 확인하고 사용자 정보 (ID 토큰)을 안전하게 교환합니다. <br>작동 방식은 다음과 같습니다.<br>
1: 사용자는 OpenID Connect Provider(Goolge, naver, kakao)(이하 OP)에 인증 요청을 보냅니다.<br>
2: 인증이 성공하면 OP는 클라이언트에 ID 토큰과 액세스 토큰을 반환합니다.<br>
3: 클라이언트는 ID 토큰을 사용해 사용자의 신원을 확인할 수 있습니다. <br><br>ID 토큰은 사용자가 인증되었음을 증명하는 결과물입니다. OIDC 요청시 access token과 함께 JWT 형태로 클라이언트에 전달됩니다. ID 토큰은 개인 키로 발급자가 서명하고, 앱은 공개 키로 ID 토큰의 유효성을 검사합니다. 또한 클라이언트는 클레임 정보에 포함되어 있는 사용자명, 이메일을 활용해 인증 관리를 할 수 있습니다. <br><br><img src="https://i.imgur.com/vesdmtA.png" referrerpolicy="no-referrer"><br><br>Google OAuth와 OpenID Connect 예시<br>
사용자가 클라이언트 애플리케이션에 Google 계정으로 로그인할 때, OpenID Connect를 통해 ID 토큰과 액세스 토큰을 발급받습니다.<br>ID 토큰: 클라이언트 애플리케이션이 사용자의 신원을 확인하는 데 사용됩니다(예: 사용자의 이메일 주소, 이름 등).<br>
액세스 토큰: 클라이언트 애플리케이션이 Google 드라이브 API를 호출하여 사용자의 파일에 접근할 때 사용됩니다.<br>Facebook 로그인 예시<br>
사용자가 모바일 애플리케이션에 Facebook 계정으로 로그인할 때, Facebook 인가 서버가 액세스 토큰을 발급합니다.<br>액세스 토큰: 애플리케이션이 Facebook Graph API를 통해 사용자의 친구 목록, 사진 등에 접근할 때 사용됩니다.<br><br>스코프는 클라이언트가 요청하는 권한의 범위를 지정하는 변수입니다. 클라이언트가 ID 토큰을 통해 접근할 수 있는 리소스와 정보를 명시적으로 제한하고 제어합니다. 공백으로 구분된 문자열의 리스트로 저장합니다. <br><img src="https://i.imgur.com/132iviN.png" referrerpolicy="no-referrer"><br><br><br><br><br>줄여서 OP라고 하며 OpenID 제공자로서 사용자를 인증하고 인증 결과와 사용자 정보를 신뢰 당사자에게 제공할 수 있는 OAuth 2.0 서버를 의미합니다. <br><br>줄여서 RP라고 하며 신뢰 당사자로서, 인증 요청을 처리하기 위해 OP에 의존하는 Oauth 2.0 애플리케이션을 의미합니다. <br><br>1: RP는 OP에 권한 부여 요청을 보냅니다.<br>
2: OP는 최종 사용자를 인증하고 권한을 얻습니다.<br>
3: OP는 권한을 ID 토큰과 액세스 토큰으로 응답합니다.<br>
4: RP는 Access Token을 사용하여 User의 정보를 제공하는 API에 요청을 보낼 수 있습니다.<br>
5: 유저의 정보를 제공하는 API는 최종 사용자에 대한 클레임을 반환합니다. <br><br><img src="https://i.imgur.com/hcRmqXc.png" referrerpolicy="no-referrer"><br>
요청시 주의사항<br>
1: 요청시 openid 범위를 scope에 포함합니다.<br>
2: response_type은 id_token을 포함하며, response_type이 해당 토큰을 지원해야합니다.<br>
3: 요청시 nonce를 포함해야합니다.<br>nonce란?<br>
id_token 값에 클레임으로 포함되며, 토큰의 재생 공격을 방지하고 요청의 출처를 식별하는데 사용할 수 있는 고유 문자열입니다. 응답 nonce에는 요청에서 nonce와 같은 값이어야 합니다.]]></description><link>spring/openid/open-id.html</link><guid isPermaLink="false">Spring/OpenID/Open ID.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 06 Jul 2024 10:08:24 GMT</pubDate><enclosure url="https://i.imgur.com/2TROtDc.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/2TROtDc.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[0. 초기화 과정 이해]]></title><description><![CDATA[ 
 <br><br><br>
기본 설정 클래스에 대해서 알아봅니다. 
<br><br>
핵심적인 두 개의 클래스가 초기화시 어떻게 동작하는지 알아봅니다. 
<br><br>
실행과정에서 매우 중요한 대리 클래스입니다. 어떻게 동작하는지 알아봅니다. 
<br><br>
]]></description><link>spring/security/초기화-과정-이해/0.-초기화-과정-이해.html</link><guid isPermaLink="false">Spring/Security/초기화 과정 이해/0. 초기화 과정 이해.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Fri, 21 Jun 2024 11:36:13 GMT</pubDate></item><item><title><![CDATA[1. Security에서 제공하는 기본 보안(자동설정)]]></title><description><![CDATA[ 
 <br><br>서버가 기동되면 스프링 시큐리티의 초기화 작업 및 기본 보안 설정이 이뤄집니다. 별도의 설정이나 코드를 작성하지 않아도 기본적인 웹 보안 기능이 현재 시스템에 연동되어서 동작합니다. <br><br>1: 모든 요청에 대해 인증여부(=로그인)을 검증하고 인증이 승인되어야 자원에 접근이 가능합니다.<br>
2: 인증방식은 폼 로그인 방식과 httpBasic 로그인 방식을 제공합니다.<br>
3: 인증을 시도할 수 있는 로그인 페이지가 자동적으로 생성되어 렌더링 됩니다.<br>
4: 인증 승인이 이뤄질 수 있도록 한 개의 계정이 기본적으로 제공됩니다. <br><br>실제로 어떻게 동작이 되는지 살펴보겠습니다. 다음과 같이 종속성을 설정합니다.<br>implementation 'org.springframework.boot:spring-boot-starter-security'  
implementation 'org.springframework.boot:spring-boot-starter-web'  
testImplementation 'org.springframework.boot:spring-boot-starter-test'  
testImplementation 'org.springframework.security:spring-security-test'
<br>spring boot start io에서 security와 web을 검색하여 두개의 종속성을 추가합니다. <br>이후 테스트용도 컨트롤러를 생성합니다. <br>@RestController  
public class TestController {  
  
    @GetMapping("/test")  
    public String getTest(){  
        return "test";  
    }  
}

<br>이 상태로 바로 Spring 서버를 기동해보겠습니다.<br>
서버가 쭉쭉 기동되다보면 아래 사진과 같이 랜덤으로 생성된 비밀번호가 보입니다. 기본 웹 보안 기능 항목에서의 4번에서 살펴보았던 기본 제공되는 계정의 비밀번호입니다.<br>
<img src="https://i.imgur.com/TH3QKqa.png" referrerpolicy="no-referrer"><br>localhost:8080/test로 접속하면 자동으로 localhost:8080/login으로 리다이렉션 되면서 다음과 같은 창이 뜹니다.<br>
<img src="https://i.imgur.com/GvKuQ1A.png" referrerpolicy="no-referrer"><br>
아이디는 user, 비밀번호는 아까 콘솔에서 보았던 값을 입력하면<br>
<img src="https://i.imgur.com/izoDj9W.png" referrerpolicy="no-referrer"><br>
정상적으로 반환하는 것을 확인할 수 있습니다. <br><br><br>먼저 SpringBootWebSecurityConfiguration에 대해서 알아보겠습니다. SpringBootWebSecurityConfiguration은 Spring Security의 기본적인 웹 보안 구성을 제공하는 클래스입니다. Spring Boot에서는 보안을 손쉽게 설정할 수 있도록 여러 자동 설정 기능을 제공합니다. 이 클래스는 Spring Boot 애플리케이션에서 웹 보안을 설정할 때 핵심적인 역할을 합니다.<br>자동 설정<br>
: SpringBootWebSecurityConfiguration은 Spring Boot의 자동 설정 기능을 이용하여 기본적인 웹 보안을 설정합니다. 기본 로그인 페이지, CSRF 보호, HTTP 기본 인증 등의 설정을 자동으로 구성합니다.<br>기본 보안 설정<br>
: 기본적으로 Spring Security의 많은 보안 기능을 활성화합니다. 예를 들어, CSRF 보호, HTTP 기본 인증, 세션 관리 등의 설정이 기본적으로 활성화됩니다.<br>커스터마이징<br>
: 필요에 따라 사용자 정의 설정을 추가할 수 있습니다. @Configuration과 @EnableWebSecurity 어노테이션을 사용하여 보안 구성을 오버라이드하거나 추가 설정을 할 수 있습니다.<br><br>SpringBootWebSecurityConfiguration 하위의 스태틱 클래스입니다. Spring Security에서 보안 필터 체인을 설정하고 구성하기 위해 사용되는 클래스나 설정 파일을 의미합니다. 이를 통해 웹 애플리케이션에 대한 보안 설정을 세부적으로 정의할 수 있습니다. SecurityFilterChainConfiguration의 주요 목적은 다양한 보안 필터를 체인 형태로 연결하여 요청이 처리되는 과정에서 단계별로 보안 검사를 수행하는 것입니다.<br>기본 제공되는 구현체의 기본 옵션<br>@Bean  
@Order(SecurityProperties.BASIC_AUTH_ORDER)  
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) 
throws Exception {  
   
   http.authorizeHttpRequests(
	   (requests) 
		   -&gt; requests.anyRequest().authenticated()
   );  
   http.formLogin(withDefaults());  
   http.httpBasic(withDefaults());  
   return http.build();  
}
<br>1: 모든 요청에 대해 인증 검증 과정을 거칩니다.<br>
2: 모든 요청에 대해 인증 방식을 폼 로그인으로 처리합니다.<br>
3; httpBasicd은 HTTP 기본인증을 활성화 합니다. <br><br>@Configuration(proxyBeanMethods = false)  
@ConditionalOnDefaultWebSecurity  
static class SecurityFilterChainConfiguration {
<br>SpringBootWebSecurityConfiguration 클래스에는 총 두가지의 어노테이션이 있습니다. ConditionalOnDefaultWebSecurity 어노테이션은 웹 보안 설정을 조건부로 적용하기 위한 어노테이션입니다. 좀 더 자세히 살펴보겠습니다. <br>@Target({ ElementType.TYPE, ElementType.METHOD })  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
@Conditional(DefaultWebSecurityCondition.class)  
public @interface ConditionalOnDefaultWebSecurity {  
  
}
<br>@Conditional(DefaultWebSecurityCondition.class) 에 인자로 받은 클래스 내부 설정값을 따라 웹 보안 설정을 어떤 상황에서 적용할지 결정합니다. <br>class DefaultWebSecurityCondition extends AllNestedConditions {  
  
   DefaultWebSecurityCondition() {  
      super(ConfigurationPhase.REGISTER_BEAN);  
   }  
  
   @ConditionalOnClass({ SecurityFilterChain.class, HttpSecurity.class })  
   static class Classes {  
  
   }  
  
   @ConditionalOnMissingBean({ SecurityFilterChain.class })  
   static class Beans {  
  
   }  
  
}
<br>총 2가지 조건을 모두 만족할 경우에만, Spring Security의 기본 보안 작동이 동작합니다. 첫번째, 클래스 패스에 SecurityFilterChain.class, HttpSecurity.class 2가지 클래스가 동작하느냐 (=security 의존성을 추가했는가) 두번째, SecurityFilterChain이 Bean으로 등록되어 있지 않은 경우 모두 만족해야 동작합니다. <br><br>기본제공 유저는 SecurityProperties 내부 static class인 user입니다. <br>@ConfigurationProperties(prefix = "spring.security")  
public class SecurityProperties {
<br>@Configuration 어노테이션을 이용해 yaml, properties 설정 파일에 있는 값을 읽어옵니다. 이 때 spring.security로 시작되는 모든 값을 가져옵니다. <br><br>public static class User {  
  
	private String name = "user";  
  
	private String password = UUID.randomUUID().toString();  
  
   private List&lt;String&gt; roles = new ArrayList&lt;&gt;();  
  
   private boolean passwordGenerated = true;  
  
   public String getName() {  
      return this.name;  
   }  
  
   public void setName(String name) {  
      this.name = name;  
   }  
  
   public String getPassword() {  
      return this.password;  
   }  
  
   public void setPassword(String password) {  
      if (!StringUtils.hasLength(password)) {  
         return;  
      }  
      this.passwordGenerated = false;  
      this.password = password;  
   }  
  
   public List&lt;String&gt; getRoles() {  
      return this.roles;  
   }  
  
   public void setRoles(List&lt;String&gt; roles) {  
      this.roles = new ArrayList&lt;&gt;(roles);  
   }  
  
   public boolean isPasswordGenerated() {  
      return this.passwordGenerated;  
   }  
  
}
<br>구현체에서 보는 것과 같이 기본 유저 이름은 user, 비밀번호는 uuid를 이용해서 생성되고 있는 것을 확인할 수 있습니다. ]]></description><link>spring/security/초기화-과정-이해/1.-security에서-제공하는-기본-보안(자동설정).html</link><guid isPermaLink="false">Spring/Security/초기화 과정 이해/1. Security에서 제공하는 기본 보안(자동설정).md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Fri, 21 Jun 2024 12:22:30 GMT</pubDate><enclosure url="https://i.imgur.com/TH3QKqa.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/TH3QKqa.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2. SecurityBuilder와 SecurityConfigure]]></title><description><![CDATA[ 
 <br><br>SecurityBuilder는 빌더 클래스입니다. Security를 구성하는 빈 객체와 설정 클래스를 생성하는 역할을 하며, 대표적으로 WebSecurity와 HttpSecurity가 있습니다. <br><br><img src="https://i.imgur.com/CfQX18L.png" referrerpolicy="no-referrer"><br>
(붉은색이 인터페이스, 검은색이 구현체를 의미합니다.)<br>SecurityConfigurer는 Http 요청과 관련된 보안 처리를 담당하는 필터들을 생성하고 여러 초기화 설정에 관여합니다. SecurityBuilder는 SecurityConfigurer를 참조하고 있으며 인증 및 인가 초기화 작업은 SecurityConfigurer가 담당합니다. <br><br>일반적으로 필터를 통해서 인증과 인가 과정을 구현합니다. 이 필터를 생성하는 것이 SecurityConfigure의 역할입니다.<br>
<img src="https://i.imgur.com/axymfmG.png" referrerpolicy="no-referrer"><br>
즉, Security Builder 클래스가 설정 클래스(Security Configure)를 생성한 다음,  여러가지 설정클래스에서 객체 생성을 하면서 초기 작업을 이끌어갑니다. SecurityConfigure의 내부에는 두가지 메서드 (init, configure)가 있습니다. 두 개의 메서드를 이용해 초기화를 진행하며 필터를 생성합니다. <br><br>아래 코드는 HttpSecurityConfiguration 클래스 내 httpSecurity 메서드의 일부입니다. <br>http  
   .csrf(withDefaults())  
   .addFilter(webAsyncManagerIntegrationFilter)  
   .exceptionHandling(withDefaults())  
   .headers(withDefaults())  
   .sessionManagement(withDefaults())  
   .securityContext(withDefaults())  
   .requestCache(withDefaults())  
   .anonymous(withDefaults())  
   .servletApi(withDefaults())  
   .apply(new DefaultLoginPageConfigurer&lt;&gt;());
<br>각각의 메서드를 상세하게 보면 (예시로 csrf 메서드를 확인해봅시다.)<br>public HttpSecurity csrf(
	Customizer&lt;CsrfConfigurer&lt;HttpSecurity&gt;&gt; csrfCustomizer
) throws Exception {  
   ApplicationContext context = getContext();  
   csrfCustomizer.customize(getOrApply(new CsrfConfigurer&lt;&gt;(context)));  
   return HttpSecurity.this;  
}
<br>처럼 Configure 클래스 파일을 생성한 후 http의 메서드에서 인자로 받아 초기화 작업을 실행합니다. 이후 http 빈 객체를 생성하게 됩니다. 이후 생성된 http빈은 SpringBootWebSecurityConfiguration 클래스의 defaultSecurityFilterChain메서드에서 주입받아 사용합니다. <br>@Bean  
@Order(SecurityProperties.BASIC_AUTH_ORDER)  
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {  
   http.authorizeHttpRequests((requests) -&gt; requests.anyRequest().authenticated());  
   http.formLogin(withDefaults());  
   http.httpBasic(withDefaults());  
   return http.build();  
}
]]></description><link>spring/security/초기화-과정-이해/2.-securitybuilder와-securityconfigure.html</link><guid isPermaLink="false">Spring/Security/초기화 과정 이해/2. SecurityBuilder와 SecurityConfigure.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Fri, 21 Jun 2024 13:01:34 GMT</pubDate><enclosure url="https://i.imgur.com/CfQX18L.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/CfQX18L.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[사용자 정의 보안 설정하기]]></title><description><![CDATA[ 
 <br><br>한 개 이상의 SecurityFilterChaing 타입의 빈을 정의한 후 인증 API 및 인가 API를 설정합니다. <br><img src="https://i.imgur.com/c6Rl5Y1.png" referrerpolicy="no-referrer"><br>하나 이상의 SecufiryFilterChain 타입의 빈이 있어야 정상적으로 처리됩니다. 유저가 직접 설정하지 않을 경우에는 Security에서 자동 설정에 의해 기본 빈 하나가 생성됩니다. SecurityFilterChain을 빈으로 정의하면 자동설정은 이루어지지 않습니다. <br><br>실제 예제 코드를 통해 확인해보겠습니다. <br>@EnableWebSecurity  
@Configuration  
public class SecurityConfig {  
  
    @Bean  
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception{  
  
        http.authorizeHttpRequests(auth-&gt; auth.anyRequest().authenticated())  
                //폼로그인 방식을 default 로 사용   
.formLogin(Customizer.withDefaults());  
  
  
        return http.build();  
    }  
  
}
<br>모든 설정 코드는 시큐리티 7버전부터는 람다 형식만 지원합니다. <br><br><br>spring:
  security:
    user:
      name: user
      password: 1111
      roles: USER

<br><br>@Bean
public InMemoryUserDetailsManager inMemoryUserDetailsManager() {

    UserDetails user = User.withUsername("user")
        .password("{noop}1111")
        .authorities("ROLE_USER")
        .build();

    return new InMemoryUserDetailsManager(user);
}

<br>위 코드를 이용하면 메모리 상에서 사용자가 정의한 유저 정보를 저장하고 있습니다. ]]></description><link>spring/security/초기화-과정-이해/3.-사용자-정의-보안-설정하기.html</link><guid isPermaLink="false">Spring/Security/초기화 과정 이해/3. 사용자 정의 보안 설정하기.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 06 Jul 2024 12:56:23 GMT</pubDate><enclosure url="https://i.imgur.com/c6Rl5Y1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/c6Rl5Y1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4. 인증 프로세스]]></title><description><![CDATA[ 
 <br><br><br><br>HTTP 기반의 폼 로그인 인증 매커니즘을 활성하는 API입니다. 사용자 정의 로그인 페이지를 쉽게 구현할 수 있습니다. 기본적으로는 스프링 시큐리티가 제공하는 기본 로그인 페이지를 사용하며 사용자 이름과 비밀번호 필드가 포함된 간단한 로그인 양식을 제공합니다. 사용자는 웹 폼을 통해 자격 증명(사용자 이름과 비밀번호)를 제공하고 Spring Security는 HttpServletRequest에서 이 값을 읽어옵니다. <br><br><img src="https://i.imgur.com/KDeFoTB.png" referrerpolicy="no-referrer"><br>1: 권한 검사 필터는 현재 권한으로 /user를 호출할 수 있는지 검사합니다.<br>
2: 당연히 로그인이 안된 상태이므로 권한 필터를 통과하지 못해 접근 예외가 발생합니다.<br>
3: 예외처리 필터가 발생한 예외를 처리합니다.<br>
4: AuthenticationEntryPoint가 로그인할 수 있는 페이지로 이동시킵니다. (로그인 페이지 리다이렉트)<br>
5: 로그인 페이지에서 아이디와 비밀번호를 입력받아 서버에 재요청합니다. <br><br><img src="https://i.imgur.com/QHWggyt.png" referrerpolicy="no-referrer"><br>
UsernamePasswordAuthenticationFilter가 생성되어 폼 방식의 인증 처리를 담당하게 됩니다. ]]></description><link>spring/security/초기화-과정-이해/4.-인증-프로세스.html</link><guid isPermaLink="false">Spring/Security/초기화 과정 이해/4. 인증 프로세스.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 06 Jul 2024 13:05:01 GMT</pubDate><enclosure url="https://i.imgur.com/KDeFoTB.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/KDeFoTB.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Untitled]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br><br><br><br><br><br>참조1.build()로 빌더 클래스를 생성
2. 설정 클래스를 생성 3. init(builder) / configure(builder)
메서드로 초기화 작업 진행]]></description><link>spring/security/etc/untitled.html</link><guid isPermaLink="false">Spring/Security/ETc/Untitled.canvas</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Fri, 21 Jun 2024 12:38:54 GMT</pubDate></item><item><title><![CDATA[Security]]></title><description><![CDATA[ 
 <br><br>
시큐리티 초기화 시 설정되는 빈 또는 구조와 흐름을 살펴봅니다. 
<br><br>
폼인증, 기본인증, 기억하기 등 다양한 인증 방식에 대해서 알아봅시다. 
<br><br>
인증 처리구조의 원리와 프로세스, 클래스간 관계를 알아봅니다. 
<br><br>
인증 상태를 저장, 참조, 삭제하는 여러가지 방법에 대해서 알아봅니다. 
<br><br>
인증 상태를 유지하기 위한 기본 설정인 세션에 대해서 알아봅니다. 
<br><br>
인증과 인가 예외가 어떻게 발생하고 처리되는지 알아봅니다. 
<br><br>
악성 사용자의 침입을 막는 방법을 살펴봅니다. 
<br><br>
권한을 설정, 부여, 관리할 수 있는 방법에 대해 알아봅니다. 
<br><br>
인가 처리구조 및 원리, 클래스간 관계에 대해서 알아봅니다. 
<br><br>
인증과 인가 이벤트에 대해서 알아봅니다. 
<br><br>
서블릿이나 MVC에 확장하는 방법을 알아봅니다. 
<br><br>
다중 보안 설정, CustomDSLs에 대해서 알아봅니다. 
<br><br>
회원 인증 및 관리 시스템을 직접 구현해봅니다. 
]]></description><link>spring/security/security.html</link><guid isPermaLink="false">Spring/Security/Security.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Fri, 21 Jun 2024 11:32:54 GMT</pubDate></item><item><title><![CDATA[AOP]]></title><description><![CDATA[ 
 <br><br>]]></description><link>spring/aop.html</link><guid isPermaLink="false">Spring/AOP.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 15 Jun 2024 05:46:17 GMT</pubDate></item><item><title><![CDATA[Untitled]]></title><description><![CDATA[ 
 ]]></description><link>spring/untitled.html</link><guid isPermaLink="false">Spring/Untitled.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sat, 06 Jul 2024 09:30:14 GMT</pubDate></item><item><title><![CDATA[코딩테스트 풀이법]]></title><description><![CDATA[ 
 <br><br><br><br><img src="https://i.imgur.com/WwCBhT7.png" referrerpolicy="no-referrer"><br><br><img src="https://i.imgur.com/6d7CvcV.png" referrerpolicy="no-referrer"><br><br><img src="https://i.imgur.com/WFoAZaQ.png" referrerpolicy="no-referrer"><br><br><br><img src="https://i.imgur.com/1fdPgyc.png" referrerpolicy="no-referrer"><br><br><br>시작점 2개를 먼저 큐에 넣고 시작합니다. <br><br><br><br>BFS를 사용할 때 큐에 쌓이는 순서는 반드시 거리순입니다. <br><br><img src="https://i.imgur.com/H9DFlMj.png" referrerpolicy="no-referrer"><br><br>
<br>임의의 정점 1개 구하기 
<br>정점 x에서 가장 먼 정점y 구하기 
<br>정점 y에서 가장 먼 정점 z 구하기 (=트리의 지름)
<br><br>dist 배열을 이용해 거리를 구하고 가장 긴 거리를 갖는 노드를 반환한다. <br><br><br><br>
<br>들어오는 간선이 없는 루트 노드가 정확히 1개 존재하는가
<br>모든 노드는 반드시 단 하나의 들어오는 간선이 있다. 
<br>루트 노드에서 모든 노드를 방문할 수 있으며 이러한 경로는 유일하다. 
<br><br>
int binarySearch(int[] arr, int target){  
  
    int l = 0;  
    int h = arr.length;  
  
    while(h&gt;l){  
        int mid = (l+h)/2;  
        if(arr[mid]==target){  
            return mid;  
        }else if(arr[mid]&gt;target){  
            h = mid;  
        }else{  
            l = mid+1;  
        }  
    }  
    return -1;  
}
<br><br>int upperIdx(int target, int[] arr){
	int l = 0;
	int h = arr.length;
	while(h&gt;l){
		int mid = (l+h)/2;
		if(arr[mid]&gt;target) h = mid;
		else l = mid+1;
	}
	
	return l;

}
<br><img src="https://i.imgur.com/r6XSZRm.png" referrerpolicy="no-referrer"><br><br>int lowerIdx(int target, int[] arr){
	int l = 0;
	int h = arr.length;
	while(h&gt;l){
		int mid = (l+h)/2;
		if(arr[mid]&gt;=target) h = mid;
		else l = mid+1;
	}
	
	return l;

}
<br><br>
<br>값의 등장 횟수 = 정렬이 유지되는 제일 왼쪽과 오른쪽 인덱스 차이
<br><br><br>
각 배열의 값보다는 요소들의 대소 관계만 알고 싶을 때 크기순 인덱스로 붙여버린다. 
<br>
<br>중복값을 지운다. 
<br>이진탐색으로 해당값의 인덱스를 찾는다.
<br><br>private static int[] getArr() throws IOException{  
    return Arrays.stream(buffer.readLine().split("\\s+"))  
            .mapToInt(Integer::parseInt)  
            .toArray();  
}
<br><br>// 스트림을 사용하여 결과를 StringBuilder에 추가  
String result = Arrays.stream(compressedPositions)  
        .mapToObj(String::valueOf)  
        .collect(Collectors.joining(" "));
<br><br>int[] compressedPositions = IntStream.range(0, n)  
        .map(i -&gt; Collections.binarySearch(uniquePositions, positions[i]))  
        .toArray();
<br><br>private static long getAnswer(int[] costs, int limit){  
    long l = 0;  
    long h = Arrays.stream(costs).sum();  
  
    while(h&gt;l){  
        long mid = (h+l)/2;  
  
        if(isValid(mid, costs, limit)){  
            h=mid;  
  
        }else{  
            l=mid+1;  
        }  
    }  
  
    return l;  
}
<br><br>private static long get(long[] lengths, long maxLength, long numOfOrder){  
    long l = 0;  
    long h = maxLength;  
  
    while(h&gt;l){  
        long mid= (l+h+1)/2;  
  
        if(isValid(mid, numOfOrder, lengths)){  
            l=mid;  
        }else{  
            h=mid-1;  
        }  
    }  
  
  
    return l;  
  
}
<br><br>안에서 밖으로 이동하는 로직을 예시로 설명합니다. <br><img alt="Pasted image 20240803123705.png" src="prj/cloudy/pasted-image-20240803123705.png"><br>방향의 사이클이 전부 완료 후 이동 횟수가 1씩 증가합니다. <br>⬆︎ ➡︎ 로 이동할 때는 1, 3, 5 ... 칸씩 이동하고,&nbsp;<br>⬇︎ ⬅︎ 로 이동할 때는 2, 4, 6 ... 칸씩 이동합니다.<br>밖에서 안으로 이동하는 경우 위와 반대로 생각하면 되므로 방향만 바꿔줍니다. <br>

//상우하좌 순서대로 넣습니다. 
int[] dx = {-1,0,1,0};
int[] dy = {0,1,0,-1};

int currentX = n/2;
int currentY = n/2; 
int moveDir = 0;
int moveNum = 1; 

while(currentX&gt;0||currentY&gt;0){
	//하나의 방향 이동 
	for(int i=0; i&lt;moveNum; i++){
		//안에서 밖으로 이동하는 달팽이의 경우 
		//이동하는 도중 0,0으로 오게 되면 움직이는 것을 종료한다. 
		if(currentX==0&amp;&amp;currentY==0)break; 	
	}
	//방향을 전환합니다. 
	moveDir = (moveDir+1)%4;

	//윗 방향 또는 아랫 방향이 될 때마다 움직여야할 횟수가 1증가합니다. 
	if(moveDir==0||moveDir==2) moveNum++;

}


반복문 시작 조정isUsed 사용isUsed 사용dis[nx][ny] = dis[current.x][current.y]+1큐에서 뺄때마다 세기시작점 위치 세기]]></description><link>코딩테스트-풀이법.html</link><guid isPermaLink="false">코딩테스트 풀이법.canvas</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Sun, 11 Aug 2024 13:54:13 GMT</pubDate><enclosure url="https://i.imgur.com/WwCBhT7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/WwCBhT7.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Dynamic Programming 총정리]]></title><description><![CDATA[ 
 <br><br><br>
<br>지금까지 선택한 동전의 합이 같은 경우 
<br>지금까지 사용한 동전의 개수가 같은 경우<br>
: 지금까지 선택한 동전의 합이 같다면 개수가 많을수록 좋습니다. 
<br><br>dp[i] = 지금까지 선택한 동전의 합 i일 때, 가능한 최대 동전 개수
<br>최종합 i보다 마지막으로 사용한 동전 coin[j]가 작아야합니다. <br>dp[i] = max (dp[i-coin[j]]+1) 
(i&gt;=coin[j]인 경우+ 1&lt;=j&lt;n)
<br><br>n=동전 갯수<br>
m=동전의 합 <br>for(int i=1; i&lt;=m; i++)
{ 
	for(int j=1; j&lt;=n; j++)
	{ 
		if(i&gt;=coin[j])
		{ 
			if(dp[i-coin[j]] == 최소) continue; 
			dp[i] = Math.max(dp[i], dp[i-coin[j]]+1); 
		} 
	} 
}
<br>
<br>동전의 합 순회 
<br>동전 종류 순회 
<br><br><br>dp[i] = 지금까지 선택한 동전의 합 i일 때, 가능한 최소 동전 갯수 
<br>동전 거스르기 구현방식에서 반복문만 거꾸로 돌리면 된다.<br>
-&gt; 동일한 원소를 2번 이상 스는 경우에 대한 갱신이 일어나지 않는다.<br>
-&gt; 각 원소들을 1번씩만 써서 만들 수 있는 합을 구할 수 있다. <br><br>n=동전 갯수<br>
m=동전의 합 <br>for(int j=1; j&lt;=n; j++)
{ 
	for(int i=m; i&gt;=0; i--)
	{ 
		if(i-coin[j]&gt;=0)
		{ 
			if(dp[i-coin[j]] == max) continue; 
			dp[i] = Math.min(dp[i], dp[i-coin[j]]); 
		} 
	} 
}
<br>
<br>동전 순회 
<br>동전의 합 순회
<br><br><br>
<br>지금까지 선택한 동전의 합이 같은 경우 
<br>지금까지 사용한 동전의 개수가 같은 경우<br>
: 지금까지 선택한 동전의 합이 같다면 개수가 많을수록 좋습니다. 
<br><br>dp[i] = 지금까지 선택한 동전의 합 i일 때, 가능한 최대 동전 개수
<br>최종합 i보다 마지막으로 사용한 동전 coin[j]가 작아야합니다. <br>dp[i] = max (dp[i-coin[j]]+1) 
(i&gt;=coin[j]인 경우+ 1&lt;=j&lt;n)
<br><br>n=동전 갯수<br>
m=동전의 합 <br>int n = Integer.valueOf(buffer.readLine());  
//DP[I]= 동전 합이 i일 때 최소 동전 갯수  
  
int[] coins = {2,5};  
int[] dp = new int[n+1];  
Arrays.fill(dp, n+1);  
  
dp[0] = 0;  
for(int sum=0; sum&lt;=n; sum++){  
    for(int coin :coins ){  
        if(coin&gt;sum)continue;  
  
        dp[sum] = Math.min( dp[sum], dp[sum-coin]+1);  
    }  
}
<br>
<br>동전의 합 순회 
<br>동전 종류 순회 
<br><br><br>
i번째 보석을 사용했을 때, 안했을 때 중 사용했을 때만 고려하면된다. 
<br>dp[i-1][j-weight[i]]+ value[i]값이 갱신되는 경우가 아니라면 dp[i-1][j] 값은 그대로 넘어온다.<br>
무게의 합만 관리하는 1차원 배열만 사용해도 된다. <br><br>dp[j] = 지금까지 고른 보석 무게의 합이 J일 때 얻을 수 있는 최대가치 
<br><br>
// 점화식에 따라 값을 채워줍니다.
for(int weight = 1; weight &lt;= m; i++) {
    // 보석 무게의 합 i를 만들기 위해
    // 마지막으로 길이가 j번 보석을 고른 경우에 대해 조사합니다.
    // 그 중 얻을 수 있는 최대 가치를 계산합니다.
    for(int idx = 0; idx &lt; n; idx++) {
        // i가 j번 보석의 무게인 weight[j]보다는 같거나 커야만
        // 가능한 경우입니다.
        if(i &gt;= weight[idx])
            dp[weight] = Math.max(dp[weight], dp[weight - weight[idx]] + value[idx]);
    }
}

<br>for(int i = 0; i &lt; n; i++) 
{ 
	for(int w = weights[i]; w &lt;= W; w++) 
	{ 
		dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); 
	} 
}
<br>dp[j-weight[i]] 값이 i-1번째 보석까지만 고려한 값인지 i번째 보석까지 포함한 값인지를 구분할 수 없음. <br><br>
int[] w = new int[n+1];  
int[] v = new int[n+1];  
  
int[] dp = new int[k+1];  
  
for(int i=1; i&lt;=n; i++) {  
    w[i] = sc.nextInt();  
    v[i] = sc.nextInt();  
}  
  
  
  
// DP 초기화  
for(int item=1; item&lt;=n; item++) {  
    for(int weight=k; weight&gt;=w[item]; weight--) {  
        dp[weight] = Math.max(dp[weight], dp[weight-w[item]]+v[item]);  
    }  
}  
  
int max = 0;  
for(int  weight = 0; weight&lt;=k; weight++) {  
    max = Math.max(max, dp[weight]);  
}  
System.out.println(max);

<br>
<br>
<br>for(int i = 0; i &lt; n; i++) 
{ 
	for(int w = W; w &gt;= weights[i]; w--) 
	{ 
		dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]); 
	}
}

<br>
<br>
<br>각 보석을 한 번만 사용할 수 있으므로, 이미 고려된 보석을 다시 사용하면 안 됩니다.
<br>dp[w - weight[i]]의 값을 갱신할 때, 이 값이 현재 보석을 추가하기 전의 값이어야 합니다.
<br>따라서, 뒤에서부터 접근하여 이미 업데이트된 값을 덮어쓰지 않도록 합니다.
<br><br>
<br>0-1 배낭 문제: 각 보석을 한 번만 사용할 수 있기 때문에, 이전 상태를 기반으로 현재 상태를 계산해야 합니다. 이를 위해 무게의 뒤에서부터 접근합니다.
<br>완전 배낭 문제: 동일한 보석을 여러 번 사용할 수 있기 때문에, 현재 상태를 기반으로 미래 상태를 계산해야 합니다. 이를 위해 무게의 앞에서부터 접근합니다.
<br><br><br>
<br>지금까지 고려한 보석의 위치 
<br>지금까지 고른 보석 무게의합<br>
: 지금까지 선택한 보석 무게의 합이 같고 고려한 보석의 위치가 같다면 가치가 클수록 좋습니다. 
<br><br>dp[i][j] = i번째 보석까지 고려했고, 지금까지 고른 보석 무게의 합이 j일때, 얻을 수 있는 최대가치
<br><br><br>dp[i][j] = dp[i-1][j-weights[i]] + value[i]
<br><br>dp[i][j] = dp[i-1][j]
<br><br>
int[] weights = new int[n];  
int[] values = new int[n];  
  
for (int i = 0; i &lt; n; i++) {  
    tokens = new StringTokenizer(buffer.readLine());  
    weights[i] = Integer.parseInt(tokens.nextToken());  
    values[i] = Integer.parseInt(tokens.nextToken());  
}  
  
int[][] dp = new int[n + 1][k + 1];  
  
// DP 초기화  
for (int i = 0; i &lt;= n; i++) {  
    for (int j = 0; j &lt;= k; j++) {  
        dp[i][j] = 0;  
    }  
}  
  
// DP 수행  
for (int i = 1; i &lt;= n; i++) {  
    for (int w = 0; w &lt;= k; w++) {  
        if (w &gt;= weights[i - 1]) {  
            dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);  
        } else {  
            dp[i][w] = dp[i - 1][w];  
        }  
    }  
}
  
System.out.println(dp[n][k]);

<br><img src="https://i.imgur.com/VkQc3QQ.png" referrerpolicy="no-referrer"><br><img src="https://i.imgur.com/tFYT5JI.png" referrerpolicy="no-referrer"><br><img src="https://i.imgur.com/mcDFKRJ.png" referrerpolicy="no-referrer"><br><br><br>
<br>지금까지 선택한 동전의 합이 같은 경우 
<br>지금까지 사용한 동전의 개수가 같은 경우<br>
: 지금까지 선택한 동전의 합이 같다면 개수가 많을수록 좋습니다. 
<br><br>dp[i] = 지금까지 선택한 동전의 합 i일 때, 가능한 동전 조합 가짓수 
<br>현재 확인중인 동전 가치 ~ 전체 총합까지 순회 
dp[tot] += dp[tot - coin];
<br>현재 금액 tot를 만들기 위해 동전 coin을 추가했을 때의 경우의ㅣ 수를 더합니다. <br><br> 
int[] dp = new int[targetTot + 1]; dp[0] = 1; // 0원을 만드는 방법은 1가지 
for(int coin : coins) 
{ 
  for(int tot = coin; tot &lt;= targetTot; tot++) 
  { 
	  dp[tot] += dp[tot - coin]; 
  } 
}

]]></description><link>dynamic-programming-총정리.html</link><guid isPermaLink="false">Dynamic Programming 총정리.canvas</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Thu, 13 Jun 2024 13:02:04 GMT</pubDate><enclosure url="https://i.imgur.com/VkQc3QQ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/VkQc3QQ.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[<font color="#8064a2">Profile.</font>]]></title><description><![CDATA[ 
 <br><br><br><br>
안녕하세요. 백엔드 개발자 김한주입니다.<br>
제 강점은 단순 기능 구현을 넘어 안정적인 상황을 목표로 개발하는 습관입니다.<br>
또한, 다양한 기술 스택을 효율적으로 결합하여 안정적인 시스템을 만들어 나갑니다.<br>
이를 위해 새로운 기술이나 도구를 습득하고 프로젝트에 적용하는 것에 있어서도 익숙합니다.
<br><br><br><br>1.<a data-href="Index 잘 쓰는 방법" href="db/rdb/index-잘-쓰는-방법.html" class="internal-link" target="_self" rel="noopener nofollow">Index 잘 쓰는 방법</a><br>
RDBMS에서 Index를 사용할 때 주의점과 팁을 알아봅니다.
<br>2.<a data-href="Hash 함부로 쓰면 메모리 터진다" href="알고리즘과-자료구조/hash-함부로-쓰면-메모리-터진다.html" class="internal-link" target="_self" rel="noopener nofollow">Hash 함부로 쓰면 메모리 터진다</a><br>
코테에서 Java의 HashSet을 사용시 메모리가 터질 수 있는 이유와 간단한 계산법을 알아봅니다.
<br>3.<a data-href="Flux를 활용한 SSE 구현기" href="prj/cloudy/flux를-활용한-sse-구현기.html" class="internal-link" target="_self" rel="noopener nofollow">Flux를 활용한 SSE 구현기</a><br>
Cloudy에서 챗봇 사용자 경험을 위해 Flux를 활용해 SSE를 적용한 개선기를 소개합니다.
<br>4.<a data-href="콘팅이 서비스를 잘게 쪼갠 이유" href="prj/conting/콘팅이-서비스를-잘게-쪼갠-이유.html" class="internal-link" target="_self" rel="noopener nofollow">콘팅이 서비스를 잘게 쪼갠 이유</a><br>
콘팅의 서비스가 잘게 쪼갠 근거와 그 방향성을 소개합니다. 
<br><br><br>
<br>KIST (Korea Institute of Science and Technology / AI &amp; Robot Lab) Intern (2022.09.03 ~ 2023.02.19)
<br>SSAFY (Samsung Software Academy Foy Youth) 10th Trainnee<br>
(2023.07~2024.07)
<br>SSAFY (Samsung Software Academy Foy Youth) 11th Coach<br>
(2024.07~2024.11)
<br><br><br>
<br>동계 한국방송미디어공학회 대학생 논문/캡스톤디자인 경진대회 최우수상 (2022.11.19)
<br>교내 캡스톤디자인 경진대회 우수상 (2023.01.16)
<br>신한은행 해커톤 본선진출 (2023..12)
<br>삼성 청년 SW 아카데미 1학기 관통 프로젝트 최우수상 (2023.11.24)
<br>삼성 청년 SW 아카데미 2학기 공통 프로젝트 우수상 (2024.2.29)
<br>삼성 청년 SW 아카데미 2학기 특화 프로젝트 최우수상 (2024.4.04)
<br>삼성 청년 SW 아카데미 2학기 기업연계 프로젝트 최우수상 (2024.6.06)
<br>삼성 청년 SW 아카데미 삼성전자 이사 우수상 (2024.6.26)
<br><br><br>
<br>한국데이터진흥원 SQL Developer 취득 (2022.12.09)
<br>제7차 현대 Softeer 정기 역량 진단(HSAT) Level3 취득(2023.08.11)
<br>삼성 SW 역량 검정 B형 취득 (2024.08.24)
<br><br><br><img src="https://i.imgur.com/1c4Jlsl.png" referrerpolicy="no-referrer"><br><br><br><img src="https://i.imgur.com/cehUtrI.png" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F1810b9fc-4174-48e5-b9c2-c6e1d1a13486%2FPasted_image_20241126094917.png?table=block&amp;id=14a066e7-e39d-80d5-8e13-dd273e6b0e1a&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fe190b8ca-ef4d-4cd3-8522-621fb50d2e56%2FPasted_image_20241126094948.png?table=block&amp;id=14a066e7-e39d-8061-af2f-cd0be40cbc13&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fd2e33ad7-475e-4014-acf0-372df4b4a51a%2FPasted_image_20241126095022.png?table=block&amp;id=14a066e7-e39d-8008-930c-cf349c7c0262&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fac0e6630-460f-4ac0-b96c-67cff5d8074e%2FPasted_image_20241126095044.png?table=block&amp;id=14a066e7-e39d-801e-808b-c525fa664214&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Febf17a55-ac06-45d5-a055-e77f975537b4%2FPasted_image_20241126095103.png?table=block&amp;id=14a066e7-e39d-805a-a607-fdf222c8d230&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F6c59b000-d7d6-401e-9d7b-463bfe30d512%2FPasted_image_20241126095944.png?table=block&amp;id=14a066e7-e39d-80bc-a09c-dcac5fef5ad0&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br>
<img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fc2f63fb2-cafe-4d10-b054-51a2f3abb241%2FPasted_image_20241126100006.png?table=block&amp;id=14a066e7-e39d-807d-838d-e3acfb8905ac&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br>
<img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F7cb010ec-d412-4786-9640-db426bc208aa%2FPasted_image_20241126100027.png?table=block&amp;id=14a066e7-e39d-80d4-ac0e-ced4124f857e&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1400&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fc1a332c8-b06a-4c1b-9fa4-9b294b3fef74%2FPasted_image_20241126100047.png?table=block&amp;id=14a066e7-e39d-8049-a99f-fb670aada0cb&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fa1a7678c-f845-4570-b7c8-ec088ac17cc7%2FPasted_image_20241126100110.png?table=block&amp;id=14a066e7-e39d-8096-bc6a-ea2aeb9c043d&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1380&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br>
<img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F1a0973e5-68e9-4465-88fb-0bf4c7273457%2FPasted_image_20241126100125.png?table=block&amp;id=14a066e7-e39d-809b-95c3-d9bdc322911a&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1380&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fba3990cd-390e-4f7a-8b2b-c40592835e57%2FPasted_image_20241126095200.png?table=block&amp;id=14a066e7-e39d-8094-ae18-dc36baea942d&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F18e5edd9-13ad-4e22-83f8-7632721859d9%2FPasted_image_20241126095216.png?table=block&amp;id=14a066e7-e39d-8031-8cd1-d0b38a1f3cd1&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F5d2a1be1-d618-4636-8762-8bf0dcfd4f5c%2FPasted_image_20241126095232.png?table=block&amp;id=14a066e7-e39d-8031-b3d1-f3f619c95cee&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fad0dc001-d2a4-4e50-b7b8-3d78e5ff9eef%2FPasted_image_20241126095253.png?table=block&amp;id=14a066e7-e39d-802a-99a5-cf33f0c24502&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1330&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br>
<img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F545ec7ce-0312-4edd-bb99-6ebe86ca1a04%2FPasted_image_20241126095348.png?table=block&amp;id=14a066e7-e39d-8049-9fb9-c32b105666d9&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1300&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2Fe851b834-dbfb-4662-b544-e62c2222f60b%2FPasted_image_20241126095405.png?table=block&amp;id=14a066e7-e39d-807e-a673-c54078a52b4a&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br>
<img src="" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F7fdcd346-070a-4e20-8cdf-5756a3932b8b%2FPasted_image_20241126095421.png?table=block&amp;id=14a066e7-e39d-80dd-9c0f-fb4e86fb033d&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer"><br><br><img src="https://coding-test.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fe7472e42-7118-406f-8758-f9c76b1cf86a%2F03fbf9ab-9c34-425a-b626-8f30d62b7124%2FPasted_image_20241126095437.png?table=block&amp;id=14a066e7-e39d-80bf-a382-c17f49e4de8d&amp;spaceId=e7472e42-7118-406f-8758-f9c76b1cf86a&amp;width=1420&amp;userId=&amp;cache=v2" referrerpolicy="no-referrer">]]></description><link>hanju&apos;s-study-note.html</link><guid isPermaLink="false">Hanju&apos;s Study Note.md</guid><dc:creator><![CDATA[1week]]></dc:creator><pubDate>Tue, 26 Nov 2024 01:37:14 GMT</pubDate><enclosure url="https://i.imgur.com/1c4Jlsl.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i.imgur.com/1c4Jlsl.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>